<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[南峰子的技术博客]]></title>
  <link href="http://southpeak.github.io/atom.xml" rel="self"/>
  <link href="http://southpeak.github.io/"/>
  <updated>2014-10-30T16:05:08+08:00</updated>
  <id>http://southpeak.github.io/</id>
  <author>
    <name><![CDATA[南峰子]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Objective-C Runtime 运行时之二：成员变量与属性]]></title>
    <link href="http://southpeak.github.io/blog/2014/10/30/objective-c-runtime-yun-xing-shi-zhi-er-:cheng-yuan-bian-liang-yu-shu-xing/"/>
    <updated>2014-10-30T16:03:21+08:00</updated>
    <id>http://southpeak.github.io/blog/2014/10/30/objective-c-runtime-yun-xing-shi-zhi-er-:cheng-yuan-bian-liang-yu-shu-xing</id>
    <content type="html"><![CDATA[<p>在前面一篇文章中，我们介绍了Runtime中与类和对象相关的内容，从这章开始，我们将讨论类实现细节相关的内容，主要包括类中成员变量，属性，方法，协议与分类的实现。</p>

<p>本章的主要内容将聚集在Runtime对成员变量与属性的处理。在讨论之前，我们先介绍一个重要的概念：类型编码。</p>

<h2>类型编码(Type Encoding)</h2>

<p>作为对Runtime的补充，编译器将每个方法的返回值和参数类型编码为一个字符串，并将其与方法的selector关联在一起。这种编码方案在其它情况下也是非常有用的，因此我们可以使用@encode编译器指令来获取它。当给定一个类型时，@encode返回这个类型的字符串编码。这些类型可以是诸如int、指针这样的基本类型，也可以是结构体、类等类型。事实上，任何可以作为sizeof()操作参数的类型都可以用于@encode()。</p>

<p>在Objective-C Runtime Programming Guide中的<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1">Type Encoding</a>一节中，列出了Objective-C中所有的类型编码。需要注意的是这些类型很多是与我们用于存档和分发的编码类型是相同的。但有一些不能在存档时使用。</p>

<p><em>注：Objective-C不支持long double类型。@encode(long double)返回d，与double是一样的。</em></p>

<p>一个数组的类型编码位于方括号中；其中包含数组元素的个数及元素类型。如以下示例：</p>

<pre><code>float a[] = {1.0, 2.0, 3.0};
NSLog(@"array encoding type: %s", @encode(typeof(a)));
</code></pre>

<p>输出是：</p>

<pre><code>2014-10-28 11:44:54.731 RuntimeTest[942:50791] array encoding type: [3f]
</code></pre>

<p>其它类型可参考<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1">Type Encoding</a>，在此不细说。</p>

<p>另外，还有些编码类型，@encode虽然不会直接返回它们，但它们可以作为协议中声明的方法的类型限定符。可以参考<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1">Type Encoding</a>。</p>

<p>对于属性而言，还会有一些特殊的类型编码，以表明属性是只读、拷贝、retain等等，详情可以参考<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html#//apple_ref/doc/uid/TP40008048-CH101-SW6">Property Type String</a>。</p>

<h2>成员变量、属性</h2>

<p>Runtime中关于成员变量和属性的相关数据结构并不多，只有三个，并且都很简单。不过还有个非常实用但可能经常被忽视的特性，即关联对象，我们将在这小节中详细讨论。</p>

<h3>基础数据类型</h3>

<h4>Ivar</h4>

<p>Ivar是表示实例变量的类型，其实际是一个指向objc_ivar结构体的指针，其定义如下：</p>

<pre><code>typedef struct objc_ivar *Ivar;

struct objc_ivar {
    char *ivar_name                 OBJC2_UNAVAILABLE;  // 变量名
    char *ivar_type                 OBJC2_UNAVAILABLE;  // 变量类型
    int ivar_offset                 OBJC2_UNAVAILABLE;  // 基地址偏移字节
#ifdef __LP64__
    int space                       OBJC2_UNAVAILABLE;
#endif
} 
</code></pre>

<h4>objc_property_t</h4>

<p>objc_property_t是表示Objective-C声明的属性的类型，其实际是指向objc_property结构体的指针，其定义如下：</p>

<pre><code>typedef struct objc_property *objc_property_t;
</code></pre>

<h4>objc_property_attribute_t</h4>

<p>objc_property_attribute_t定义了属性的特性(attribute)，它是一个结构体，定义如下：</p>

<pre><code>typedef struct {
    const char *name;           // 特性名
    const char *value;          // 特性值
} objc_property_attribute_t;
</code></pre>

<h3>关联对象(Associated Object)</h3>

<p>关联对象是Runtime中一个非常实用的特性，不过可能很容易被忽视。</p>

<p>关联对象类似于成员变量，不过是在运行时添加的。我们通常会把成员变量(Ivar)放在类声明的头文件中，或者放在类实现的@implementation后面。但这有一个缺点，我们不能在分类中添加成员变量。如果我们尝试在分类中添加新的成员变量，编译器会报错。</p>

<p>我们可能希望通过使用(甚至是滥用)全局变量来解决这个问题。但这些都不是Ivar，因为他们不会连接到一个单独的实例。因此，这种方法很少使用。</p>

<p>Objective-C针对这一问题，提供了一个解决方案：即关联对象(Associated Object)。</p>

<p>我们可以把关联对象想象成一个Objective-C对象(如字典)，这个对象通过给定的key连接到类的一个实例上。不过由于使用的是C接口，所以key是一个void指针(const void *)。我们还需要指定一个内存管理策略，以告诉Runtime如何管理这个对象的内存。这个内存管理的策略可以由以下值指定：</p>

<pre><code>OBJC_ASSOCIATION_ASSIGN
OBJC_ASSOCIATION_RETAIN_NONATOMIC
OBJC_ASSOCIATION_COPY_NONATOMIC
OBJC_ASSOCIATION_RETAIN
OBJC_ASSOCIATION_COPY
</code></pre>

<p>当宿主对象被释放时，会根据指定的内存管理策略来处理关联对象。如果指定的策略是assign，则宿主释放时，关联对象不会被释放；而如果指定的是retain或者是copy，则宿主释放时，关联对象会被释放。我们甚至可以选择是否是自动retain/copy。当我们需要在多个线程中处理访问关联对象的多线程代码时，这就非常有用了。</p>

<p>我们将一个对象连接到其它对象所需要做的就是下面两行代码：</p>

<pre><code>static char myKey;

objc_setAssociatedObject(self, &amp;myKey, anObject, OBJC_ASSOCIATION_RETAIN);
</code></pre>

<p>在这种情况下，self对象将获取一个新的关联的对象anObject，且内存管理策略是自动retain关联对象，当self对象释放时，会自动release关联对象。另外，如果我们使用同一个key来关联另外一个对象时，也会自动释放之前关联的对象，这种情况下，先前的关联对象会被妥善地处理掉，并且新的对象会使用它的内存。</p>

<pre><code>id anObject = objc_getAssociatedObject(self, &amp;myKey);
</code></pre>

<p>我们可以使用objc_removeAssociatedObjects函数来移除一个关联对象，或者使用objc_setAssociatedObject函数将key指定的关联对象设置为nil。</p>

<p>我们下面来用实例演示一下关联对象的使用方法。</p>

<p>假定我们想要动态地将一个Tap手势操作连接到任何UIView中，并且根据需要指定点击后的实际操作。这时候我们就可以将一个手势对象及操作的block对象关联到我们的UIView对象中。这项任务分两部分。首先，如果需要，我们要创建一个手势识别对象并将它及block做为关联对象。如下代码所示：</p>

<pre><code>- (void)setTapActionWithBlock:(void (^)(void))block
{
    UITapGestureRecognizer *gesture = objc_getAssociatedObject(self, &amp;kDTActionHandlerTapGestureKey);

    if (!gesture)
    {
        gesture = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(__handleActionForTapGesture:)];
        [self addGestureRecognizer:gesture];
        objc_setAssociatedObject(self, &amp;kDTActionHandlerTapGestureKey, gesture, OBJC_ASSOCIATION_RETAIN);
    }

    objc_setAssociatedObject(self, &amp;kDTActionHandlerTapBlockKey, block, OBJC_ASSOCIATION_COPY);
}
</code></pre>

<p>这段代码检测了手势识别的关联对象。如果没有，则创建并建立关联关系。同时，将传入的块对象连接到指定的key上。注意block对象的关联内存管理策略。</p>

<p>手势识别对象需要一个target和action，所以接下来我们定义处理方法：</p>

<pre><code>- (void)__handleActionForTapGesture:(UITapGestureRecognizer *)gesture
{
    if (gesture.state == UIGestureRecognizerStateRecognized)
    {
        void(^action)(void) = objc_getAssociatedObject(self, &amp;kDTActionHandlerTapBlockKey);

        if (action)
        {
            action();
        }
    }
}
</code></pre>

<p>我们需要检测手势识别对象的状态，因为我们只需要在点击手势被识别出来时才执行操作。</p>

<p>从上面的例子我们可以看到，关联对象使用起来并不复杂。它让我们可以动态地增强类现有的功能。我们可以在实际编码中灵活地运用这一特性。</p>

<h3>成员变量、属性的操作方法</h3>

<h4>成员变量</h4>

<p>成员变量操作包含以下函数：</p>

<pre><code>// 获取成员变量名
const char * ivar_getName ( Ivar v );

// 获取成员变量类型编码
const char * ivar_getTypeEncoding ( Ivar v );

// 获取成员变量的偏移量
ptrdiff_t ivar_getOffset ( Ivar v );
</code></pre>

<p>● ivar_getOffset函数，对于类型id或其它对象类型的实例变量，可以调用object_getIvar和object_setIvar来直接访问成员变量，而不使用偏移量。</p>

<h4>关联对象</h4>

<p>关联对象操作函数包括以下：</p>

<pre><code>// 设置关联对象
void objc_setAssociatedObject ( id object, const void *key, id value, objc_AssociationPolicy policy );

// 获取关联对象
id objc_getAssociatedObject ( id object, const void *key );

// 移除关联对象
void objc_removeAssociatedObjects ( id object );
</code></pre>

<p>关联对象及相关实例已经在前面讨论过了，在此不再重复。</p>

<h4>属性</h4>

<p>属性操作相关函数包括以下：</p>

<pre><code>// 获取属性名
const char * property_getName ( objc_property_t property );

// 获取属性特性描述字符串
const char * property_getAttributes ( objc_property_t property );

// 获取属性中指定的特性
char * property_copyAttributeValue ( objc_property_t property, const char *attributeName );

// 获取属性的特性列表
objc_property_attribute_t * property_copyAttributeList ( objc_property_t property, unsigned int *outCount );
</code></pre>

<p>● property_copyAttributeValue函数，返回的char *在使用完后需要调用free()释放。
● property_copyAttributeList函数，返回值在使用完后需要调用free()释放。</p>

<h2>实例</h2>

<p>假定这样一个场景，我们从服务端两个不同的接口获取相同的字典数据，但这两个接口是由两个人写的，相同的信息使用了不同的字段表示。我们在接收到数据时，可将这些数据保存在相同的对象中。对象类如下定义：</p>

<pre><code>@interface MyObject: NSObject

@property (nonatomic, copy) NSString    *   name;                  
@property (nonatomic, copy) NSString    *   status;                 

@end
</code></pre>

<p>接口A、B返回的字典数据如下所示：</p>

<pre><code>@{@"name1": "张三", @"status1": @"start"}

@{@"name2": "张三", @"status2": @"end"}
</code></pre>

<p>通常的方法是写两个方法分别做转换，不过如果能灵活地运用Runtime的话，可以只实现一个转换方法，为此，我们需要先定义一个映射字典(全局变量)</p>

<pre><code>static NSMutableDictionary *map = nil;

@implementation MyObject

+ (void)load
{
    map = [NSMutableDictionary dictionary];

    map[@"name1"]                = @"name";
    map[@"status1"]              = @"status";
    map[@"name2"]                = @"name";
    map[@"status2"]              = @"status";
}

@end
</code></pre>

<p>上面的代码将两个字典中不同的字段映射到MyObject中相同的属性上，这样，转换方法可如下处理：</p>

<pre><code>- (void)setDataWithDic:(NSDictionary *)dic
{
    [dic enumerateKeysAndObjectsUsingBlock:^(NSString *key, id obj, BOOL *stop) {

        NSString *propertyKey = [self propertyForKey:key];

        if (propertyKey)
        {
            objc_property_t property = class_getProperty([self class], [propertyKey UTF8String]);

            // TODO: 针对特殊数据类型做处理
            NSString *attributeString = [NSString stringWithCString:property_getAttributes(property) encoding:NSUTF8StringEncoding];

            ...

            [self setValue:obj forKey:propertyKey];
        }
    }];
}
</code></pre>

<p>当然，一个属性能否通过上面这种方式来处理的前提是其支持KVC。</p>

<h2>小结</h2>

<p>本章中我们讨论了Runtime中与成员变量和属性相关的内容。成员变量与属性是类的数据基础，合理地使用Runtime中的相关操作能让我们更加灵活地来处理与类数据相关的工作。</p>

<h2>参考</h2>

<ol>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html">Objective-C Runtime Programming Guide</a></li>
<li><a href="http://www.cocoanetics.com/2012/06/associated-objects/">Associated Objects</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C Runtime 运行时之一：类与对象]]></title>
    <link href="http://southpeak.github.io/blog/2014/10/25/objective-c-runtime-yun-xing-shi-zhi-lei-yu-dui-xiang/"/>
    <updated>2014-10-25T21:00:05+08:00</updated>
    <id>http://southpeak.github.io/blog/2014/10/25/objective-c-runtime-yun-xing-shi-zhi-lei-yu-dui-xiang</id>
    <content type="html"><![CDATA[<p>Objective-C语言是一门动态语言，它将很多静态语言在编译和链接时期做的事放到了运行时来处理。这种动态语言的优势在于：我们写代码时更具灵活性，如我们可以把消息转发给我们想要的对象，或者随意交换一个方法的实现等。</p>

<p>这种特性意味着Objective-C不仅需要一个编译器，还需要一个运行时系统来执行编译的代码。对于Objective-C来说，这个运行时系统就像一个操作系统一样：它让所有的工作可以正常的运行。这个运行时系统即Objc Runtime。Objc Runtime其实是一个Runtime库，它基本上是用C和汇编写的，这个库使得C语言有了面向对象的能力。</p>

<p>Runtime库主要做下面几件事：</p>

<ol>
<li>封装：在这个库中，对象可以用C语言中的结构体表示，而方法可以用C函数来实现，另外再加上了一些额外的特性。这些结构体和函数被runtime函数封装后，我们就可以在程序运行时创建，检查，修改类、对象和它们的方法了。</li>
<li>找出方法的最终执行代码：当程序执行[object doSomething]时，会向消息接收者(object)发送一条消息(doSomething)，runtime会根据消息接收者是否能响应该消息而做出不同的反应。这将在后面详细介绍。</li>
</ol>


<p>Objective-C runtime目前有两个版本：Modern runtime和Legacy runtime。Modern Runtime 覆盖了64位的Mac OS X Apps，还有 iOS Apps，Legacy Runtime 是早期用来给32位 Mac OS X Apps 用的，也就是可以不用管就是了。</p>

<p>在这一系列文章中，我们将介绍runtime的基本工作原理，以及如何利用它让我们的程序变得更加灵活。在本文中，我们先来介绍一下类与对象，这是面向对象的基础，我们看看在Runtime中，类是如何实现的。</p>

<h2>类与对象基础数据结构</h2>

<h3>Class</h3>

<p>Objective-C类是由Class类型来表示的，它实际上是一个指向objc_class结构体的指针。它的定义如下：</p>

<pre><code>typedef struct objc_class *Class;
</code></pre>

<p>查看objc/runtime.h中objc_class结构体的定义如下：</p>

<pre><code>struct objc_class {
    Class isa  OBJC_ISA_AVAILABILITY;

#if !__OBJC2__
    Class super_class                       OBJC2_UNAVAILABLE;  // 父类
    const char *name                        OBJC2_UNAVAILABLE;  // 类名
    long version                            OBJC2_UNAVAILABLE;  // 类的版本信息，默认为0
    long info                               OBJC2_UNAVAILABLE;  // 类信息，供运行期使用的一些位标识
    long instance_size                      OBJC2_UNAVAILABLE;  // 该类的实例变量大小
    struct objc_ivar_list *ivars            OBJC2_UNAVAILABLE;  // 该类的成员变量链表
    struct objc_method_list **methodLists   OBJC2_UNAVAILABLE;  // 方法定义的链表
    struct objc_cache *cache                OBJC2_UNAVAILABLE;  // 方法缓存
    struct objc_protocol_list *protocols    OBJC2_UNAVAILABLE;  // 协议链表
#endif

} OBJC2_UNAVAILABLE;
</code></pre>

<p>在这个定义中，下面几个字段是我们感兴趣的</p>

<ol>
<li>isa：需要注意的是在Objective-C中，所有的类自身也是一个对象，这个对象的Class里面也有一个isa指针，它指向metaClass(元类)，我们会在后面介绍它。</li>
<li>super_class：指向该类的父类，如果该类已经是最顶层的根类(如NSObject或NSProxy)，则super_class为NULL。</li>
<li>cache：用于缓存最近使用的方法。一个接收者对象接收到一个消息时，它会根据isa指针去查找能够响应这个消息的对象。在实际使用中，这个对象只有一部分方法是常用的，很多方法其实很少用或者根本用不上。这种情况下，如果每次消息来时，我们都是methodLists中遍历一遍，性能势必很差。这时，cache就派上用场了。在我们每次调用过一个方法后，这个方法就会被缓存到cache列表中，下次调用的时候runtime就会优先去cache中查找，如果cache没有，才去methodLists中查找方法。这样，对于那些经常用到的方法的调用，但提高了调用的效率。</li>
<li>version：我们可以使用这个字段来提供类的版本信息。这对于对象的序列化非常有用，它可是让我们识别出不同类定义版本中实例变量布局的改变。</li>
</ol>


<p>针对cache，我们用下面例子来说明其执行过程：</p>

<pre><code>NSArray *array = [[NSArray alloc] init];
</code></pre>

<p>其流程是：</p>

<ol>
<li>[NSArray alloc]先被执行。因为NSArray没有+alloc方法，于是去父类NSObject去查找。</li>
<li>检测NSObject是否响应+alloc方法，发现响应，于是检测NSArray类，并根据其所需的内存空间大小开始分配内存空间，然后把isa指针指向NSArray类。同时，+alloc也被加进cache列表里面。</li>
<li>接着，执行-init方法，如果NSArray响应该方法，则直接将其加入cache；如果不响应，则去父类查找。</li>
<li>在后期的操作中，如果再以[[NSArray alloc] init]这种方式来创建数组，则会直接从cache中取出相应的方法，直接调用。</li>
</ol>


<h3>objc_object与id</h3>

<p>objc_object是表示一个类的实例的结构体，它的定义如下(objc/objc.h)：</p>

<pre><code>struct objc_object {
    Class isa  OBJC_ISA_AVAILABILITY;
};

typedef struct objc_object *id;
</code></pre>

<p>可以看到，这个结构体只有一个字体，即指向其类的isa指针。这样，当我们向一个Objective-C对象发送消息时，运行时库会根据实例对象的isa指针找到这个实例对象所属的类。Runtime库会在类的方法列表及父类的方法列表中去寻找与消息对应的selector指向的方法。找到后即运行这个方法。</p>

<p>当创建一个特定类的实例对象时，分配的内存包含一个objc_object数据结构，然后是类的实例变量的数据。NSObject类的alloc和allocWithZone:方法使用函数class_createInstance来创建objc_object数据结构。</p>

<p>另外还有我们常见的id，它是一个objc_object结构类型的指针。它的存在可以让我们实现类似于C++中泛型的一些操作。该类型的对象可以转换为任何一种对象，有点类似于C语言中void *指针类型的作用。</p>

<h3>objc_cache</h3>

<p>上面提到了objc_class结构体中的cache字段，它用于缓存调用过的方法。这个字段是一个指向objc_cache结构体的指针，其定义如下：</p>

<pre><code>struct objc_cache {
    unsigned int mask /* total = mask + 1 */                 OBJC2_UNAVAILABLE;
    unsigned int occupied                                    OBJC2_UNAVAILABLE;
    Method buckets[1]                                        OBJC2_UNAVAILABLE;
};
</code></pre>

<p>该结构体的字段描述如下：</p>

<ol>
<li>mask：一个整数，指定分配的缓存bucket的总数。在方法查找过程中，Objective-C runtime使用这个字段来确定开始线性查找数组的索引位置。指向方法selector的指针与该字段做一个AND位操作(index = (mask &amp; selector))。这可以作为一个简单的hash散列算法。</li>
<li>occupied：一个整数，指定实际占用的缓存bucket的总数。</li>
<li>buckets：指向Method数据结构指针的数组。这个数组可能包含不超过mask+1个元素。需要注意的是，指针可能是NULL，表示这个缓存bucket没有被占用，另外被占用的bucket可能是不连续的。这个数组可能会随着时间而增长。</li>
</ol>


<h3>元类(Meta Class)</h3>

<p>在上面我们提到，所有的类自身也是一个对象，我们可以向这个对象发送消息(即调用类方法)。如：</p>

<pre><code>NSArray *array = [NSArray array];
</code></pre>

<p>这个例子中，+array消息发送给了NSArray类，而这个NSArray也是一个对象。既然是对象，那么它也是一个objc_object指针，它包含一个指向其类的一个isa指针。那么这些就有一个问题了，这个isa指针指向什么呢？为了调用+array方法，这个类的isa指针必须指向一个包含这些类方法的一个objc_class结构体。这就引出了meta-class的概念</p>

<pre><code>meta-class是一个类对象的类。
</code></pre>

<p>当我们向一个对象发送消息时，runtime会在这个对象所属的这个类的方法列表中查找方法；而向一个类发送消息时，会在这个类的meta-class的方法列表中查找。</p>

<p>meta-class之所以重要，是因为它存储着一个类的所有类方法。每个类都会有一个单独的meta-class，因为每个类的类方法基本不可能完全相同。</p>

<p>再深入一下，meta-class也是一个类，也可以向它发送一个消息，那么它的isa又是指向什么呢？为了不让这种结构无限延伸下去，Objective-C的设计者让所有的meta-class的isa指向基类的meta-class，以此作为它们的所属类。即，任何NSObject继承体系下的meta-class都使用NSObject的meta-class作为自己的所属类，而基类的meta-class的isa指针是指向它自己。这样就形成了一个完美的闭环。</p>

<p>通过上面的描述，再加上对objc_class结构体中super_class指针的分析，我们就可以描绘出类及相应meta-class类的一个继承体系了，如下图所示：</p>

<p><img src="http://cn.cocos2d-x.org/uploads/20141018/1413628797629491.png" alt="image" /></p>

<p>对于NSObject继承体系来说，其实例方法对体系中的所有实例、类和meta-class都是有效的；而类方法对于体系内的所有类和meta-class都是有效的。</p>

<p>讲了这么多，我们还是来写个例子吧：</p>

<pre><code>void TestMetaClass(id self, SEL _cmd) {

    NSLog(@"This objcet is %p", self);
    NSLog(@"Class is %@, super class is %@", [self class], [self superclass]);

    Class currentClass = [self class];
    for (int i = 0; i &lt; 4; i++) {
        NSLog(@"Following the isa pointer %d times gives %p", i, currentClass);
        currentClass = objc_getClass((__bridge void *)currentClass);
    }

    NSLog(@"NSObject's class is %p", [NSObject class]);
    NSLog(@"NSObject's meta class is %p", objc_getClass((__bridge void *)[NSObject class]));
}

#pragma mark -

@implementation Test

- (void)ex_registerClassPair {

    Class newClass = objc_allocateClassPair([NSError class], "TestClass", 0);
    class_addMethod(newClass, @selector(testMetaClass), (IMP)TestMetaClass, "v@:");
    objc_registerClassPair(newClass);

    id instance = [[newClass alloc] initWithDomain:@"some domain" code:0 userInfo:nil];
    [instance performSelector:@selector(testMetaClass)];
}

@end
</code></pre>

<p>这个例子是在运行时创建了一个NSError的子类TestClass，然后为这个子类添加一个方法testMetaClass，这个方法的实现是TestMetaClass函数。</p>

<p>运行后，打印结果是</p>

<pre><code>2014-10-20 22:57:07.352 mountain[1303:41490] This objcet is 0x7a6e22b0
2014-10-20 22:57:07.353 mountain[1303:41490] Class is TestStringClass, super class is NSError
2014-10-20 22:57:07.353 mountain[1303:41490] Following the isa pointer 0 times gives 0x7a6e21b0
2014-10-20 22:57:07.353 mountain[1303:41490] Following the isa pointer 1 times gives 0x0
2014-10-20 22:57:07.353 mountain[1303:41490] Following the isa pointer 2 times gives 0x0
2014-10-20 22:57:07.353 mountain[1303:41490] Following the isa pointer 3 times gives 0x0
2014-10-20 22:57:07.353 mountain[1303:41490] NSObject's class is 0xe10000
2014-10-20 22:57:07.354 mountain[1303:41490] NSObject's meta class is 0x0
</code></pre>

<p>我们在for循环中，我们通过objc_getClass来获取对象的isa，并将其打印出来，依此一直回溯到NSObject的meta-class。分析打印结果，可以看到最后指针指向的地址是0x0，即NSObject的meta-class的类地址。</p>

<p><em>这里需要注意的是：我们在一个类对象调用class方法是无法获取meta-class，它只是返回类而已。</em></p>

<h2>类与对象操作函数</h2>

<p>runtime提供了大量的函数来操作类与对象。类的操作方法大部分是以class<em>为前缀的，而对象的操作方法大部分是以objc</em>或object_为前缀。下面我们将根据这些方法的用途来分类讨论这些方法的使用。</p>

<h3>类相关操作函数</h3>

<p>我们可以回过头去看看objc_class的定义，runtime提供的操作类的方法主要就是针对这个结构体中的各个字段的。下面我们分别介绍这一些的函数。并在最后以实例来演示这些函数的具体用法。</p>

<h4>类名(name)</h4>

<p>类名操作的函数主要有：</p>

<pre><code>// 获取类的类名
const char * class_getName ( Class cls );
</code></pre>

<p>● 对于class_getName函数，如果传入的cls为Nil，则返回一个字字符串。</p>

<h4>父类(super_class)和元类(meta-class)</h4>

<p>父类和元类操作的函数主要有：</p>

<pre><code>// 获取类的父类
Class class_getSuperclass ( Class cls );

// 判断给定的Class是否是一个元类
BOOL class_isMetaClass ( Class cls );
</code></pre>

<p>● class_getSuperclass函数，当cls为Nil或者cls为根类时，返回Nil。不过通常我们可以使用NSObject类的superclass方法来达到同样的目的。</p>

<p>● class_isMetaClass函数，如果是cls是元类，则返回YES；如果否或者传入的cls为Nil，则返回NO。</p>

<h4>实例变量大小(instance_size)</h4>

<p>实例变量大小操作的函数有：</p>

<pre><code>// 获取实例大小
size_t class_getInstanceSize ( Class cls );
</code></pre>

<h4>成员变量(ivars)及属性</h4>

<p>在objc_class中，所有的成员变量、属性的信息是放在链表ivars中的。ivars是一个数组，数组中每个元素是指向Ivar(变量信息)的指针。runtime提供了丰富的函数来操作这一字段。大体上可以分为以下几类：</p>

<p>1.成员变量操作函数，主要包含以下函数：</p>

<pre><code>// 获取类中指定名称实例成员变量的信息
Ivar class_getInstanceVariable ( Class cls, const char *name );

// 获取类成员变量的信息
Ivar class_getClassVariable ( Class cls, const char *name );

// 添加成员变量
BOOL class_addIvar ( Class cls, const char *name, size_t size, uint8_t alignment, const char *types );

// 获取整个成员变量列表
Ivar * class_copyIvarList ( Class cls, unsigned int *outCount );
</code></pre>

<p>● class_getInstanceVariable函数，它返回一个指向包含name指定的成员变量信息的objc_ivar结构体的指针(Ivar)。</p>

<p>● class_getClassVariable函数，目前没有找到关于Objective-C中类变量的信息，一般认为Objective-C不支持类变量。注意，返回的列表不包含父类的成员变量和属性。</p>

<p>● Objective-C不支持往已存在的类中添加实例变量，因此不管是系统库提供的提供的类，还是我们自定义的类，都无法动态添加成员变量。但如果我们通过运行时来创建一个类的话，又应该如何给它添加成员变量呢？这时我们就可以使用class_addIvar函数了。不过需要注意的是，这个方法只能在objc_allocateClassPair函数与objc_registerClassPair之间调用。另外，这个类也不能是元类。成员变量的按字节最小对齐量是1&lt;&lt;alignment。这取决于ivar的类型和机器的架构。如果变量的类型是指针类型，则传递log2(sizeof(pointer_type))。</p>

<p>● class_copyIvarList函数，它返回一个指向成员变量信息的数组，数组中每个元素是指向该成员变量信息的objc_ivar结构体的指针。这个数组不包含在父类中声明的变量。outCount指针返回数组的大小。需要注意的是，我们必须使用free()来释放这个数组。</p>

<p>2.属性操作函数，主要包含以下函数：</p>

<pre><code>// 获取指定的属性
objc_property_t class_getProperty ( Class cls, const char *name );

// 获取属性列表
objc_property_t * class_copyPropertyList ( Class cls, unsigned int *outCount );

// 为类添加属性
BOOL class_addProperty ( Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount );

// 替换类的属性
void class_replaceProperty ( Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount );
</code></pre>

<p>这一种方法也是针对ivars来操作，不过只操作那些是属性的值。我们在后面介绍属性时会再遇到这些函数。</p>

<p>3.在MAC OS X系统中，我们可以使用垃圾回收器。runtime提供了几个函数来确定一个对象的内存区域是否可以被垃圾回收器扫描，以处理strong/weak引用。这几个函数定义如下：</p>

<pre><code>const uint8_t * class_getIvarLayout ( Class cls );
void class_setIvarLayout ( Class cls, const uint8_t *layout );
const uint8_t * class_getWeakIvarLayout ( Class cls );
void class_setWeakIvarLayout ( Class cls, const uint8_t *layout );
</code></pre>

<p>但通常情况下，我们不需要去主动调用这些方法；在调用objc_registerClassPair时，会生成合理的布局。在此不详细介绍这些函数。</p>

<h4>方法(methodLists)</h4>

<p>方法操作主要有以下函数：</p>

<pre><code>// 添加方法
BOOL class_addMethod ( Class cls, SEL name, IMP imp, const char *types );

// 获取实例方法
Method class_getInstanceMethod ( Class cls, SEL name );

// 获取类方法
Method class_getClassMethod ( Class cls, SEL name );

// 获取所有方法的数组
Method * class_copyMethodList ( Class cls, unsigned int *outCount );

// 替代方法的实现
IMP class_replaceMethod ( Class cls, SEL name, IMP imp, const char *types );

// 返回方法的具体实现
IMP class_getMethodImplementation ( Class cls, SEL name );
IMP class_getMethodImplementation_stret ( Class cls, SEL name );

// 类实例是否响应指定的selector
BOOL class_respondsToSelector ( Class cls, SEL sel );
</code></pre>

<p>● class_addMethod的实现会覆盖父类的方法实现，但不会取代本类中已存在的实现，如果本类中包含一个同名的实现，则函数会返回NO。如果要修改已存在实现，可以使用method_setImplementation。一个Objective-C方法是一个简单的C函数，它至少包含两个参数&mdash;self和_cmd。所以，我们的实现函数(IMP参数指向的函数)至少需要两个参数，如下所示：</p>

<pre><code>void myMethodIMP(id self, SEL _cmd)
{
    // implementation ....
}
</code></pre>

<p>与成员变量不同的是，我们可以为类动态添加方法，不管这个类是否已存在。</p>

<p>另外，参数types是一个描述传递给方法的参数类型的字符数组，这就涉及到类型编码，我们将在后面介绍。</p>

<p>● class_getInstanceMethod、class_getClassMethod函数，与class_copyMethodList不同的是，这两个函数都会去搜索父类的实现。</p>

<p>● class_copyMethodList函数，返回包含所有实例方法的数组，如果需要获取类方法，则可以使用class_copyMethodList(object_getClass(cls), &amp;count)(一个类的实例方法是定义在元类里面)。该列表不包含父类实现的方法。outCount参数返回方法的个数。在获取到列表后，我们需要使用free()方法来释放它。</p>

<p>● class_replaceMethod函数，该函数的行为可以分为两种：如果类中不存在name指定的方法，则类似于class_addMethod函数一样会添加方法；如果类中已存在name指定的方法，则类似于method_setImplementation一样替代原方法的实现。</p>

<p>● class_getMethodImplementation函数，该函数在向类实例发送消息时会被调用，并返回一个指向方法实现函数的指针。这个函数会比method_getImplementation(class_getInstanceMethod(cls, name))更快。返回的函数指针可能是一个指向runtime内部的函数，而不一定是方法的实际实现。例如，如果类实例无法响应selector，则返回的函数指针将是运行时消息转发机制的一部分。</p>

<p>● class_respondsToSelector函数，我们通常使用NSObject类的respondsToSelector:或instancesRespondToSelector:方法来达到相同目的。</p>

<h4>协议(objc_protocol_list)</h4>

<p>协议相关的操作包含以下函数：</p>

<pre><code>// 添加协议
BOOL class_addProtocol ( Class cls, Protocol *protocol );

// 返回类是否实现指定的协议
BOOL class_conformsToProtocol ( Class cls, Protocol *protocol );

// 返回类实现的协议列表
Protocol * class_copyProtocolList ( Class cls, unsigned int *outCount );
</code></pre>

<p>● class_conformsToProtocol函数可以使用NSObject类的conformsToProtocol:方法来替代。</p>

<p>● class_copyProtocolList函数返回的是一个数组，在使用后我们需要使用free()手动释放。</p>

<h4>版本(version)</h4>

<p>版本相关的操作包含以下函数：</p>

<pre><code>// 获取版本号
int class_getVersion ( Class cls );

// 设置版本号
void class_setVersion ( Class cls, int version );
</code></pre>

<h4>其它</h4>

<p>runtime还提供了两个函数来供CoreFoundation的tool-free bridging使用，即：</p>

<pre><code>Class objc_getFutureClass ( const char *name );
void objc_setFutureClass ( Class cls, const char *name );
</code></pre>

<p>通常我们不直接使用这两个函数。</p>

<h4>实例(Example)</h4>

<p>上面列举了大量类操作的函数，下面我们写个实例，来看看这些函数的实例效果：</p>

<pre><code>//-----------------------------------------------------------
// MyClass.h

@interface MyClass : NSObject &lt;NSCopying, NSCoding&gt;

@property (nonatomic, strong) NSArray *array;

@property (nonatomic, copy) NSString *string;

- (void)method1;

- (void)method2;

+ (void)classMethod1;

@end

//-----------------------------------------------------------
// MyClass.m

#import "MyClass.h"

@interface MyClass () {
    NSInteger       _instance1;

    NSString    *   _instance2;
}

@property (nonatomic, assign) NSUInteger integer;

- (void)method3WithArg1:(NSInteger)arg1 arg2:(NSString *)arg2;

@end

@implementation MyClass

+ (void)classMethod1 {

}

- (void)method1 {
    NSLog(@"call method method1");
}

- (void)method2 {

}

- (void)method3WithArg1:(NSInteger)arg1 arg2:(NSString *)arg2 {

    NSLog(@"arg1 : %ld, arg2 : %@", arg1, arg2);
}

@end

//-----------------------------------------------------------
// main.h

#import "MyClass.h"
#import "MySubClass.h"
#import &lt;objc/runtime.h&gt;

int main(int argc, const char * argv[]) {
    @autoreleasepool {

        MyClass *myClass = [[MyClass alloc] init];
        unsigned int outCount = 0;

        Class cls = myClass.class;

        // 类名
        NSLog(@"class name: %s", class_getName(cls));

        NSLog(@"==========================================================");

        // 父类
        NSLog(@"super class name: %s", class_getName(class_getSuperclass(cls)));
        NSLog(@"==========================================================");

        // 是否是元类
        NSLog(@"MyClass is %@ a meta-class", (class_isMetaClass(cls) ? @"" : @"not"));
        NSLog(@"==========================================================");

        Class meta_class = objc_getMetaClass(class_getName(cls));
        NSLog(@"%s's meta-class is %s", class_getName(cls), class_getName(meta_class));
        NSLog(@"==========================================================");

        // 变量实例大小
        NSLog(@"instance size: %zu", class_getInstanceSize(cls));
        NSLog(@"==========================================================");

        // 成员变量
        Ivar *ivars = class_copyIvarList(cls, &amp;outCount);
        for (int i = 0; i &lt; outCount; i++) {
            Ivar ivar = ivars[i];
            NSLog(@"instance variable's name: %s at index: %d", ivar_getName(ivar), i);
        }

        free(ivars);

        Ivar string = class_getInstanceVariable(cls, "_string");
        if (string != NULL) {
            NSLog(@"instace variable %s", ivar_getName(string));
        }

        NSLog(@"==========================================================");

        // 属性操作
        objc_property_t * properties = class_copyPropertyList(cls, &amp;outCount);
        for (int i = 0; i &lt; outCount; i++) {
            objc_property_t property = properties[i];
            NSLog(@"property's name: %s", property_getName(property));
        }

        free(properties);

        objc_property_t array = class_getProperty(cls, "array");
        if (array != NULL) {
            NSLog(@"property %s", property_getName(array));
        }

        NSLog(@"==========================================================");

        // 方法操作
        Method *methods = class_copyMethodList(cls, &amp;outCount);
        for (int i = 0; i &lt; outCount; i++) {
            Method method = methods[i];
            NSLog(@"method's signature: %s", method_getName(method));
        }

        free(methods);

        Method method1 = class_getInstanceMethod(cls, @selector(method1));
        if (method1 != NULL) {
            NSLog(@"method %s", method_getName(method1));
        }

        Method classMethod = class_getClassMethod(cls, @selector(classMethod1));
        if (classMethod != NULL) {
            NSLog(@"class method : %s", method_getName(classMethod));
        }

        NSLog(@"MyClass is%@ responsd to selector: method3WithArg1:arg2:", class_respondsToSelector(cls, @selector(method3WithArg1:arg2:)) ? @"" : @" not");

        IMP imp = class_getMethodImplementation(cls, @selector(method1));
        imp();

        NSLog(@"==========================================================");

        // 协议
        Protocol * __unsafe_unretained * protocols = class_copyProtocolList(cls, &amp;outCount);
        Protocol * protocol;
        for (int i = 0; i &lt; outCount; i++) {
            protocol = protocols[i];
            NSLog(@"protocol name: %s", protocol_getName(protocol));
        }

        NSLog(@"MyClass is%@ responsed to protocol %s", class_conformsToProtocol(cls, protocol) ? @"" : @" not", protocol_getName(protocol));

        NSLog(@"==========================================================");
    }
    return 0;
}
</code></pre>

<p>这段程序的输出如下：</p>

<pre><code>2014-10-22 19:41:37.452 RuntimeTest[3189:156810] class name: MyClass
2014-10-22 19:41:37.453 RuntimeTest[3189:156810] ==========================================================
2014-10-22 19:41:37.454 RuntimeTest[3189:156810] super class name: NSObject
2014-10-22 19:41:37.454 RuntimeTest[3189:156810] ==========================================================
2014-10-22 19:41:37.454 RuntimeTest[3189:156810] MyClass is not a meta-class
2014-10-22 19:41:37.454 RuntimeTest[3189:156810] ==========================================================
2014-10-22 19:41:37.454 RuntimeTest[3189:156810] MyClass's meta-class is MyClass
2014-10-22 19:41:37.455 RuntimeTest[3189:156810] ==========================================================
2014-10-22 19:41:37.455 RuntimeTest[3189:156810] instance size: 48
2014-10-22 19:41:37.455 RuntimeTest[3189:156810] ==========================================================
2014-10-22 19:41:37.455 RuntimeTest[3189:156810] instance variable's name: _instance1 at index: 0
2014-10-22 19:41:37.455 RuntimeTest[3189:156810] instance variable's name: _instance2 at index: 1
2014-10-22 19:41:37.455 RuntimeTest[3189:156810] instance variable's name: _array at index: 2
2014-10-22 19:41:37.455 RuntimeTest[3189:156810] instance variable's name: _string at index: 3
2014-10-22 19:41:37.463 RuntimeTest[3189:156810] instance variable's name: _integer at index: 4
2014-10-22 19:41:37.463 RuntimeTest[3189:156810] instace variable _string
2014-10-22 19:41:37.463 RuntimeTest[3189:156810] ==========================================================
2014-10-22 19:41:37.463 RuntimeTest[3189:156810] property's name: array
2014-10-22 19:41:37.463 RuntimeTest[3189:156810] property's name: string
2014-10-22 19:41:37.464 RuntimeTest[3189:156810] property's name: integer
2014-10-22 19:41:37.464 RuntimeTest[3189:156810] property array
2014-10-22 19:41:37.464 RuntimeTest[3189:156810] ==========================================================
2014-10-22 19:41:37.464 RuntimeTest[3189:156810] method's signature: method1
2014-10-22 19:41:37.464 RuntimeTest[3189:156810] method's signature: method2
2014-10-22 19:41:37.464 RuntimeTest[3189:156810] method's signature: method3WithArg1:arg2:
2014-10-22 19:41:37.465 RuntimeTest[3189:156810] method's signature: integer
2014-10-22 19:41:37.465 RuntimeTest[3189:156810] method's signature: setInteger:
2014-10-22 19:41:37.465 RuntimeTest[3189:156810] method's signature: array
2014-10-22 19:41:37.465 RuntimeTest[3189:156810] method's signature: string
2014-10-22 19:41:37.465 RuntimeTest[3189:156810] method's signature: setString:
2014-10-22 19:41:37.465 RuntimeTest[3189:156810] method's signature: setArray:
2014-10-22 19:41:37.466 RuntimeTest[3189:156810] method's signature: .cxx_destruct
2014-10-22 19:41:37.466 RuntimeTest[3189:156810] method method1
2014-10-22 19:41:37.466 RuntimeTest[3189:156810] class method : classMethod1
2014-10-22 19:41:37.466 RuntimeTest[3189:156810] MyClass is responsd to selector: method3WithArg1:arg2:
2014-10-22 19:41:37.467 RuntimeTest[3189:156810] call method method1
2014-10-22 19:41:37.467 RuntimeTest[3189:156810] ==========================================================
2014-10-22 19:41:37.467 RuntimeTest[3189:156810] protocol name: NSCopying
2014-10-22 19:41:37.467 RuntimeTest[3189:156810] protocol name: NSCoding
2014-10-22 19:41:37.467 RuntimeTest[3189:156810] MyClass is responsed to protocol NSCoding
2014-10-22 19:41:37.468 RuntimeTest[3189:156810] ==========================================================
</code></pre>

<h3>动态创建类和对象</h3>

<p>runtime的强大之处在于它能在运行时创建类和对象。</p>

<h4>动态创建类</h4>

<p>动态创建类涉及到以下几个函数：</p>

<pre><code>// 创建一个新类和元类
Class objc_allocateClassPair ( Class superclass, const char *name, size_t extraBytes );

// 销毁一个类及其相关联的类
void objc_disposeClassPair ( Class cls );

// 在应用中注册由objc_allocateClassPair创建的类
void objc_registerClassPair ( Class cls );
</code></pre>

<p>● objc_allocateClassPair函数：如果我们要创建一个根类，则superclass指定为Nil。extraBytes通常指定为0，该参数是分配给类和元类对象尾部的索引ivars的字节数。</p>

<p>为了创建一个新类，我们需要调用objc_allocateClassPair。然后使用诸如class_addMethod，class_addIvar等函数来为新创建的类添加方法、实例变量和属性等。完成这些后，我们需要调用objc_registerClassPair函数来注册类，之后这个新类就可以在程序中使用了。</p>

<p>实例方法和实例变量应该添加到类自身上，而类方法应该添加到类的元类上。</p>

<p>● objc_disposeClassPair函数用于销毁一个类，不过需要注意的是，如果程序运行中还存在类或其子类的实例，则不能调用针对类调用该方法。</p>

<p>在前面介绍元类时，我们已经有接触到这几个函数了，在此我们再举个实例来看看这几个函数的使用。</p>

<pre><code>Class cls = objc_allocateClassPair(MyClass.class, "MySubClass", 0);
class_addMethod(cls, @selector(submethod1), (IMP)imp_submethod1, "v@:");
class_replaceMethod(cls, @selector(method1), (IMP)imp_submethod1, "v@:");
class_addIvar(cls, "_ivar1", sizeof(NSString *), log(sizeof(NSString *)), "i");

objc_property_attribute_t type = {"T", "@\"NSString\""};
objc_property_attribute_t ownership = { "C", "" };
objc_property_attribute_t backingivar = { "V", "_ivar1"};
objc_property_attribute_t attrs[] = {type, ownership, backingivar};

class_addProperty(cls, "property2", attrs, 3);
objc_registerClassPair(cls);

id instance = [[cls alloc] init];
[instance performSelector:@selector(submethod1)];
[instance performSelector:@selector(method1)];
</code></pre>

<p>程序的输出如下：</p>

<pre><code>2014-10-23 11:35:31.006 RuntimeTest[3800:66152] run sub method 1
2014-10-23 11:35:31.006 RuntimeTest[3800:66152] run sub method 1
</code></pre>

<h4>动态创建对象</h4>

<p>动态创建对象的函数如下：</p>

<pre><code>// 创建类实例
id class_createInstance ( Class cls, size_t extraBytes );

// 在指定位置创建类实例
id objc_constructInstance ( Class cls, void *bytes );

// 销毁类实例
void * objc_destructInstance ( id obj );
</code></pre>

<p>● class_createInstance函数：创建实例时，会在默认的内存区域为类分配内存。extraBytes参数表示分配的额外字节数。这些额外的字节可用于存储在类定义中所定义的实例变量之外的实例变量。该函数在ARC环境下无法使用。</p>

<p>调用class_createInstance的效果与+alloc方法类似。不过在使用class_createInstance时，我们需要确切的知道我们要用它来做什么。在下面的例子中，我们用NSString来测试一下该函数的实际效果：</p>

<pre><code>id theObject = class_createInstance(NSString.class, sizeof(unsigned));
id str1 = [theObject init];

NSLog(@"%@", [str1 class]);

id str2 = [[NSString alloc] initWithString:@"test"];
NSLog(@"%@", [str2 class]);
</code></pre>

<p>输出结果是：</p>

<pre><code>2014-10-23 12:46:50.781 RuntimeTest[4039:89088] NSString
2014-10-23 12:46:50.781 RuntimeTest[4039:89088] __NSCFConstantString
</code></pre>

<p>可以看到，使用class_createInstance函数获取的是NSString实例，而不是类簇中的默认占位符类__NSCFConstantString。</p>

<p>● objc_constructInstance函数：在指定的位置(bytes)创建类实例。</p>

<p>● objc_destructInstance函数：销毁一个类的实例，但不会释放并移除任何与其相关的引用。</p>

<h3>实例操作函数</h3>

<p>实例操作函数主要是针对我们创建的实例对象的一系列操作函数，我们可以使用这组函数来从实例对象中获取我们想要的一些信息，如实例对象中变量的值。这组函数可以分为三小类：</p>

<p>1.针对整个对象进行操作的函数，这类函数包含</p>

<pre><code>// 返回指定对象的一份拷贝
id object_copy ( id obj, size_t size );

// 释放指定对象占用的内存
id object_dispose ( id obj );
</code></pre>

<p>有这样一种场景，假设我们有类A和类B，且类B是类A的子类。类B通过添加一些额外的属性来扩展类A。现在我们创建了一个A类的实例对象，并希望在运行时将这个对象转换为B类的实例对象，这样可以添加数据到B类的属性中。这种情况下，我们没有办法直接转换，因为B类的实例会比A类的实例更大，没有足够的空间来放置对象。此时，我们就要以使用以上几个函数来处理这种情况，如下代码所示：</p>

<pre><code>NSObject *a = [[NSObject alloc] init];
id newB = object_copy(a, class_getInstanceSize(MyClass.class));
object_setClass(newB, MyClass.class);
object_dispose(a);
</code></pre>

<p>2.针对对象实例变量进行操作的函数，这类函数包含：</p>

<pre><code>// 修改类实例的实例变量的值
Ivar object_setInstanceVariable ( id obj, const char *name, void *value );

// 获取对象实例变量的值
Ivar object_getInstanceVariable ( id obj, const char *name, void **outValue );

// 返回指向给定对象分配的任何额外字节的指针
void * object_getIndexedIvars ( id obj );

// 返回对象中实例变量的值
id object_getIvar ( id obj, Ivar ivar );

// 设置对象中实例变量的值
void object_setIvar ( id obj, Ivar ivar, id value );
</code></pre>

<p>如果实例变量的Ivar已经知道，那么调用object_getIvar会比object_getInstanceVariable函数快，相同情况下，object_setIvar也比object_setInstanceVariable快。</p>

<p>3.针对对象的类进行操作的函数，这类函数包含：</p>

<pre><code>// 返回给定对象的类名
const char * object_getClassName ( id obj );

// 返回对象的类
Class object_getClass ( id obj );

// 设置对象的类
Class object_setClass ( id obj, Class cls );
</code></pre>

<h3>获取类定义</h3>

<p>Objective-C动态运行库会自动注册我们代码中定义的所有的类。我们也可以在运行时创建类定义并使用objc_addClass函数来注册它们。runtime提供了一系列函数来获取类定义相关的信息，这些函数主要包括：</p>

<pre><code>// 获取已注册的类定义的列表
int objc_getClassList ( Class *buffer, int bufferCount );

// 创建并返回一个指向所有已注册类的指针列表
Class * objc_copyClassList ( unsigned int *outCount );

// 返回指定类的类定义
Class objc_lookUpClass ( const char *name );
Class objc_getClass ( const char *name );
Class objc_getRequiredClass ( const char *name );

// 返回指定类的元类
Class objc_getMetaClass ( const char *name );
</code></pre>

<p>● objc_getClassList函数：获取已注册的类定义的列表。我们不能假设从该函数中获取的类对象是继承自NSObject体系的，所以在这些类上调用方法是，都应该先检测一下这个方法是否在这个类中实现。</p>

<p>下面代码演示了该函数的用法：</p>

<pre><code>int numClasses;
Class * classes = NULL;

numClasses = objc_getClassList(NULL, 0);
if (numClasses &gt; 0) {
    classes = malloc(sizeof(Class) * numClasses);
    numClasses = objc_getClassList(classes, numClasses);

    NSLog(@"number of classes: %d", numClasses);

    for (int i = 0; i &lt; numClasses; i++) {

        Class cls = classes[i];
        NSLog(@"class name: %s", class_getName(cls));
    }

    free(classes);
}
</code></pre>

<p>输出结果如下：</p>

<pre><code>2014-10-23 16:20:52.589 RuntimeTest[8437:188589] number of classes: 1282
2014-10-23 16:20:52.589 RuntimeTest[8437:188589] class name: DDTokenRegexp
2014-10-23 16:20:52.590 RuntimeTest[8437:188589] class name: _NSMostCommonKoreanCharsKeySet
2014-10-23 16:20:52.590 RuntimeTest[8437:188589] class name: OS_xpc_dictionary
2014-10-23 16:20:52.590 RuntimeTest[8437:188589] class name: NSFileCoordinator
2014-10-23 16:20:52.590 RuntimeTest[8437:188589] class name: NSAssertionHandler
2014-10-23 16:20:52.590 RuntimeTest[8437:188589] class name: PFUbiquityTransactionLogMigrator
2014-10-23 16:20:52.591 RuntimeTest[8437:188589] class name: NSNotification
2014-10-23 16:20:52.591 RuntimeTest[8437:188589] class name: NSKeyValueNilSetEnumerator
2014-10-23 16:20:52.591 RuntimeTest[8437:188589] class name: OS_tcp_connection_tls_session
2014-10-23 16:20:52.591 RuntimeTest[8437:188589] class name: _PFRoutines
......还有大量输出
</code></pre>

<p>● 获取类定义的方法有三个：objc_lookUpClass, objc_getClass和objc_getRequiredClass。如果类在运行时未注册，则objc_lookUpClass会返回nil，而objc_getClass会调用类处理回调，并再次确认类是否注册，如果确认未注册，再返回nil。而objc_getRequiredClass函数的操作与objc_getClass相同，只不过如果没有找到类，则会杀死进程。</p>

<p>● objc_getMetaClass函数：如果指定的类没有注册，则该函数会调用类处理回调，并再次确认类是否注册，如果确认未注册，再返回nil。不过，每个类定义都必须有一个有效的元类定义，所以这个函数总是会返回一个元类定义，不管它是否有效。</p>

<h2>小结</h2>

<p>在这一章中我们介绍了Runtime运行时中与类和对象相关的数据结构，通过这些数据函数，我们可以管窥Objective-C底层面向对象实现的一些信息。另外，通过丰富的操作函数，可以灵活地对这些数据进行操作。</p>

<p><strong><em>注：如有不对之处，还请指正，QQ：1318202110(跑吧)</em></strong></p>

<h4>参考</h4>

<ol>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/ObjCRuntimeRef/">Objective-C Runtime Reference</a></li>
<li><a href="http://www.cnblogs.com/whyandinside/archive/2013/02/26/2933552.html">Objective-C Runtime的数据类型</a></li>
<li><a href="http://blog.csdn.net/windyitian/article/details/19810875">详解Objective-C的meta-class</a></li>
<li><a href="http://stackoverflow.com/questions/16131172/what-are-class-setivarlayout-and-class-getivarlayout">what are class_setIvarLayout and class_getIvarLayout?</a></li>
<li><a href="http://stackoverflow.com/questions/3805499/whats-the-difference-between-doing-alloc-and-class-createinstance">What&rsquo;s the difference between doing alloc and class_createInstance</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS技术周报：第一期(2014.10.13 ~ 2014.10.19)]]></title>
    <link href="http://southpeak.github.io/blog/2014/10/19/iosji-zhu-zhou-bao-:di-%5B%3F%5D-qi-2014-dot-10-dot-13-~-2014-dot-10-dot-19/"/>
    <updated>2014-10-19T21:12:35+08:00</updated>
    <id>http://southpeak.github.io/blog/2014/10/19/iosji-zhu-zhou-bao-:di-[?]-qi-2014-dot-10-dot-13-~-2014-dot-10-dot-19</id>
    <content type="html"><![CDATA[<h2>1. 自定义下标操作</h2>

<p>对于数组与字典，我们可以使用下标来获取指定下标对应的值，如：</p>

<pre><code>NSArray *array = @[@1, @2, @3];
id value1 = array[0];        // 1

NSDictionary *dic = @{@"1": @1, @"2": @2, @"3": @3};
id value2 = dic[@"2"];      // 2
</code></pre>

<p>另外，Objective-C还支持自定义下标操作。我们先来看看如下代码：</p>

<pre><code>@interface MyCollection : NSObject

@property (nonatomic, retain) NSMutableArray *array;
@property (nonatomic, retain) NSMutableDictionary *dictionary;

@end
</code></pre>

<p>我们定义MyCollection类的一个实例，然后可以按如下方式访问array的元素</p>

<pre><code>MyCollection *collection = [[MyCollection alloc] init];
id arrElement = collection.array[0];
collection.array[1] = @"1";
id arrDic = collection.dictionary[@"test"];
collection.dictionary[@"id"] = @"abc";
</code></pre>

<p>但这样写代码略显麻烦，毕竟中间多用了一次&#8221;.&ldquo;操作。这种情况下，我们就可以为我们的类自定义相应的下标操作，来简单这种集合元素的访问。自定义下标使用到了如下几个方法：</p>

<ol>
<li>NSArray : &ndash; (id)objectAtIndexedSubscript:(NSUInteger)index;</li>
<li>NSMutableArray : &ndash; (void)setObject: (id)obj atIndexedSubscript: (NSUInteger)index;</li>
<li>NSDictionary : &ndash; (id)objectForKeyedSubscript: (id <NSCopying>)key;</li>
<li>NSMutableDictionary : &ndash; (void)setObject: (id)anObject forKeyedSubscript: (id <NSCopying>)aKey;</li>
</ol>


<p>我们为MyCollection类定义下标操作，代码如下所示：</p>

<pre><code>@implementation MyCollection

- (id)objectAtIndexedSubscript:(NSUInteger)index {
    return _array[index];
}

- (void)setObject:(id)obj atIndexedSubscript:(NSUInteger)index {
    _array[index] = obj;
}

- (id)objectForKeyedSubscript:(id&lt;NSCopying&gt;)key {
    return _dictionary[key];
}

- (void)setObject:(id)anObject forKeyedSubscript:(id&lt;NSCopying&gt;)aKey {
    _dictionary[aKey] = anObject;
}

@end
</code></pre>

<p>这样，我们就可以直接用下标操作来访问类中array属性和dictionary属性的元素了，如下所示：</p>

<pre><code>MyCollection *collection = [[MyCollection alloc] init];
id arrElement = collection[0];
collection[1] = @"1";
id arrDic = collection[@"test"];
collection[@"id"] = @"abc";
</code></pre>

<p><em>注：数组与字典本身也是实现了这些方法来支持下标操作</em></p>

<h2>2. NSInvocation的使用</h2>

<p>一个NSInvocation实例是一个静态呈现的Objective-C消息，换句话说，它是一个被转换成对象的一个动作。NSInvocation对象用于在对象间和应用间存储和转发消息，主要通过NSTimer对象和分布式对象系统来实现转发。</p>

<p>一个NSInvocation对象包含一个Objective-C消息所具有的元素：目标、selector、参数和返回值。所有这些元素可以直接设置，而返回值会在NSInvocation对象分发时被自动设置。</p>

<p>一个NSInvocation对象可以被多次分发到不同的目标(target)；它的参数可以在不同的分发中使用不同的值，以获取到不同的结果；甚至于它的selector也可以修改，只需要方法签名一样即可。这种灵活性使得NSInvocation在多次调用带有较多参数的消息的场景下非常有用；我们不需要为每个消息都键入不同的表达式，我们只需要每次在将消息发到新的目标时根据需要修改NSInvocation对象就可以。</p>

<p>NSInvocation对象不支持带有可变参数或联合参数的方法调用。我们应该使用invocationWithMethodSignature:方法来创建NSInvocation对象；而不应该使用alloc和init来创建。</p>

<p>这个类默认情况下不会为调用retain参数。如果这些参数(对象)可能会在创建NSInvocation对象和使用它这个时间段中间被释放，那么我们需要显示地retain这些对象，或者调用retainArguments方法来让调用对象自己retain它们。</p>

<p>NSInvocation的使用如下所示：</p>

<pre><code>// 代码来自ReactiveCocoa源码的RACBlockTrampoline类

- (id)invokeWithArguments:(RACTuple *)arguments {
    SEL selector = [self selectorForArgumentCount:arguments.count];
    NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:[self methodSignatureForSelector:selector]];
    invocation.selector = selector;
    invocation.target = self;

    for (NSUInteger i = 0; i &lt; arguments.count; i++) {
        id arg = arguments[i];
        NSInteger argIndex = (NSInteger)(i + 2);
        [invocation setArgument:&amp;arg atIndex:argIndex];
    }

    [invocation invoke];

    __unsafe_unretained id returnVal;
    [invocation getReturnValue:&amp;returnVal];
    return returnVal;
}
</code></pre>

<p>这里需要注意的是在调用setArgument:atIndex:时，参数的索引位置是从2开始的。因为索引0和1分别指向的是隐藏参数<strong>self</strong>和<strong>_cmd</strong>。这两个值是直接通过target和selector属性来设置的。</p>

<h4>参考</h4>

<ol>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSInvocation_Class">NSInvocation Class Reference</a></li>
</ol>


<h2>3. 方法签名</h2>

<p>在Objective-C中，方法签名由NSMethodSignature类来表示。</p>

<p>一个NSMethodSignature对象记录了方法的参数及返回值的类型信息。它主要用于转发那些接收对象无法响应的消息&mdash;最值得注意的是分发对象。通常我们会使用NSObject对象的methodSignatureForSelector:方法来创建一个NSMethodSignature对象。然后这个对象用于创建一个NSInvocation对象，这个对作为参数被传递到forwardInvocation:方法中，以将这个方法调用发送到任何其它对象以处理这个消息。默认情况下，NSObject调用doesNotRecognizeSelector:方法并引发一个异常。对于分发对象，NSInvocation对象通过NSMethodSignature对象的信息来编码，并被发送到一个表示消息接收者的真实对象中。</p>

<p>一个NSMethodSignature对象通过getArgumentTypeAtIndex:方法来获取指定索引位置的参数类型(该方法返回值是const char *, 用C字符串来表示Objective-C类型编码)。对于每个方法来说，有两个隐藏的参数，即self和_cmd，索引分别为0和1。除了参数类型，NSMethodSignature还有几个属性：numberOfArguments属性用来获取参数的个数；frameLength属性用来获取所有参数所占用的栈空间长度，以及methodReturnLength和methodReturnType获取返回值的长度和类型。最后，使用分发对象的程序可以通过isOneway方法来确定方法是否是异步的。</p>

<p>NSMethodSignature示例代码如下：</p>

<pre><code>// 代码摘自ReactiveCocoa:NSObject+RACLifting

- (RACSignal *)rac_liftSelector:(SEL)selector withSignalOfArguments:(RACSignal *)arguments {
    NSCParameterAssert(selector != NULL);
    NSCParameterAssert(arguments != nil);

    @unsafeify(self);

    NSMethodSignature *methodSignature = [self methodSignatureForSelector:selector];
    NSCAssert(methodSignature != nil, @"%@ does not respond to %@", self, NSStringFromSelector(selector));

    return [[[[arguments
            takeUntil:self.rac_willDeallocSignal]
            map:^(RACTuple *arguments) {
                @strongify(self);

                NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:methodSignature];
                invocation.selector = selector;
                invocation.rac_argumentsTuple = arguments;
                [invocation invokeWithTarget:self];

                return invocation.rac_returnValue;
            }]
            replayLast]
            setNameWithFormat:@"%@ -rac_liftSelector: %s withSignalsOfArguments: %@", [self rac_description], sel_getName(selector), arguments];
}
</code></pre>

<h4>参考</h4>

<ol>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSMethodSignature_Class/index.html#//apple_ref/doc/c_ref/NSMethodSignature">NSMethodSignature Class Reference</a></li>
</ol>


<h2>4. CFBridgingRelease/CFBridgingRetain</h2>

<p>这两个函数的作用类似于__bridge，用于在ARC环境下，在Cocoa Fundation和Core Funcation之间转换可桥接对象。</p>

<p>CFBridgingRetain函数是将Objective-C指针转换为Core Foundation指针，同时会转移对象所有权。如下代码所示：</p>

<pre><code>NSString *string = &lt;#Get a string#&gt;;
CFStringRef cfString = (CFStringRef)CFBridgingRetain(string);

// Use the CF string.
CFRelease(cfString);
</code></pre>

<p>通过这种转换，我们可以管理对象的生命周期。转换后，对象的释放就由我们来负责了。</p>

<p>相反，CFBridgingRelease函数是将一个非Objective-C指针转换为Objective-C指针，同时转移对象的权(ARC)。如下代码所示：</p>

<pre><code>CFStringRef cfName = ABRecordCopyValue(person, kABPersonFirstNameProperty);
NSString *name = (NSString *)CFBridgingRelease(cfName);
</code></pre>

<p>转换后，我们不需要手动去释放对象，因为这是在ARC环境所做的转换。</p>

<h4>参考</h4>

<ol>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Miscellaneous/Foundation_Functions">Foundation Functions Reference</a></li>
</ol>


<h2>5. NSProcessInfo</h2>

<p>这个类用来访问当前进程的信息。每一个进程都有一个单独的共享的NSProcessInfo对象，即为进程信息代理(Process information agent)，它可以返回诸如参数，环境变量，主机名或进程名等信息。方法processInfo类方法会返回当前进程共享的代理&mdash;即发送消息的对象所在的进程。我们可以如下获取当前进程的名字：</p>

<pre><code>NSString *processName = [[NSProcessInfo processInfo] processName];
</code></pre>

<p>NSProcessInfo对象在还能解析环境变量和命令行参数，如果无法使用Unicode编码将其表示为一个UTF-8字符串，则会将其编码成用户默认的C字符串编码格式。如果两种转换都无效，则NSProcessInfo对象会忽略这些值。</p>

<h4>管理Activity</h4>

<p>系统会以启发式(heuristics)的方法来改善电池寿命，性能和应用的响应。我们可以使用下面的方法来管理一些Activity，以告诉系统程序有特殊的需求：</p>

<pre><code>beginActivityWithOptions:reason:

endActivity:

performActivityWithOptions:reason:usingBlock:
</code></pre>

<p>为了响应创建Activity，系统会禁用部分或全部的heuristics，以便我们的程序尽快完成，而如果用户需要的话，同样还能提供响应操作。我们会在程序需要执行一个长时间运行的操作时使用Activity。如果Activity可能会消耗不同的时间，则应该使用这些API。这会在数据量或用户的计算机性能改变时，确保操作的正确。</p>

<p>Activity主要分为两类：</p>

<ol>
<li>用户启动(User initiated)的Activity：这些是用户显示开启的有限时长的Activity。比如导入或下载一个用户文件。</li>
<li>后台Activity：这些Activity是程序普通操作的一部分且是有限时长的，但不是由用户显示启动的。如自动保存、索引及自动下载文件。</li>
</ol>


<p>此外，如果程序需要高优先级的I/O操作，则可以包含NSActivityLatencyCritical标识(使用OR操作)。我们只应该在诸如录制视频音频这样确实需要高优先级的Activity中使用这个标识。</p>

<p>如果我们的Activity在主线程的事件回调中同步发生，则不需要使用这些API。</p>

<p>需要注意的是，如果在一个延长的时间周期内没有结束这些Activity，则会对设备的运行性能产生明显的负面影响，所以确保只使用最少的时间。用户偏好设置可能会重写应用的请求。</p>

<p>我们也可以用这些API来控制自动终止或突然终止。如</p>

<pre><code>id activity = [[NSProcessInfo processInfo] beginActivityWithOptions:NSActivityAutomaticTerminationDisabled reason:@"Good Reason"];
// Perform some work.
[[NSProcessInfo processInfo] endActivity:activity];
</code></pre>

<p>当然也可以使用</p>

<pre><code>[[NSProcessInfo processInfo] disableAutomaticTermination:@"Good Reason"];
// Perform some work.
[[NSProcessInfo processInfo] enableAutomaticTermination:@"Good Reason"];
</code></pre>

<p>不过由于上面这个接口返回一个对象，它可以方便地匹配开始和结束操作。如果这个对象在endActivity:方法调用之前被释放，则Activity会自动结束。</p>

<p>这个API也提供了禁用/执行系统范围内的闲置睡眠的机制。这可能对用户体验产生重大影响，所以确保不要忘记结束那些禁用睡眠的Activity。</p>

<h4>突然终止(Sudden Termination)</h4>

<p>在OS X v10.6及后续版本中有一个机制，它允许系统通过杀死应用程序来更快地输出日志或关机，而不是要求程序自行终止。应用程序可以在全局范围内开启这一功能，然后在可能导致数据损坏或较差用户体验的操作中重写这一功能的可用性。或者，我们的应用程序可以手动开启和禁用这一功能。</p>

<p>enableSuddenTermination和disableSuddenTermination方法分别会减少和增加一个计数器，其值在进程首次创建时为1。当计数器值为0时，程序会被认为是可安全杀死的，且可能在没有任何通知或事件被发送到进程时被系统杀死。</p>

<p>应用程序可以在程序的Info.plist文件中添加NSSupportsSuddenTermination键值来决定是否支持突然终止。如果该值存在且值为YES，则相当于在启动时调用了enableSuddenTermination。这使得程序可以立即被杀死。我们可以通过调用disableSuddenTermination方法来修改这种行为。</p>

<p>通常情况下，当我们的程序延迟那些必须在程序终止前才执行的操作时，我们会禁用突然终止行为。例如，如果程序延迟写磁盘操作，而突然终止行为可用，则我们应该将这些操作放在disableSuddenTermination方法与enableSuddenTermination方法之间执(注意，应该是先禁用、然后执行操作、最后再开启)。</p>

<p>一些AppKit功能会临时自动禁用突然终止行为，以确保数据完整性。如</p>

<ol>
<li>NSUserDefaults临时自动禁用突然终止行为以防止进程在设置值和将值写入磁盘这之间被杀死。</li>
</ol>


<h4>参考</h4>

<ol>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSProcessInfo_Class/">NSProcessInfo Class Reference</a></li>
</ol>


<h2>6. 快速枚举</h2>

<p>快速枚举即我们常写的for&hellip;in语句，可以让我们用简洁的语法来安全、有效地枚举集合中的内容。其基本用法如下</p>

<pre><code>for (type 变量 in 表达式) {
    // to do something
}
</code></pre>

<p>其中迭代变量会被赋值为表达式值对象中的每一个元素，并针对每一个元素执行处理语句。当循环结束后，迭代变量会被赋值为nil。如果循环提前结束，则迭代变量的值将指向最后一次遍历的那个对象。</p>

<p>要使用这种控制语句，则表达式的值必须遵循NSFastEnumeration协议。该协议中定义了一个用作上下文信息的结构体：</p>

<pre><code>typedef struct {
      unsigned long state;
      id *itemsPtr;
      unsigned long *mutationsPtr;
      unsigned long extra[5];
} NSFastEnumerationState;
</code></pre>

<p>及一个必须实现的方法</p>

<pre><code>- (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state
                                  objects:(id [])stackbuf
                                    count:(NSUInteger)len
</code></pre>

<p>该方法通过C数组返回发送者需要迭代的对象列表，并返回数组中对象的个数。</p>

<p>Cocoa中的集合类NSArray, NSDictionary和NSSet都遵循该协议，NSEnumerator类也是。</p>

<p>示例代码如下：</p>

<pre><code>// 代码摘自ReactiveCocoa: RACIndexSetSequence

- (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state objects:(__unsafe_unretained id[])stackbuf count:(NSUInteger)len {
    NSCParameterAssert(len &gt; 0);

    if (state-&gt;state &gt;= self.count) {
        // Enumeration has completed.
        return 0;
    }

    if (state-&gt;state == 0) {
        // Enumeration begun, mark the mutation flag.
        state-&gt;mutationsPtr = state-&gt;extra;
    }

    state-&gt;itemsPtr = stackbuf;

    unsigned long index = 0;
    while (index &lt; MIN(self.count - state-&gt;state, len)) {
        stackbuf[index] = @(self.indexes[index + state-&gt;state]);
        ++index;
    }

    state-&gt;state += index;
    return index;
}
</code></pre>

<p>从上面的代码可以看到，快速枚举使用了指针运算，所以它比使用NSEnumerator的标准方法效率更高。</p>

<h4>参考</h4>

<ol>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSEnumerator_Class/index.html">NSEnumerator Class Reference</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/NSFastEnumeration_protocol/index.html#//apple_ref/occ/intf/NSFastEnumeration">NSFastEnumeration Protocol Reference</a></li>
<li><a href="http://www.ituring.com.cn/article/details/1348">Objective-C——在Cocoa Touch框架中使用迭代器模式</a></li>
<li><a href="http://blog.csdn.net/amdbenq/article/details/7862718">快速枚举</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[instancetype]]></title>
    <link href="http://southpeak.github.io/blog/2014/10/19/instancetype/"/>
    <updated>2014-10-19T00:26:03+08:00</updated>
    <id>http://southpeak.github.io/blog/2014/10/19/instancetype</id>
    <content type="html"><![CDATA[<p>注：原文由Mattt Thompson发表于nshipster：<a href="http://nshipster.com/instancetype/">instancetype</a>。<strong>文章是2012年写的，所以有些内容现在已不适用。</strong></p>

<p>在Objective-C中，约定(conventions)不仅仅是编码最佳实践的问题，同时对编译器来说，也是一种隐式说明。</p>

<p>例如，alloc和init两个方法都返回id类型，而在Xcode中，编译器会对它们进行类型检查。这是怎么做到的呢？</p>

<p>在Cocoa中，有一个这样的约定，命名为alloc/init的方法总是返回接收者类的实例。这些方法有一个相关的返回类型。</p>

<p>而类的构造方法(类方法)，虽然他们都是返回id类型，但没有从类型检查中获得好处，因为他们不遵循命名约定。</p>

<p>我们可以试试以下代码：</p>

<pre><code>[[[NSArray alloc] init] mediaPlaybackAllowsAirPlay]; // 报错： "No visible @interface for `NSArray` declares the selector `mediaPlaybackAllowsAirPlay`"

[[NSArray array] mediaPlaybackAllowsAirPlay]; // (No error) 注：这个方法调用只在老的编译器上成立，新的编译器会报相同的错误。
</code></pre>

<p>由于alloc和init遵循返回相关结果类型的约定，所以会对NSArray执行类型检查。然而等价的类构造方法array则不遵循这一约定，只解释为id类型。</p>

<p>id类型在不需要确保类型安全时非常有用，但一旦需要时，就无法处理了。</p>

<p>而另一种方法，即显示声明返回类型(如前面例子中的(NSArray *))稍微改善了一些，但写起来有点麻烦，而且在继承体系中表现得不是很好。</p>

<p>这时编译器就需要去解决这种针对Objective-C类型系统的边界情况了:</p>

<p>instancetype是一个上下文关键字，可用在返回类型中以表示方法返回一个相关的结果类型，如：</p>

<pre><code>@interface Person
+ (instancetype)personWithName:(NSString *)name;
@end
</code></pre>

<p>使用instancetype，编译器可以正确地知道personWithName:的返回结果是一个Person实例。</p>

<p>我们现在看Foundation中的类构造器，可以发现大部分已经开始使用了instancetype了。新的API，如UICollectionViewLayoutAttributes，都是使用instancetype了。</p>

<p><em>注：instancetype与id不同的是，它只能用在方法声明的返回值中。</em></p>

<h4>更进一步的启示</h4>

<p>语言特性是特别有趣的，因为它不清楚在软件设计的更高层次方面会带来什么样的影响。</p>

<p>虽然instancetype看上去非常一般，只是对编译器有用，但也可能被用于一些更聪明的目的。</p>

<p>Jonathan Sterling的文章<a href="http://www.jonmsterling.com/posts/2012-02-05-typed-collections-with-self-types-in-objective-c.html">this quite interesting article</a>，详细描述了instancetype如何被用于编码静态类型集合，而不需要使用泛型：</p>

<pre><code>NSURL &lt;MapCollection&gt; *sites = (id)[NSURL mapCollection];
[sites put:[NSURL URLWithString:@"http://www.jonmsterling.com/"]
        at:@"jon"];
[sites put:[NSURL URLWithString:@"http://www.nshipster.com/"]
        at:@"nshipster"];

NSURL *jonsSite = [sites at:@"jon"]; // =&gt; http://www.jonmsterling.com/
</code></pre>

<p>静态类型集合使得API更有表现力，这样开发者将不再需要去确定集合中的参数可以使用使用类型的对象了。</p>

<p>不管这会不会成为Objective-C公认的约定，诸如instancetype这样一个低层特性可用于改变语言的形态已是非常棒的一件事了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OSAtomic原子操作]]></title>
    <link href="http://southpeak.github.io/blog/2014/10/17/osatomicyuan-zi-cao-zuo/"/>
    <updated>2014-10-17T10:56:00+08:00</updated>
    <id>http://southpeak.github.io/blog/2014/10/17/osatomicyuan-zi-cao-zuo</id>
    <content type="html"><![CDATA[<p>并发编程一个主要问题就是如何同步数据。同步数据的方式有很多种，这里我们介绍一下libkern/OSAtomic.h。这个头文件包含是大量关于原子操作和同步操作的函数，如果要对数据进行同步操作，这里面的函数可以作为我们的首选项。不同平台这些函数的实现是自定义的。另外，它们是线程安全的。</p>

<p>需要注意的是，传递给这些函数的所有地址都必须是“自然对齐”的，例如int32_t * 指针必须是32位对齐的(地址的低位2个bit为0)，int64_t * 指针必须是64位对齐的(低3位为0)。</p>

<p>这些原子函数的一些版本整合了内存屏障(memory barriers)，而另一些则没有。在诸如PPC这样的弱有序(weakly-ordered)架构中，Barriers严格限制了内存访问顺序。所有出现在barriers之前的加载和存储操作完成后，才会运行barriers之后的加载和存储操作。</p>

<p>在单处理器系统中，barriers操作通常是一个空操作。在多处理器系统中，barriers在某些平台上可能是相当昂贵的操作，如PPC。</p>

<p>大多数代码都应该使用barrier函数来确保在线程间共享的内存是正确同步的。例如，如果我们想要初始化一个共享的数据结构，然后自动增加某个变量值来标识初始化操作完成，则我们必须使用OSAtomicIncrement32Barrier来确保数据结构的存储操作在变量自动增加前完成。</p>

<p>同样的，该数据结构的消费者也必须使用OSAtomicIncrement32Barrier，以确保在自动递增变量值之后再去加载这些数据。另一方面，如果我们只是简单地递增一个全局计数器，那么使用OSAtomicIncrement32会更安全且可能更快。</p>

<p>如果不能确保我们使用的是哪个版本，则使用barrier变量以保证是安全的。</p>

<p>另外，自旋锁和队列操作总是包含一个barrier。</p>

<p>这个头文件中的函数主要可以分为以下几类</p>

<h2>内存屏障(Memory barriers)</h2>

<p>内存屏障的概念如上所述，它是一种屏障和指令类，可以让CPU或编译器强制将barrier之前和之后的内存操作分开。CPU采用了一些可能导致乱序执行的性能优化。在单个线程的执行中，内存操作的顺序一般是悄无声息的，但是在并发编程和设备驱动程序中就可能出现一些不可预知的行为，除非我们小心地去控制。排序约束的特性是依赖于硬件的，并由架构的内存顺序模型来定义。一些架构定义了多种barrier来执行不同的顺序约束。</p>

<p>OSMemoryBarrier()函数就是用来设置内存屏障，它即可以用于读操作，也可以用于写操作。</p>

<p>示例代码：</p>

<pre><code>// 代码来自ReactiveCocoa:RACDisposable类

- (id)initWithBlock:(void (^)(void))block {
    NSCParameterAssert(block != nil);

    self = [super init];
    if (self == nil) return nil;

    _disposeBlock = (void *)CFBridgingRetain([block copy]);
    OSMemoryBarrier();

    return self;
}
</code></pre>

<h2>自旋锁(Spinlocks)</h2>

<p>自旋锁是在多处理器系统(SMP)上为保护一段关键代码的执行或者关键数据的一种保护机制，是实现synchronization的一种手段。</p>

<p>libkern/OSAtomic.h中包含了三个关于自旋锁的函数：OSSpinLockLock, OSSpinLockTry, OSSpinLockUnlock</p>

<p>示例代码：</p>

<pre><code>// 代码来自ReactiveCocoa:RACCompoundDisposable类

- (void)dispose {
#if RACCompoundDisposableInlineCount
    RACDisposable *inlineCopy[RACCompoundDisposableInlineCount];
#endif

    CFArrayRef remainingDisposables = NULL;

    OSSpinLockLock(&amp;_spinLock);
    {
        _disposed = YES;

#if RACCompoundDisposableInlineCount
        for (unsigned i = 0; i &lt; RACCompoundDisposableInlineCount; i++) {
            inlineCopy[i] = _inlineDisposables[i];
            _inlineDisposables[i] = nil;
        }
#endif

        remainingDisposables = _disposables;
        _disposables = NULL;
    }
    OSSpinLockUnlock(&amp;_spinLock);

#if RACCompoundDisposableInlineCount
    // Dispose outside of the lock in case the compound disposable is used
    // recursively.
    for (unsigned i = 0; i &lt; RACCompoundDisposableInlineCount; i++) {
        [inlineCopy[i] dispose];
    }
#endif

    if (remainingDisposables == NULL) return;

    CFIndex count = CFArrayGetCount(remainingDisposables);
    CFArrayApplyFunction(remainingDisposables, CFRangeMake(0, count), &amp;disposeEach, NULL);
    CFRelease(remainingDisposables);
}
</code></pre>

<h2>原子队列操作</h2>

<p>队列操作主要包含两类：</p>

<ol>
<li>不加锁的FIFO入队和出队原子操作，包含OSAtomicFifoDequeue和OSAtomicFifoEnqueue两个函数</li>
<li>不加锁的LIFO入队和出队原子操作，包含OSAtomicDequeue和OSAtomicEnqueue两个函数。这两个函数是线程安全的，对有潜在精确要求的代码来说，这会是强大的构建方式。</li>
</ol>


<h2>比较和交换</h2>

<p>这组函数可以细分为三组函数：</p>

<ol>
<li>OSAtomicCompareAndSwap**[Barrier](type __oldValue, type __newValue, volatile type *__theValue)：这组函数用于比较__oldValue是否与__theValue指针指向的内存位置的值匹配，如果匹配，则将__newValue的值存储到__theValue指向的内存位置。可以根据需要使用barrier版本。</li>
<li>OSAtomicTestAndClear/OSAtomicTestAndClearBarrier( uint32_t __n, volatile void *__theAddress )：这组函数用于测试__theAddress指向的值中由__n指定的bit位，如果该位未被清除，则清除它。需要注意的是最低bit位应该是1，而不是0。对于一个64-bit的值来说，如果要清除最高位的值，则__n应该是64。</li>
<li>OSAtomicTestAndSet/OSAtomicTestAndSetBarrier(uint32_t __n, volatile void *__theAddress)：与OSAtomicTestAndClear相反，这组函数测试值后，如果指定位没有设置，则设置它。</li>
</ol>


<p>示例代码：</p>

<pre><code>void * sharedBuffer(void)
{
    static void * buffer;
    if (buffer == NULL) {
        void * newBuffer = calloc(1, 1024);
        if (!OSAtomicCompareAndSwapPtrBarrier(NULL, newBuffer, &amp;buffer)) {
            free(newBuffer);
        }
    }
    return buffer;
}
</code></pre>

<p>上述代码的作用是如果没有缓冲区，我们将创建一个newBuffer，然后将其写到buffer中。</p>

<h2>布尔操作(AND, OR, XOR)</h2>

<p>这组函数可根据以下两个规则来分类：</p>

<ol>
<li>是否使用Barrier</li>
<li>返回值是原始值还是操作完成后的值</li>
</ol>


<p>以And为例，有4个函数：OSAtomicAnd32, OSAtomicAnd32Barrier, OSAtomicAnd32Orig, OSAtomicAnd32OrigBarrier。每个函数均带有两个参数：__theMask(uint32_t)和__theValue(volatile uint32_t *)。函数将__theMask与__theValue指向的值做AND操作。</p>

<p>类似，还有OR操作和XOR操作。</p>

<h2>数学操作</h2>

<p>这组函数主要包括：</p>

<ol>
<li>加操作：OSAtomicAdd**, OSAtomicAdd**Barrier</li>
<li>递减操作：OSAtomicDecrement**, OSAtomicDecrement**Barrier</li>
<li>递增操作：OSAtomicIncrement**, OSAtomicIncrement**Barrier</li>
</ol>


<p>示例代码：</p>

<pre><code>// 代码摘自ReactiveCocoa:RACDynamicSequence

- (void)dealloc {
    static volatile int32_t directDeallocCount = 0;

    if (OSAtomicIncrement32(&amp;directDeallocCount) &gt;= DEALLOC_OVERFLOW_GUARD) {
        OSAtomicAdd32(-DEALLOC_OVERFLOW_GUARD, &amp;directDeallocCount);

        // Put this sequence's tail onto the autorelease pool so we stop
        // recursing.
        __autoreleasing RACSequence *tail __attribute__((unused)) = _tail;
    }

    _tail = nil;
}
</code></pre>

<h2>小结</h2>

<p>相较于@synchronized，OSAtomic原子操作更趋于数据的底层，从更深层次来对单例进行保护。同时，它没有阻断其它线程对函数的访问。</p>

<h2>参考</h2>

<ol>
<li><a href="https://developer.apple.com/library/mac/documentation/System/Reference/OSAtomic_header_reference/Reference/reference.html">OSAtomic.h User-Space Reference</a></li>
<li><a href="http://blog.csdn.net/wzb56_earl/article/details/6634622">Memory barrier</a></li>
<li><a href="http://www.cocoachina.com/industry/20130821/6842.html">Objc的底层并发API</a></li>
<li><a href="http://blog.csdn.net/tuxiangqi/article/details/8076972">OSATOMIC与synchronized加锁的对比</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[性能与时间]]></title>
    <link href="http://southpeak.github.io/blog/2014/09/23/xing-neng-yu-shi-jian/"/>
    <updated>2014-09-23T23:55:35+08:00</updated>
    <id>http://southpeak.github.io/blog/2014/09/23/xing-neng-yu-shi-jian</id>
    <content type="html"><![CDATA[<p>原文链接：<a href="http://www.macresearch.org/tutorial_performance_and_time">http://www.macresearch.org/tutorial_performance_and_time</a></p>

<p>在讨论性能之前，先讨论一个重要的话题：时间。为了理解代码中的变化如何影响性能，我们需要一个排序的指标。有许多方法用于时间例程，一些比另一些合适。在本教程中我们将讨论Mach Absolute Time。</p>

<h2>为什么是Mach?</h2>

<p>时间例程依赖于所需要测量的时间域。某些情况下使用诸如clock()或getrusage()函数来做些简单的数学运算就足够了。如果时间例程将用于实际的开发框架之外，可移植性就很重要了。我不使用这些。为什么？</p>

<p>对于我来说，调试代码的典型问题是：</p>

<ol>
<li>我只需要在即时测试时使用时间例程</li>
<li>我不喜欢依赖于多种函数来包含不同的时间域。它们的行为可能不一致</li>
<li>有时我需要一个高精度定时器</li>
</ol>


<h2>欢迎了解mach_absolute_time</h2>

<p>mach_absolute_time是一个CPU/总线依赖函数，返回一个基于系统启动后的时钟”嘀嗒”数。它没有很好的文档定义，但这不应该成为使用它的障碍，因为在MAC OS X上可以确保它的行为，并且，它包含系统时钟包含的所有时间区域。那是否应该在产品代码中使用它呢？可能不应该。但是对于测试，它却恰到好处。</p>

<p>使用mach_absolute_time时需要考虑两个因素：</p>

<ol>
<li>如何获取当前的Mach绝对时间</li>
<li>如何将其转换为有意义的数字</li>
</ol>


<h2>获取mach_absolute_time</h2>

<p>这非常简单</p>

<pre><code>#include &lt;stdint.h&gt; 
uint64_t start = mach_absolute_time();
uint64_t stop = mach_absolute_time(); 
</code></pre>

<p>这样就可以了。我们通常获取两个值，以得到这两个时间的时间差。</p>

<h2>将mach_absolute_time时间差转换为秒数</h2>

<p>这稍微有点复杂，因为我们需要获取mach_absolute_time所基于的系统时间基准。如下代码：</p>

<pre><code>#include &lt;stdint.h&gt;
#include&lt;mach/mach_time.h&gt; 
//Raw mach_absolute_times going in,difference in seconds out
double subtractTimes( uint64_tendTime, uint64_t startTime )
{
    uint64_t difference = endTime - startTime;
    static double conversion = 0.0;

    if( conversion == 0.0 )
    {
        mach_timebase_info_data_t info;
        kern_return_t err =mach_timebase_info( &amp;info );

        //Convert the timebase into seconds
        if( err == 0  )
            conversion= 1e-9 * (double) info.numer / (double) info.denom;
    }

    return conversion * (double)difference;
} 
</code></pre>

<p>这里最重要的是调用mach_timebase_info。我们传递一个结构体以返回时间基准值。最后，一旦我们获取到系统的心跳，我们便能生成一个转换因子。通常，转换是通过分子(info.numer)除以分母(info.denom)。这里我乘了一个1e-9来获取秒数。最后，我们获取两个时间的差值，并乘以转换因子，便得到真实的时间差。</p>

<p>现在我们可能会想，为什么这比用clock好？看起来做了更多的事情。确实是有点，这便是为什么它在一个函数中。我们只需要传递我们的值到函数中并取得答案。</p>

<h2>例子</h2>

<p>让我们写个例子。下面是完整的代码清单(包括mach函数)。可以使用gcc mach.c –o mach来编译它：</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdint.h&gt;
#include &lt;math.h&gt;
#include&lt;mach/mach_time.h&gt; 

//Raw mach_absolute_times going in,difference in seconds out
double subtractTimes( uint64_tendTime, uint64_t startTime )
{
    uint64_t difference = endTime -startTime;
    static double conversion = 0.0;

    if( conversion == 0.0 )
    {        
        mach_timebase_info_data_tinfo;        
        kern_return_terr = mach_timebase_info( &amp;info );                       //Convert the timebaseinto seconds        

        if(err == 0  )                       
            conversion= 1e-9 * (double) info.numer / (double) info.denom;    
    }

    return conversion * (double)difference;
} 

int main()
{
    inti, j, count;
    uint64_t start,stop;
    doublecurrent = 0.0;
    doubleanswer = 0.0;
    doubleelapsed = 0.0;
    intdim1 = 256;
    intdim2 = 256;
    intsize = 4*dim1*dim2;

    //Allocatesome memory and warm it up
    double *array =(double*)malloc(size*sizeof(double));       
    for(i=0;i&lt;size;i++)array = (double)i;

    count= 5;     
    for(i=0;i&lt;count;i++)
    {              
        start = mach_absolute_time();                                 
        //dosome work
        for(j=0;j&lt;size;j++)
        {
            answer+= sqrt(array[j]);
        }
        stop = mach_absolute_time();
        current= subtractTimes(stop,start);
        printf("Timefor iteration: %1.12lf for answer: %1.12lf\n",current, answer);
        elapsed+= current;
    } 

    printf("\nTotaltime in seconds = %1.12lf for answer: %1.12lf\n",elapsed/count,answer);
    free(array);
    return 0;
} 
</code></pre>

<p>我们在这里做了什么？在这个例子中，我们有一个适当大小的double数组，当中存放了一些数字，然后获取这些数值的和的开方。为了测试，我们迭代了5次这个计算。每次迭代后我们打印花费的时间，并总结了计算所需的运行时间。在我的PowerMac G5(2.5)机器上，我获得如下结果：</p>

<pre><code>[bigmac:~/misc] macresearch% gcc mach.c -omach
[bigmac:~/misc] macresearch%./mach 
Time for iteration: 0.006717496412for answer: 89478229.125529855490
Time for iteration: 0.007274204955for answer: 178956458.251062750816
Time for iteration: 0.006669191332for answer: 268434687.376589745283
Time for iteration: 0.006953711252for answer: 357912916.502135872841
Time for iteration: 0.007582157340for answer: 447391145.627681851387 
Average time in seconds =0.007039352258 for answer: 447391145.627681851387
</code></pre>

<p>注意，在这里我没有进行优化，因为编译器有方法避开这样的无脑循环。另外，这只是一个例子。如果是真正的代码，我们会进行优化。</p>

<p>好了，这就是这个例子的两个目的。</p>

<p>首先，我使用的数组大小比我的缓存大。我这样做的目的是因为我们需要注意到数据溢出缓存的情况(正如这个例子一样，至少在我的系统中是这样。如果是在MacPro中，不会出现这种情况)。我们将在以后讨论缓存的事宜。当然，这是一个做作的例子，但有一些东西可供思考。其次，你注意到在内存分配之前我写了一句注释，这是什么意思呢？</p>

<p>这在实际情况下是不需要关心的事情，因为内存总是在需要时已准备好使用。但当做一些小测试时来测试函数的性能时，它却可能是会影响到测试结果的实际问题。</p>

<p>当动态分配内存时，第一次访问内存管理时会将其清0(在OS X中不管使用哪种动态分配函数:malloc, calloc…所有内存在用户使用前都会清0)。内存清零是一种安全预防措施(我们不需要递交一些包含安全信息的内容，如解密密钥)</p>

<p>清零过程产生一个副作用(被系统标记为零填充页面故障)。所以为了让我们的计时更精确些，我们在使用内存之前一次性填充数据，以确保我们不会获取到零填充页面故障的处理时间。</p>

<p>让我们来测试一下，注释下面这行代码</p>

<pre><code>for(i=0;i&lt;size;i++) array =(double)i;
</code></pre>

<p>为:</p>

<pre><code>//for(i=0;i&lt;size;i++) array =(double)i;
</code></pre>

<p>再次运行测试</p>

<pre><code>[bigmac:~/misc] macresearch% ./mach
Time for iteration: 0.009478866798for answer: 0.000000000000
Time for iteration: 0.004756880234for answer: 0.000000000000
Time for iteration: 0.004927868215for answer: 0.000000000000
Time for iteration: 0.005227029674for answer: 0.000000000000
Time for iteration: 0.004891864428for answer: 0.000000000000 
Average time in seconds =0.005856501870 for answer: 0.000000000000
</code></pre>

<p>注意第一次迭代的时间比后序的时间多了将近一倍。同时还需要注意所有的answer都是0。再次说明内存被清零了。如果我们从堆上获取了内存，我们获取到的是无意义的数值。</p>

<p>最后，但很重要的一点。不要依赖于内存的清零操作。很有可能获取到的内存是从一个静态分配区而来，那么可能会导致如下这样的问题</p>

<pre><code>double array[3][3];
</code></pre>

<p>在我的系统上的打印结果是：</p>

<pre><code>-1.99844 -1.29321e-231 -1.99844
-3.30953e-232 -5.31401e+303 0
1.79209e-313 3.3146e-314 0
</code></pre>

<p>所以需要特别注意</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在ReactiveCocoa中将一个ViewModel绑定到UITableView上]]></title>
    <link href="http://southpeak.github.io/blog/2014/09/21/zai-reactivecocoazhong-jiang-%5B%3F%5D-ge-viewmodelbang-ding-dao-uitableviewshang/"/>
    <updated>2014-09-21T14:14:19+08:00</updated>
    <id>http://southpeak.github.io/blog/2014/09/21/zai-reactivecocoazhong-jiang-[?]-ge-viewmodelbang-ding-dao-uitableviewshang</id>
    <content type="html"><![CDATA[<p>英文作者Colin Eberhardt，原文可查看<a href="http://www.scottlogic.com/blog/2014/05/11/reactivecocoa-tableview-binding.html">BINDING TO A UITABLEVIEW FROM A REACTIVECOCOA VIEWMODEL</a></p>

<p>这篇博客介绍了一个工具类，这个类将ReactiveCocoa中的ViewModels绑定到UITableView，而不需要通常的datasource和delegate。下面是这个辅助类的使用方法：</p>

<pre><code>// 创建一个cell
UINib *nib = [UINib nibWithNibName:@"CETweetTableViewCell" bundle:nil];

// 将ViewModels的searchResults属性绑定到table view
[CETableViewBindingHelper bindingHelperForTableView:self.searchResultsTable
                        sourceSignal:RACObserve(self.viewModel, searchResults)
                        templateCell:nib];
</code></pre>

<h2>介绍</h2>

<p>我总是在不断的编写代码：在工作中，在家里，在火车上&hellip;如果我不写代码，我就会觉得不快乐！(注：这才是真正的程序员啊)</p>

<p>在过去的几个月中，我开始在我的工程中越来越多地使用ReactiveCocoa了。这个框架可以用来创建一些非常优雅的解决方案，但同时它非常具有挑战性，因为对于任何一个问题，都有许多可用的解决方案。对于像我这样的编码狂人来说，这再好不过了。</p>

<p>几个月之前，我在Ray Wenderlich的网站上发表了两篇关于ReactiveCocoa的文章(<a href="http://www.raywenderlich.com/62699/reactivecocoa-tutorial-pt1">第一部分</a>、<a href="http://www.raywenderlich.com/62796/reactivecocoa-tutorial-pt2">第二部分</a>)，以及一个<a href="http://www.raywenderlich.com/70598/reactivecocoa-tech-talk-video">Tech Talk</a>视频。这些覆盖了ReactiveCocoa的基本用法，希望能让广大读者熟悉ReactiveCocoa。不过，我收到不少请求，希望能讨论一些使用ReactiveCocoa实现MVVM模式的高级话题。</p>

<p>正因此，我开始写这篇文章。不过，在我发布之前，我想先分享一个已纠缠我很久的问题&hellip;</p>

<p>如果将一个UITableView绑定到一个ReactiveCocoa的ViewModel中？</p>

<h2>视图模式</h2>

<p>我以一个简单的例子开头&mdash;一个允许我们搜索Twitter的ViewModel：</p>

<pre><code>/// A view model which provides a mechanism for searching twitter
@interface CETwitterSearchViewModel : NSObject

/// The current search text
@property NSString *searchText;

/// An array of CETweetViewModel instances which indicate
/// the current search results
@property NSArray *searchResults;

/// A command which when executed searches twitter using the current searchText
@property RACCommand *searchCommand;

@end
</code></pre>

<p>这个ViewModel的实现重用了我在ReactiveCocoa指南第二部分所创建的信号，所以我不在此重复。如果想要看详细的代码，可以在github上查找。</p>

<p>将ViewModel绑定到一个带有UITextField和UIButton的UI是使用ReactiveCocoa最普通不过工作了</p>

<pre><code>// bind the UITextField text updates to the view model
RAC(self.viewModel, searchText) = self.searchTextField.rac_textSignal;

// bind a button to the search command
self.searchButton.rac_command = self.viewModel.searchCommand;

// when the search executes hide the keyboard
[self.viewModel.searchCommand.executing subscribeNext:^(id x) {
  [self.searchTextField resignFirstResponder];
}];

// show a network activity indicator when the search is being executed
RAC([UIApplication sharedApplication], networkActivityIndicatorVisible) =
  self.viewModel.searchCommand.executing;
</code></pre>

<p>在上面的代码中，当点击go按钮时，我们处理了诸如隐藏键盘这样的操作，并将网络连接的activity indicator绑定到了searchCommand.executing信号。</p>

<p><img src="http://www.scottlogic.com/blog/ceberhardt/assets/mvvm/UIBinding.png" alt="image" /></p>

<p>这样就将ViewModel三个属性中的两个绑定到了UI，到目前为止，一切都还不错！</p>

<p>最后一个属性是searchResults；这个属性是一个数组，包含了搜索结果。我们可以通过RACObserve来观察这个属性的修改，RACObserve创建了一个信号，该信号会在每次更新时发出一个next事件。但不幸的是，我们不能只给UITableView一个对象的数组，并告诉它去渲染自己。</p>

<p>如果我们在StackOverflow上搜索相关帖子，或者查看别人的ReactiveCocoa实例，可以看到传统的方式似乎是我们需要自己去实现table view的代理和数据源。换句话说，我们之前优雅的只需要几行绑定代码的视图类代码会由于需要实现table view的各种逻辑而显示异常丑陋。</p>

<p>不过，我们有更好的方法。</p>

<h2>一个Table View绑定辅助类</h2>

<p>在MVVM模式中，每一个View都由一个ViewModel支撑着。一个视图可能占据整个屏幕(此时我们将一个视图控制器绑定到一个ViewModel)，或者只占据屏幕的一部分。</p>

<p>我们的顶层ViewModel的searchResults属性包含了一个对象数组，其中每一个元素都是一个ViewModel。为了解决这个问题，我们需要的是一个通用的机制来为每个视图创建一个ViewModel，并将这两者绑定在一起。</p>

<p>Nib提供了一种便捷的机制来定义可重用的视图。可以方便地使用nib来定义一个table view的单元格。</p>

<p>一个合理的table view绑定辅助类的接口如下：</p>

<pre><code>/// A helper class for binding view models with NSArray properties
/// to a UITableView.
@interface CETableViewBindingHelper : NSObject

- (instancetype) initWithTableView:(UITableView *)tableView
                      sourceSignal:(RACSignal *)source
                      templateCell:(UINib *)templateCellNib;

@end
</code></pre>

<p>这个绑定类使用提供的table view来渲染由源信号所提供的view model，另外templeteCell定义了视图。让我们来看看这个辅助类的实现：</p>

<pre><code>＠interface CETableViewBindingHelper () &lt;UITableViewDataSource&gt;

＠end

＠implementation CETableViewBindingHelper {
  UITableView *_tableView;
  NSArray *_data;
  UITableViewCell *_templateCell;
}

- (instancetype)initWithTableView:(UITableView *)tableView
                     sourceSignal:(RACSignal *)source
                     templateCell:(UINib *)templateCellNib {

  if (self = [super init]) {
    _tableView = tableView;
    _data = [NSArray array];

    // each time the view model updates the array property, store the latest
    // value and reload the table view
    [source subscribeNext:^(id x) {
      _data = x;
      [_tableView reloadData];
    }];

    // create an instance of the template cell and register
    // with the table view
    _templateCell = [[templateCellNib instantiateWithOwner:nil
                                          options:nil] firstObject];
    [_tableView registerNib:templateCellNib
              forCellReuseIdentifier:_templateCell.reuseIdentifier];

    // use the template cell to set the row height
    _tableView.rowHeight = _templateCell.bounds.size.height;

    _tableView.dataSource = self;
  }
  return self;
}

#pragma mark - UITableViewDataSource implementation

- (NSInteger)tableView:(UITableView *)tableView
                       numberOfRowsInSection:(NSInteger)section {
  return _data.count;
}

- (UITableViewCell *)tableView:(UITableView *)tableView
                        cellForRowAtIndexPath:(NSIndexPath *)indexPath {
  id&lt;CEReactiveView&gt; cell = [tableView
      dequeueReusableCellWithIdentifier:_templateCell.reuseIdentifier];
  [cell bindViewModel:_data[indexPath.row]];
  return (UITableViewCell *)cell;
}

＠end
</code></pre>

<p>注意，初始化方法是内在逻辑所在。在这里，sourceSignal添加了一个subscriber，这样每次ViewModel的数组属性变化时，当前属性值的引用都会被保存，而table view也会重新加载。同样，也会创建templeteCell实例，来确定单元格的高度。</p>

<p>最后，这个类实现了table view的数据源方法，并通过信号来获取数据。</p>

<p>其中，单元格Cell必须实现以下协议，该协议提供了一个信号方法来将Cell绑定到相应的ViewModel上。</p>

<pre><code>/// A protocol which is adopted by views which are backed by view models.
@protocol CEReactiveView &lt;NSObject&gt;

/// Binds the given view model to the view
- (void)bindViewModel:(id)viewModel;

@end 
</code></pre>

<p>将这个用于实际当中，现在只需要几行代码就可以将一个数组属性绑定到一个table view上了。</p>

<pre><code>// create a cell template
UINib *nib = [UINib nibWithNibName:@"CETweetTableViewCell" bundle:nil];

// bind the view models 'searchResults' property to a table view
[[CETableViewBindingHelper alloc]
      initWithTableView:self.searchResultsTable
           sourceSignal:RACObserve(self.viewModel, searchResults)
           templateCell:nib];
</code></pre>

<p>注意，源信号是通过RACObserver宏来创建的。这个信号在每次属性通过setter来改变都会发出一个next事件。</p>

<p>cell的实现类似于视图控制器；它们的UI控件定义在一个nib文件中并连接到相应的outlet属性。下图是该示例程序中定义cell的nib：</p>

<p><img src="http://www.scottlogic.com/blog/ceberhardt/assets/mvvm/CellNib.png" alt="image" /></p>

<p>定义在CEReactiveView协议中的ViewModel绑定方法实现如下：</p>

<pre><code>- (void)bindViewModel:(id)viewModel {

  CETweetViewModel *tweet = (CETweetViewModel *)viewModel;

  // set the tweet 'status' label, sizing it to fit the text
  self.titleTextField.frame =
                 CGRectInset(self.titleBackgroundView.frame, 5.0f, 5.0f) ;
  self.titleTextField.text = tweet.status;
  [self.titleTextField sizeToFit];

  // set the username
  self.usernameTextField.text = tweet.username;

  // use signals to fetch the images for each image view
  self.profileImage.image = nil;
  [[self signalForImage:[NSURL URLWithString:tweet.profileBannerUrl]]
    subscribeNext:^(id x) {
      self.ghostImageView.image = x;
    }];

  self.ghostImageView.image = nil;
  [[self signalForImage:[NSURL URLWithString:tweet.profileImageUrl]]
    subscribeNext:^(id x) {
      self.profileImage.image = x;
    }];
} 
</code></pre>

<p>注意，由于CETweetViewModel的属性不会发生变化，因此它们的值直接被拷贝到相应的UI控件上。当然，如果它们的值会改变，我们也可以使用ReactiveCocoa来将两者绑定到一起。</p>

<p>cell的实现同样使用了ReactiveCocoa在后台加载图片：</p>

<pre><code>// creates a signal that fetches an image in the background, delivering
// it on the UI thread. This signal 'cancels' itself if the cell is re-used before the
// image is downloaded.
-(RACSignal *)signalForImage:(NSURL *)imageUrl {

  RACScheduler *scheduler = [RACScheduler 
                 schedulerWithPriority:RACSchedulerPriorityBackground];

  RACSignal *imageDownloadSignal = [[RACSignal
    createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
      NSData *data = [NSData dataWithContentsOfURL:imageUrl];
      UIImage *image = [UIImage imageWithData:data];
      [subscriber sendNext:image];
      [subscriber sendCompleted];
      return nil;
    }] subscribeOn:scheduler];

  return [[imageDownloadSignal
          takeUntil:self.rac_prepareForReuseSignal]
          deliverOn:[RACScheduler mainThreadScheduler]];

}
</code></pre>

<p>通过这种方式，我们就可以让我们的视图控制器保持少量的代码。看，是不是很整洁。</p>

<p>下面是完整的程序的实现效果：</p>

<p><img src="http://www.scottlogic.com/blog/ceberhardt/assets/mvvm/CellBinding.png" alt="image" /></p>

<h2>处理选中事件</h2>

<p>当前的绑定辅助类允许我们在一个table view中渲染ViewModel的数组，但如果我们需要处理选中事件呢？传统的方法是在视图控制器的手动处理，实现table view的代理方法，并执行相关的ViewModel的命令。</p>

<p>不过，这部分逻辑代码也可以放入到绑定辅助类中。</p>

<p>首先，我们在初始化方法中添加一个选择命令：</p>

<pre><code>- (instancetype) initWithTableView:(UITableView *)tableView
                      sourceSignal:(RACSignal *)source
                  selectionCommand:(RACCommand *)selection                  
                      templateCell:(UINib *)templateCellNib;
</code></pre>

<p>这个初始化方法的实现现在存储了这个命令的引用。辅助类同样也实现了table view的代理，即tableView:didSelectRowAtIndexPath:方法的实现如下：</p>

<pre><code>- (void)tableView:(UITableView *)tableView
               didSelectRowAtIndexPath:(NSIndexPath *)indexPath {
  [_selection execute:_data[indexPath.row]];
}
</code></pre>

<p>即当命令被调用时，会将选择的ViewModel作为执行参数传入。</p>

<p>在顶层ViewModel中，我已经添加了一个命令，这个操作只是简单地记录一下日志：</p>

<pre><code> // create the tweet selected command, that simply logs
 self.tweetSelectedCommand = [[RACCommand alloc]
             initWithSignalBlock:^RACSignal *(CETweetViewModel *selected) {
   NSLog(selected.status);
   return [RACSignal empty];
 }];
</code></pre>

<h2>结论</h2>

<p>希望这个table view绑定辅助类能够帮助那些使用MVVM和ReactiveCocoa来开发iOS应用的开发者们。所有的代码都在github上。如果您有任何意见、想法或建议，请让我知道。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS8中扫描Wi-Fi时MAC地址的随机化]]></title>
    <link href="http://southpeak.github.io/blog/2014/09/18/ios8zhong-sao-miao-wi-fishi-macdi-zhi-de-sui-ji-hua/"/>
    <updated>2014-09-18T15:51:54+08:00</updated>
    <id>http://southpeak.github.io/blog/2014/09/18/ios8zhong-sao-miao-wi-fishi-macdi-zhi-de-sui-ji-hua</id>
    <content type="html"><![CDATA[<p>继在iOS6和iOS7系统中面向开发者关闭IP地址和MAC地址的获取后，苹果在iOS8中又出新招：在扫描Wi-Fi时使用随机的、本地管理的MAC地址。基于苹果保护用户隐私的一贯政策，这一步是必然的，它会封死所以获取用户隐私信息的通道。这对于苹果用户来说，当然是件好事。而对于想通过MAC地址来获取用户信息的商家们或黑客们，可能就得另想办法了。我们在此粗略地总结一下iOS对MAC地址所做的随机化处理。</p>

<h2>MAC地址</h2>

<p>在当今基于OSI模型的七层网络系统中，所有有网络接口的设备至少都有一个MAC地址(Media Access Control)。MAC地址位于OSI模型的第二层中，用于帮助网络交换机(有机或无线)确定哪个设备正在传输包及哪个设备应该接收这些包。根据设计，MAC地址应该是唯一的，它被写入到设备的物理网络芯片中，两个不同的设备MAC地址是不一样的。由于像智能手机设备中的无线以太网适配器在广播MAC地址时，采用的的类似于“嘿，这里有没有Wi-Fi”这种形式，所以，我们可以很容易地通过记录这个唯一识别来跟踪用户是否到过某个公共区域。</p>

<h2>随机MAC地址的技术实现</h2>

<p>在WWDC 2014上，Frederic Jacobs在对iOS8新特性的介绍中，提到了如下一条:</p>

<p><img src="http://cdn.arstechnica.net/wp-content/uploads/2014/06/Screen-Shot-2014-06-09-at-10.15.22-AM-1280x551.png" alt="image" /></p>

<p>其大意是在iOS8系统中，Wi-Fi扫描过程中将使用随机的、本地管理的MAC地址，这个MAC地址并不总是设备的真实的MAC地址。</p>

<p>首先需要注意的是MAC地址的随机化。</p>

<p>如果是主动扫描，手机的无线设备会广播一个Probe请求，它包含一个随机的MAC地址。然后手机会等待周围的无线访问接入点(AP)返回Probe响应。一般来说会扫描所有的信道channel1-channel13(或者channel1, 5, 13)，每个信道扫描10ms左右。当然，手机也可以通过点对点的方式将请求(Directed Probe)发送给特定的AP。我们一般隐藏一个无线路由的SSID的方法，就是让这个无线路由不响应广播的Probe，不主动发Beacon，只响应Directed Probe。</p>

<p>而如果是被动扫描，则手机不会广播任何Probe请求，只是周期性地在不同的信道上监听AP发出的beacon包。</p>

<p>另外一个需要注意的是这个随机化是发生在扫描过程中的。而在手机与无线接入点进行关联的过程以及数据传输的过程中，使用MAC地址仍然是设备真实的MAC地址。通常只有在关联阶段才是让AP记录手机MAC地址的阶段，这时候记录的MAC地址，才是将来作为数据传输的MAC地址。</p>

<p>更详细的介绍，可以参看<a href="http://www.zhihu.com/people/qiang-meta">@Qiang Meta</a>在知乎上对《<a href="http://www.zhihu.com/question/24094236?sort=created">iOS 8 设备随机 MAC 地址躲避 Wi-Fi 热点的记录追踪，技术上是怎么实现，有何影响？</a>》的作答。</p>

<h2>影响</h2>

<p>如果我们是在家中或者在办公区域，我们通常会自己去主动关联无线接入点，那么等到下次再进入这一区域时，我们的手机等设备就会自动去连接无线网络。由于这些Wi-Fi是受我们信任的，所以无所谓。但是当我们到达一个陌生区域或公共区域时，我们的设备就会去搜索可用的无线接入点。这时候就涉及到隐私的问题了。</p>

<p>现在，已经有一些公司已经开发了可以记住所扫描到的MAC地址的Wi-Fi集线器。这种设备可以记住我们的MAC地址，无论我们有没有连接它。这些公司已经在许多地方部署了这些设备，以便他们能在用户不知道的情况下了解用户的一些基本行为。</p>

<p>正如WWDC上所指出的一样，“诸如Euclid或其同行Turnstyle Solutions这样的公司，它们会使用MAC地址这样的数据来记录用户进出商店的一些信息，如人们何时走进一个商店，他们在某个区域停留多久，他们来商店的频率是多少”。而MAC地址的随机化正是为了规避这个问题。</p>

<p>这对于广告商和营销商来说无疑是个不小的打击，如果iOS8设备使用不断变化的MAC地址来广播Wi-Fi Probe请求，则不可能通过MAC地址来跟踪进出商店或其它场所的移动设备。这对于保护用户的隐私来说，又是更进了一步。</p>

<h2>苹果的替代方案</h2>

<p>不过苹果也没有完全关闭追踪用户并向用户推送广告的通道，它推出了另外一种方案&mdash;即基于位置服务的iBeacon。iBeacon已经内置在最近的iOS设备中了。不同于使用设备的MAC地址，iBeacon使用低功耗蓝牙技术来发现那边带有支持iBeacon功能的App的设备，以向这些设备发送广告或通知。iBeacon不同于基于MAC地址跟踪技术(iBeacon发射器不会从设备中获取数据)，它只是在匹配到带有基于iBeacon的应用时，才可以察看设备位置。这样就无法推测出一个用户的习惯，从而保护了用户的隐私了。</p>

<p>当然，苹果在随机化MAC地址时，也综合考虑了用户隐私的泄露与商家基于地理位置来发送广告的需求之间的平衡。那些不愿意使用iBeacon的iOS用户可以通过关闭蓝牙来禁用iBeacon感知功能。在iOS8之前，用户只能通过禁用Wi-Fi来避免自己的设备被通过MAC地址的方式跟踪到。</p>

<h2>总结</h2>

<p>苹果这次对MAC地址的随机化处理，又一次展示了它对保护用户隐私的决定。相信以后类似的事情还会出现。而对于开发商或者开发者来说，在iOS设备上获取用户信息的渠道将会越来越少。我们改变不了苹果，或许也就只能另辟蹊径。</p>

<h2>参考</h2>

<ol>
<li><a href="http://www.zhihu.com/question/24094236">iOS 8 设备随机 MAC 地址躲避 Wi-Fi 热点的记录追踪，技术上是怎么实现，有何影响？</a></li>
<li><a href="http://arstechnica.com/apple/2014/06/ios8-to-stymie-trackers-and-marketers-with-mac-address-randomization/">iOS 8 to stymie trackers and marketers with MAC address randomization</a></li>
<li><a href="http://www.tuicool.com/articles/rUv6Br">Why iOS 8′s MAC address randomizing is a huge win for privacy</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[对于iOS 8的Size Classes的思考]]></title>
    <link href="http://southpeak.github.io/blog/2014/09/15/dui-yu-ios-8de-size-classesde-si-kao/"/>
    <updated>2014-09-15T17:25:53+08:00</updated>
    <id>http://southpeak.github.io/blog/2014/09/15/dui-yu-ios-8de-size-classesde-si-kao</id>
    <content type="html"><![CDATA[<p>原文链接：<a href="http://carpeaqua.com/2014/06/14/thinking-in-terms-of-ios-8-size-classes/">Thinking In Terms Of iOS 8 Size Classes</a></p>

<p>对于最新的iOS8 SDK来说，最性感也最重要的的特性也许莫过于Size Classes了。</p>

<p>在聊Size Classes之前，我们先来回顾下历史。</p>

<h2>一堂历史课</h2>

<p>最初，iOS推出时，我们只有一种设备：iPhone。它的屏幕大小是320*480。不过即使如此，它也是同时支付横屏和竖屏。设计同时支持两个方向的App不是像Mobile Safari或Messages那样，简单地拉伸和重新设置视图的大小。在大多数情况下，我们需要移动按钮和其它控件来让其适应横屏(480*320)。</p>

<p>几年后的现在，我们有了高清屏，iPads和大屏的iPhone。当然，所有这些设备都是支持横屏和竖屏的。解决这个适配问题的传统的方法是在视图控制器和自定义视图中监听设备方向的变化，同时使用多个xib或storyboard。</p>

<p>假设我已经构建了一个同时支持iPhone和iPad的的Glassboard工程。在iOS7和老的版本之前，我们需要针对iPad单独创建一个storyboard，这个storyboard包含重建的视图控制器，outlet属性和target/action。这相当于是重复工作了。任何程序员都知道这不是个好主意。需要在两个不同的地方做相同的改变真是件糟糕的事。</p>

<p>如果是使用代码，则我们需要在代码中检测屏幕方向及设备大小，以便我们能手动调整我们的约束或基于frame的布局。我们的代码会像下面这段代码一样：</p>

<pre><code>UIDevice *device = [UIDevice currentDevice];
UIDeviceOrientation currentOrientation = device.orientation;
BOOL isPhone = (device.userInterfaceIdiom == UIUserInterfaceIdiomPhone);
BOOL isTallPhone = ([[UIScreen mainScreen] bounds].size.height == 568.0);
if (UIDeviceOrientationIsPortrait(currentOrientation) == YES)
{
    // Do Portrait Things
    if (isPhone == YES)
    {
        // Do Portrait Phone Things
        // Don't deny you've done this at least once.
        if (isTallPhone)
        {
            // iPhone 5+
        }
        else
        {
            // Old phones
        }
    }
    else
    {
        // Do Portrait iPad things.
    }
}
else
{
    // Do Landscape Things.
    if (isPhone == YES)
    {
        // Do Landscape Phone Things
    }
    else
    {
        // Do Landscape iPad things.
    }
}
</code></pre>

<h2>Size Classes</h2>

<p>显然，上面的这些方案都不理想，而且随着苹果新设备的推出，这种情况会变得越来越糟。在今年的WWDC上，苹果除了介绍自动布局的新特性外，我们同样也看到了许多可变iOS模拟器的事例，以及一种处理所有这些问题和屏幕问题的新技术：Size Classes。</p>

<p>Size Classes是iOS使用的一种新的技术，允许我们为给定的设备自定义我们的程序，而且是基于设备的方向和屏幕大小的。</p>

<p>Size Classes有两个目的：</p>

<ol>
<li>让开发人员和设计人员跳出指定设备的范畴，而是以更广义的范畴来思考问题</li>
<li>为未来做准备</li>
</ol>


<p>第一个目的也引出了第二个目的。我们看到各种传说，说iPhone 6, 7将会是更大的设备。你也看到了苹果已经开发出了可穿戴设备(Apple Watch)。那么有什么方法可以让为这些设备开发变得更容易呢？那就是Size Classes。</p>

<p>目前从XCode 6上可以看到有四种类型的Size Classes：</p>

<p><img src="http://cdn.carpeaqua.com.s3.amazonaws.com/images/size-classes/size_class_chart.jpg" alt="image" /></p>

<ol>
<li>宽紧凑(Compact)</li>
<li>长紧凑</li>
<li>宽正常(Regular)</li>
<li>长正常</li>
</ol>


<p>任意时刻，我们的设备都有一个水平方向的Size Class和一个竖直方向的Size Class。这两者都是用来定义布局属性与物征(trait)的集合，以在屏幕上显示内容给用户。</p>

<h2>特征(Traits)</h2>

<p>水平和竖直的Size Class被认为是Traits。结合当前界面术语和显示比例，一起组成了一个特征集合。这不只是包含了指定的控制应该放在屏幕的什么地方。</p>

<p>特征(Trait)也可以用于诸如image assets的东西上(假设你正在使用Asset Catalogs)。在asset中，我们不仅可以包含1x和2x版本，我们还可以为不同的size class指定不同的image asset。在代码中，它看着仍然是相同的UIImage调用。Asset Catalogs负责基于当前的特征集合来渲染合适的图片。</p>

<h2>为Size Classes设计</h2>

<p>Size Classes对于开发人员来讲是一个很好的扩展，因为当我们需要支持多种设备和方向时，它能简化我们的开发。通过简化我们的工作，苹果可以更容易地开发新的设备，并可以让开发者开发能用的应用，而不仅仅是只为iPhone开发程序。</p>

<p>对于开发者来说，最大的改变是我们需要再一次修改我们的关于不同方向的代码。大家已经习惯了吧，谁让我们是开发者呢。</p>

<p>对于设计者来说，特征集合意味着可以少考虑是为哪种设备来做设计，而可以更多的考虑设备的属性。现在，设计者最需要考虑的因素是物理屏幕大小。</p>

<p>由于不能确保每台设备的屏幕尺寸都与Photoshop或测试样机保持一致，所以单独为特定的场景做设计已经站不住脚了。相反，我们的目标是应该为一类设备做通用的设计，主要包括：</p>

<ol>
<li>手机上的肖像模式</li>
<li>平板上的肖像模式</li>
<li>手机上的景观模式</li>
<li>平板上的景观模式</li>
</ol>


<p>现在iPhone 6来了，它的屏幕也变大了，它拥有与iPhone 4s和5一样的特征集合。当然，iPhone 6的尺寸比原来的手机更大了，但是UI应该基于为指定特征集合定义的界面，来做自适应的处理。</p>

<p>这可能意味着设计者需要推翻自己以前的一些设计，但这就是事实。就像软件开发一样，软件设计需要符合这些约束。新的约束就是我们不能再活在只为特定屏幕尺寸做设计的世界里面了。我们不是要像Android一样，但这是苹果希望我们前进的方向。</p>

<h2>采用Size Classes</h2>

<p>好消息是，Interface Builder可以让我们更好的使用Size Classes。更好的消息是，这些Interface Builder变化是向后兼容的，所以我们可以在合适的地方简化和合并Storyboards和Xibs，而不会落下任何用户。</p>

<p>不太好的消息是，如果需要在代码中使用特征集合，则只支持iOS 8。这是因为苹果很少为老的系统提供新的API接口。这就意味着我们需要在代码中添加一些新的分支来支持不同的系统。例如，为自定义的UIView调整intrinsicContentSize属性。如果系统是iOS8，我们可以使用竖直和水平的size class来确定这个值，但如果设备仍然是iOS 7或老版本，则已存在的代码仍然需要保留。</p>

<p>因为我使用并推荐Interface Builder，所以比起那些仍然活在“将一切写在代码”口号中的人们来说，我的工作明显地减少了。如果你仍然在那个阵营里面，我强烈建议你使用iOS 8, XCode 6和特征集合，并以此为契机加入到Interface Builder阵营中来。这样不仅能减少我们的代码量，同样可以通过提取大量的特征处理到一个视觉UI库来简化代码。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MVVM指南二：Flickr搜索深入]]></title>
    <link href="http://southpeak.github.io/blog/2014/08/12/mvvmzhi-nan-er-:flickrsou-suo-shen-ru/"/>
    <updated>2014-08-12T21:12:20+08:00</updated>
    <id>http://southpeak.github.io/blog/2014/08/12/mvvmzhi-nan-er-:flickrsou-suo-shen-ru</id>
    <content type="html"><![CDATA[<p>本文由Colin Eberhardt发表于raywenderlich，原文可查看<a href="http://www.raywenderlich.com/74131/mvvm-tutorial-with-reactivecocoa-part-2">MVVM Tutorial with ReactiveCocoa: Part 2/2</a></p>

<p>在第一部分中，我们介绍了MVVM，可以看到ReactiveCocoa如何将ViewModel绑定到各自对应的View上。</p>

<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/06/MVVMReactiveCocoa-700x121.png" alt="image" /></p>

<p>下图是我们程序实现的Flickr搜索功能</p>

<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2014/06/FinishedApp-671x500.png" alt="image" /></p>

<p>在这一部分中，我们来看看如何在程序的ViewModel中驱动视图间的导航操作。</p>

<p>目前我们的程序允许使用简单的搜索字符串来搜索Flickr。我们可以在<a href="http://cdn4.raywenderlich.com/wp-content/uploads/2014/06/FlickrSearchPart1Project1.zip">这里</a>下载程序。Model层使用ReactiveCocoa来提供搜索结果，ViewModel只是简单地记录响应。</p>

<p>现在，我们来看看如何在结果页中进行导航。</p>

<h2>实现ViewModel导航</h2>

<p>当一个Flickr成功返回需要的结果时，程序导航到一个新的视图控制器来显示搜索结果。当前的程序只有一个ViewModel，即RWTFlickrSearchViewModel类。为了实现需要的功能，我们将添加一个新的ViewModel来返回到搜索结果视图。添加新的继承自NSObject的RWTSearchResultsViewModel类到ViewModel分组中，并更新其头文件：</p>

<pre><code>@import Foundation;
#import "RWTViewModelServices.h"
#import "RWTFlickrSearchResults.h"

@interface RWTSearchResultsViewModel : NSObject

- (instancetype)initWithSearchResults:(RWTFlickrSearchResults *)results services:(id&lt;RWTViewModelServices&gt;)services;

@property (strong, nonatomic) NSString *title;
@property (strong, nonatomic) NSArray *searchResults;

@end
</code></pre>

<p>上述代码添加了描述视图的两个属性，及一个初始化方法。打开RWTSearchResultsViewModel.m并实现初始化方法：</p>

<pre><code>- (instancetype)initWithSearchResults:(RWTFlickrSearchResults *)results services:(id&lt;RWTViewModelServices&gt;)services {
  if (self = [super init]) {
    _title = results.searchString;
    _searchResults = results.photos;
  }
  return self;
}
</code></pre>

<p>回想一下第一部分，ViewModel在View驱动程序之前就已经生成了。下一步就是将View连接到对应的ViewModel上。</p>

<p>打开RWTSearchResultsViewController.h，导入ViewModel，并添加以下初始化方法：</p>

<pre><code>#import "RWTSearchResultsViewModel.h"

@interface RWTSearchResultsViewController : UIViewController

- (instancetype)initWithViewModel:(RWTSearchResultsViewModel *)viewModel;

@end
</code></pre>

<p>打开RWTSearchResultsViewController.m，在类的扩展中添加以下私有属性：</p>

<pre><code>@property (strong, nonatomic) RWTSearchResultsViewModel *viewModel;
</code></pre>

<p>在同一个文件下面，实现初始化方法：</p>

<pre><code>- (instancetype)initWithViewModel:(RWTSearchResultsViewModel *)viewModel {
  if (self = [super init]) {
    _viewModel = viewModel;
  }
  return self;
}
</code></pre>

<p>在这一步中，我们将重点关注导航如何工作，回到视图控制器中将ViewModel绑定到UI中。</p>

<p>现在程序有两个ViewModel，但是现在将面临一个难题。如何从一个ViewModel导航到另一个ViewModel中，也就是在对应的视图控制器中导航。ViewModel不能直接引用视图，所示我们应该怎么做呢？</p>

<p>答案已经在RWTViewModelServices协议中给出来了。它获取了一个Model层的引用，我们将使用这个协议来允许ViewModel来初始化导航。打开RWTViewModelServices.h并添加以下方法来协议中：</p>

<pre><code>- (void)pushViewModel:(id)viewModel;
</code></pre>

<p>理论上讲，是ViewModel层驱动程序，这一层中的逻辑决定了在View中显示什么，及何时进行导航。这个方法允许ViewModel层push一个ViewModel，该方式与UINavigationController方式类似。在更新协议实现前，我们将在ViewModel层先让这个机制工作。</p>

<p>打开RWTFlickrSearchViewModel.m并导入以下头文件</p>

<pre><code>#import "RWTSearchResultsViewModel.h"
</code></pre>

<p>同时在同一文件中更新executeSearchSignal的实现：</p>

<pre><code>- (RACSignal *)executeSearchSignal {
  return [[[self.services getFlickrSearchService]
    flickrSearchSignal:self.searchText]
    doNext:^(id result) {
      RWTSearchResultsViewModel *resultsViewModel =
        [[RWTSearchResultsViewModel alloc] initWithSearchResults:result services:self.services];
      [self.services pushViewModel:resultsViewModel];
    }];
}
</code></pre>

<p>上面的代码添加一个addNext操作到搜索命令执行时创建的信号。doNext块创建一个新的ViewModel来显示搜索结果，然后通过ViewModel服务将它push进来。现在是时候更新协议的实现代码了。为了满足这个需求，代码需要一个导航控制器的引用。</p>

<p>打开RWTViewModelServicesImpl.h并添加以下的初始化方法</p>

<pre><code>- (instancetype)initWithNavigationController:(UINavigationController *)navigationController;
</code></pre>

<p>打开RWTViewModelServicesImpl.m并导入以下头文件：</p>

<pre><code>#import "RWTSearchResultsViewController.h"
</code></pre>

<p>然后添加一个私有属性：</p>

<pre><code>@property (weak, nonatomic) UINavigationController *navigationController;
</code></pre>

<p>接下来实现初始化方法：</p>

<pre><code>- (instancetype)initWithNavigationController:(UINavigationController *)navigationController {
  if (self = [super init]) {
    _searchService = [RWTFlickrSearchImpl new];
    _navigationController = navigationController;
  }
  return self;
}
</code></pre>

<p>这简单地更新了初始化方法来存储传入的导航控制器的引用。最后，添加以下方法：</p>

<pre><code>- (void)pushViewModel:(id)viewModel {
  id viewController;

  if ([viewModel isKindOfClass:RWTSearchResultsViewModel.class]) {
    viewController = [[RWTSearchResultsViewController alloc] initWithViewModel:viewModel];
  } else {
    NSLog(@"an unknown ViewModel was pushed!");
  }

  [self.navigationController pushViewController:viewController animated:YES];
}
</code></pre>

<p>上面的方法使用提供的ViewModel的类型来确定需要哪个视图。在上面的例子中，只有一个ViewModel-View对，不过我确信你可以看到如何扩展这个模式。导航控制器push了结果视图。</p>

<p>最后，打开RWTAppDelegate.m，定位到createInitialViewController方法的RWTViewModelServicesImpl实例创建的地方，用下面的代码替换创建操作：</p>

<pre><code>self.viewModelServices = [[RWTViewModelServicesImpl alloc] initWithNavigationController:self.navigationController];
</code></pre>

<p>运行后，点击&#8221;GO&#8221;可以看到程序切换到新的ViewModel/View:</p>

<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/06/BlankView-281x500.png" alt="image" /></p>

<p>现在还是空的。别急，我们一步一步来。不过我们的程序现在有多个ViewModel，其中导航控制器通过ViewModel层来进行控制。我们先回来UI绑定上来。</p>

<h2>渲染结果页</h2>

<p>搜索结果的视图对应的nib文件中有一个UITableView。接下来，我们需要在这个table中渲染ViewModel的内容。打开RWTSearchResultsViewController.m并定位到类扩展。更新它以实现UITableViewDataSource协议：</p>

<pre><code>@interface RWTSearchResultsViewController () &lt;UITableViewDataSource&gt;
</code></pre>

<p>重写viewDidLoad的代码：</p>

<pre><code>- (void)viewDidLoad {
  [super viewDidLoad];

  [self.searchResultsTable registerClass:UITableViewCell.class
                  forCellReuseIdentifier:@"cell"];
  self.searchResultsTable.dataSource = self;

  [self bindViewModel];
}
</code></pre>

<p>这段代码执行table view的初始化并将其绑定到view model。先忘记硬编码的cell标识常量，我们会在后面将其移除。</p>

<p>继续在下面添加bindViewModel代码：</p>

<pre><code>- (void)bindViewModel {
  self.title = self.viewModel.title;
}
</code></pre>

<p>ViewModel有两个属性：上述代码处理的的标题，及渲染到table中的searchResults数组。那么我们该怎么样将数组绑定到table view呢？实际上，我们做不了。ReactiveCocoa可以绑定一些简单的UI控件，但是不能处理这种针对table view的复杂交互。但不需要担心，还有其它方法。卷起袖子开始做吧。</p>

<p>在同一文件中，添加以下两个数据源方法：</p>

<pre><code>- (NSInteger)tableView:(UITableView *)tableView
 numberOfRowsInSection:(NSInteger)section {
  return self.viewModel.searchResults.count;
}

- (UITableViewCell *)tableView:(UITableView *)tableView
         cellForRowAtIndexPath:(NSIndexPath *)indexPath {
  UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@"cell"];
  cell.textLabel.text = [self.viewModel.searchResults[indexPath.row] title];
  return cell;
}
</code></pre>

<p>这个就不用说了吧。运行后，效果如下：</p>

<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2014/06/PopulatedTable-281x500.png" alt="image" /></p>

<h2>更好的TableView绑定方法</h2>

<p>table view绑定的缺失会很快导致视图控制器代码的增加。而手动绑定看上去又不太优雅。从概念上讲，在ViewModel的searchResults数组中的每一项是一个ViewMode，每个cell是对应一个ViewModel实例。在<a href="http://www.scottlogic.com/blog/2014/05/11/reactivecocoa-tableview-binding.html">这篇博客</a>中我创建了一个绑定帮助类CETableViewBindingHelper，允许我们定义用于子ViewModel的View，帮助类负责实现数据源协议。我们可以在当前工程的Util分组中找到这个帮助类。</p>

<p>CETableViewBindingHelper的构造方法如下：</p>

<pre><code>+ (instancetype) bindingHelperForTableView:(UITableView *)tableView
                              sourceSignal:(RACSignal *)source
                          selectionCommand:(RACCommand *)selection
                              templateCell:(UINib *)templateCellNib;
</code></pre>

<p>为了将数组绑定到视图中，我们简单创建一个帮助类的实例。它的参数是：</p>

<ol>
<li>渲染ViewModel数组的table view</li>
<li>处理数组变化的信号</li>
<li>可选的当某行被选中时的命令</li>
<li>cell视图的nib文件</li>
</ol>


<p>nib文件定义的cell必须实现CEReactiveView协议。工程已经包含了一个table view cell，我们可以用它来渲染搜索结果。打开RWTSearchResultsTableViewCell.h并导入协议：</p>

<pre><code>#import "CEReactiveView.h"
</code></pre>

<p>采用协议：</p>

<pre><code>@interface RWTSearchResultsTableViewCell : UITableViewCell &lt;CEReactiveView&gt;
</code></pre>

<p>下一步是实现协议。打开RWTSearchResultsTableViewCell.m并添加头文件</p>

<pre><code>#import &lt;SDWebImage/UIImageView+WebCache.h&gt;
#import "RWTFlickrPhoto.h"
</code></pre>

<p>添加以下方法：</p>

<pre><code>- (void)bindViewModel:(id)viewModel {
  RWTFlickrPhoto *photo = viewModel;
  self.titleLabel.text = photo.title;

  self.imageThumbnailView.contentMode = UIViewContentModeScaleToFill;

  [self.imageThumbnailView setImageWithURL:photo.url];
}
</code></pre>

<p>RWTSearchResultsViewModel的searchResults属性包含RWTFlickrPhoto实例的数组。它们被直接绑定到View，而不是在ViewModel中包装这些Model对象。</p>

<p>bindViewModel方法使用了SDWebImage第三方库，它在后台线程下载并解码图片数据，大大提高了scroll的性能。</p>

<p>最后一步是使用绑定帮助类来渲染table。</p>

<p>打开RWTSearchResultsViewController.m并导入头文件：</p>

<pre><code>#import "CETableViewBindingHelper.h"
</code></pre>

<p>在该文件下面的代码中移除对UITableDataSource协议的实现，同时移除实现的方法。接下来，添加以下私有属性：</p>

<pre><code>@property (strong, nonatomic) CETableViewBindingHelper *bindingHelper;
</code></pre>

<p>在viewDidLoad方法中移除table view的配置代码，回归来方法的最初形式：</p>

<pre><code>- (void)viewDidLoad {
  [super viewDidLoad]; 
  [self bindViewModel];
}
</code></pre>

<p>然后我们在[self bindViewModel]后面添加以下代码：</p>

<pre><code>UINib *nib = [UINib nibWithNibName:@"RWTSearchResultsTableViewCell" bundle:nil];

self.bindingHelper =
  [CETableViewBindingHelper bindingHelperForTableView:self.searchResultsTable
                                         sourceSignal:RACObserve(self.viewModel, searchResults)
                                     selectionCommand:nil
                                         templateCell:nib];
</code></pre>

<p>这从nib文件中创建了一个UINib实例并构建了一个绑定帮助类实例，sourceSignal是通过观察ViewModel的searchResults属性改变而创建的。</p>

<p>运行后，得到新的UI：</p>

<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2014/06/UsingTheBindingHelper-281x500.png" alt="image" /></p>

<h2>一些UI特效</h2>

<p>到目前为止，本指南主要关注于根据MVVM模式来构建程序。接下来，我们做点别的吧：添加特效。</p>

<p>iOS7已经发布一年多了，“运动设计(motion design)”获取了更多的青睐，很多设计者现在都喜欢用这种微妙的对话和流体行为。</p>

<p>在这一步中，我们将添加一个图片滑动的特效，很不错的。</p>

<p>打开RWTSearchResultsTableViewCell.h并添加以下方法：</p>

<pre><code>- (void) setParallax:(CGFloat)value;
</code></pre>

<p>table view将使用这个方法来为每个cell提供视差补偿。</p>

<p>打开RWTSearchResultsTableViewCell.m并实现这个方法：</p>

<pre><code>- (void)setParallax:(CGFloat)value {
  self.imageThumbnailView.transform = CGAffineTransformMakeTranslation(0, value);
}
</code></pre>

<p>很不错，这只是个简单的变换。</p>

<p>打开RWTSearchResultsViewController.m并导入以下头文件：</p>

<pre><code>#import "RWTSearchResultsTableViewCell.h"
</code></pre>

<p>然后在类扩展中采用UITableViewDelegate协议：</p>

<pre><code>@interface RWTSearchResultsViewController () &lt;UITableViewDataSource, UITableViewDelegate&gt;
</code></pre>

<p>我们只是添加一个绑定辅助类来将将它自己设置为table view的代理，以便其可以响应行的选择。然而，它也转发代理方法调用到它所有的代理属性，这样我们仍然可以添加自定义行为。</p>

<p>在bindViewModel方法中，设置绑定辅助类代理：</p>

<pre><code>self.bindingHelper.delegate = self;
</code></pre>

<p>在同一文件下面，添加scrollViewDidScroll的实现：</p>

<pre><code>- (void)scrollViewDidScroll:(UIScrollView *)scrollView {
  NSArray *cells = [self.searchResultsTable visibleCells];
  for (RWTSearchResultsTableViewCell *cell in cells) {
    CGFloat value = -40 + (cell.frame.origin.y - self.searchResultsTable.contentOffset.y) / 5;
    [cell setParallax:value];
  }
}
</code></pre>

<p>table view每次滚动时，调用这个方法。它迭代所有的可见cell，计算用于视差效果的偏移值。这个偏移值依赖于cell在table view中可见部分的位置。</p>

<p>运行后，可得到以下效果</p>

<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/06/ParallaxAnimation.gif" alt="image" /></p>

<p>现在我们回到业务的View和ViewModel。</p>

<h2>查询评论及收藏计数</h2>

<p>我们应该在列表界面中每幅图片的右下方显示评论的数量和收藏的数量。当前我们只在nib文件中显示一个假数据&#8217;123&#8217;。我们在使用真值来替换这些值前，需要在Model层添加这些功能。添加表示查询Flickr API结果的Model对象的步骤跟前面一样。</p>

<p>在Model分组中添加RWTFlickrPhotoMetadata类，打开RWTFlickrPhotoMetadata.h并添加以下属性：</p>

<pre><code>@property (nonatomic) NSUInteger favorites;
@property (nonatomic) NSUInteger comments;
</code></pre>

<p>打开RWTFlickrPhotoMetadata.m并添加description的实现</p>

<pre><code>- (NSString *)description {
  return [NSString stringWithFormat:@"metadata: comments=%lU, faves=%lU",
          self.comments, self.favorites];
}
</code></pre>

<p>接下来打开RWTFlickrSearch.h并添加以下方法：</p>

<pre><code>- (RACSignal *)flickrImageMetadata:(NSString *)photoId;
</code></pre>

<p>ViewModel将使用这个方法来请求给定图片的元数据，如评论和收藏。</p>

<p>接下来打开RWTFlickrSearchImpl.m并添加以下头文件：</p>

<pre><code>#import "RWTFlickrPhotoMetadata.h"
#import &lt;ReactiveCocoa/RACEXTScope.h&gt;
</code></pre>

<p>接下来实现flickrImageMetadata方法。不幸的是，这里有些小问题：为了获取图片相关的评论数，我们需要调用flickr.photos.getinfo方法；为了获取收藏数，需要调用flickr.photos.getFavorites方法。这让事件变得有点复杂，因为flickrImageMetadata方法需要调用两个接口请求以获取需要的数据。不过，ReactiveCocoa已经为我们解决了这个问题。</p>

<p>添加以下实现：</p>

<pre><code>- (RACSignal *)flickrImageMetadata:(NSString *)photoId {

  RACSignal *favorites = [self signalFromAPIMethod:@"flickr.photos.getFavorites"
                                          arguments:@{@"photo_id": photoId}
                                          transform:^id(NSDictionary *response) {
                                            NSString *total = [response valueForKeyPath:@"photo.total"];
                                            return total;
                                          }];

  RACSignal *comments = [self signalFromAPIMethod:@"flickr.photos.getInfo"
                                        arguments:@{@"photo_id": photoId}
                                        transform:^id(NSDictionary *response) {
                                          NSString *total = [response valueForKeyPath:@"photo.comments._text"];
                                          return total;
                                        }];

  return [RACSignal combineLatest:@[favorites, comments] reduce:^id(NSString *favs, NSString *coms){
    RWTFlickrPhotoMetadata *meta = [RWTFlickrPhotoMetadata new];
    meta.comments = [coms integerValue];
    meta.favorites = [favs integerValue];
    return  meta;
  }];
}
</code></pre>

<p>上面的代码使用signalFromAPIMethod:arguments:transform:来从底层的基于ObjectiveFLickr的接口创建信号。上面的代码创建了一个信号对，一个用于获取收藏的数量，一个用于获取评论的数量。</p>

<p>一旦创建了两个信号，combineLatest:reduce:方法生成一个新的信号来组合两者。</p>

<p>这个方法等待源信号的一个next事件。reduce块使用它们的内容来调用，其结果变成联合信号的next事件。</p>

<p>简单明了吧！</p>

<p>不过在庆祝前，我们回到signalFromAPIMethod:arguments:transform:方法来修复之前提到的一个错误。你注意到了么？这个方法为每个请求创建一个新的OFFlickrAPIRequest实例。然后，每个请求的结果是通过代理对象来返回的，而这种情况下，其代理是它自己。结果是，在并发请求的情况下，没有办法指明哪个flickrAPIRequest:didCompleteWithResponse:调用用来响应哪个请求。不过，ObjectiveFlickr代理方法签名在第一个参数中包含了相应请求，所以这个问题很好解决。</p>

<p>在signalFromAPIMethod:arguments:transform:中，使用下面的代码来替换处理successSignal的管道：</p>

<pre><code>@weakify(flickrRequest)
[[[[successSignal
  filter:^BOOL(RACTuple *tuple) {
    @strongify(flickrRequest)
    return tuple.first == flickrRequest;
  }]
  map:^id(RACTuple *tuple) {
    return tuple.second;
  }]
  map:block]
  subscribeNext:^(id x) {
    [subscriber sendNext:x];
    [subscriber sendCompleted];
  }];
</code></pre>

<p>这只是简单地添加一个filter操作来移除任何与请求相关的代理方法调用，而不是生成当前的信号。</p>

<p>最后一步是在ViewModel层中使用信号。</p>

<p>打开RWTSearchResultsViewModel.m并导入以下头文件：</p>

<pre><code>#import "RWTFlickrPhoto.h"
</code></pre>

<p>在同一文件中的初始化的末尾添加以下代码：</p>

<pre><code>RWTFlickrPhoto *photo = results.photos.firstObject;
RACSignal *metaDataSignal = [[services getFlickrSearchService]
                            flickrImageMetadata:photo.identifier];
    [metaDataSignal subscribeNext:^(id x) {
     NSLog(@"%@", x);
   }];
</code></pre>

<p>这段代码测试了新添加的方法，该方法从返回的结果中的第一幅图片获取图片元数据。运行程序后，会在控制台输出以下信息：</p>

<pre><code>2014-06-04 07:27:26.813 RWTFlickrSearch[76828:70b] metadata: comments=120, faves=434
</code></pre>

<h2>获取可见cell的元数据</h2>

<p>我们可以扩展当前代码来获取所有搜索结果的元数据。然而，如果我们有100条结果，则需要立即发起200个请求，每幅图片2个请求。大多数API都有些限制，这种调用方式会阻塞我们的请求调用，至少是临时的。</p>

<p>在一个table中，我们只需要获取当前显示的单元格所对象的结果的元数据。所以，如何实现这个行为呢？当然，我们需要一个ViewModel来表示这些数据。当前RWTSearchResultsViewModel暴露了一个绑定到View的RWTFlickrPhoto实例的数组，它们的暴露给View的Model层对象。为了添加这种可见性，我们将给ViewModel中的model对象添加view-centric状态。</p>

<p>在ViewModel分组中添加RWTSearchResultsItemViewModel类，打开头文件并各以下代码更新：</p>

<pre><code>@import Foundation;
#import "RWTFlickrPhoto.h"
#import "RWTViewModelServices.h"

@interface RWTSearchResultsItemViewModel : NSObject

- (instancetype) initWithPhoto:(RWTFlickrPhoto *)photo services:(id&lt;RWTViewModelServices&gt;)services;

@property (nonatomic) BOOL isVisible;
@property (strong, nonatomic) NSString *title;
@property (strong, nonatomic) NSURL *url;
@property (strong, nonatomic) NSNumber *favorites;
@property (strong, nonatomic) NSNumber *comments;

@end
</code></pre>

<p>看看初始化方法，这个ViewModel封装了一个RWTFlickrPhoto模型对象的实例。这个ViewModel包含以下几类属性：</p>

<ol>
<li>表示底层Model属性的属性(title, url)</li>
<li>当获取到元数据时动态更新的属性(favorites, comments)</li>
<li>isVisible，用于表示ViewModel是否可见</li>
</ol>


<p>打开RWTSearchResultsItemViewModel.m并导入以下头文件：</p>

<pre><code>#import &lt;ReactiveCocoa/ReactiveCocoa.h&gt;
#import &lt;ReactiveCocoa/RACEXTScope.h&gt;
#import "RWTFlickrPhotoMetadata.h"
</code></pre>

<p>接下来添加几个私有属性：</p>

<pre><code>@interface RWTSearchResultsItemViewModel ()

@property (weak, nonatomic) id&lt;RWTViewModelServices&gt; services;
@property (strong, nonatomic) RWTFlickrPhoto *photo;

@end
</code></pre>

<p>然后实现初始化方法：</p>

<pre><code>- (instancetype)initWithPhoto:(RWTFlickrPhoto *)photo services:(id&lt;RWTViewModelServices&gt;)services {
  self = [super init];
  if (self) {
    _title = photo.title;
    _url = photo.url;
    _services = services;
    _photo = photo;

    [self initialize];
  }
  return  self;
}
</code></pre>

<p>这基于Model对象的title和url属性，然后通过私有属性来存储服务和图片的引用。</p>

<p>接下来添加initialize方法。准备好，这里有些有趣的事情会发生。</p>

<pre><code>- (void)initialize {
  RACSignal *fetchMetadata =
    [RACObserve(self, isVisible)
     filter:^BOOL(NSNumber *visible) {
       return [visible boolValue];
     }];

  @weakify(self)
  [fetchMetadata subscribeNext:^(id x) {
    @strongify(self)
    [[[self.services getFlickrSearchService] flickrImageMetadata:self.photo.identifier]
     subscribeNext:^(RWTFlickrPhotoMetadata *x) {
       self.favorites = @(x.favorites);
       self.comments = @(x.comments);
     }];
  }];
}
</code></pre>

<p>这个方法的第一部分通过监听isVisible属性和过滤true值来创建一个名为fetchMetadata的信号。结果，信号在isVisible属性设置为true时发出next事件。第二部分订阅这个信号以初始化到flickrImageMetadata方法的请求。当这个嵌套的信号发送next事件时，favorite和comment属性使用这个结果来更新值。</p>

<p>总的来说，当isVisible设置为true时，发送Flickr API请求，并在将来某个时刻更新comments和favorites属性。</p>

<p>为了使用新的ViewModel，打开RWTSearchResultsViewModel.m并导入头文件：</p>

<pre><code>#import &lt;LinqToObjectiveC/NSArray+LinqExtensions.h&gt;
#import "RWTSearchResultsItemViewModel.h"
</code></pre>

<p>在初始化方法中，移除当前设置_searchResults的代码，并使用以下代码：</p>

<pre><code>_searchResults =
  [results.photos linq_select:^id(RWTFlickrPhoto *photo) {
    return [[RWTSearchResultsItemViewModel alloc]
              initWithPhoto:photo services:services];
  }];
</code></pre>

<p>这只是简单地使用一个ViewModel来包装每一个Model对象。</p>

<p>最后一步是通过视图来设置isVisible对象，并使用这些新的属性。</p>

<p>打开RWTSearchResultsTableViewCell.m并导入以下头文件：</p>

<pre><code>#import "RWTSearchResultsItemViewModel.h"
</code></pre>

<p>然后在下面的bindViewModel方法的第一行添加以下代码：</p>

<pre><code>RWTSearchResultsItemViewModel *photo = viewModel;
</code></pre>

<p>并在访方法中添加以下代码：</p>

<pre><code>[RACObserve(photo, favorites) subscribeNext:^(NSNumber *x) {
  self.favouritesLabel.text = [x stringValue];
  self.favouritesIcon.hidden = (x == nil);
}];

[RACObserve(photo, comments) subscribeNext:^(NSNumber *x) {
  self.commentsLabel.text = [x stringValue];
  self.commentsIcon.hidden = (x == nil);
}];

photo.isVisible = YES;
</code></pre>

<p>这个代码监听了新的comments和favorites属性，当它们更新lable和image时会更新。最后，ModelView的isVisible属性被设置成YES。table view绑定辅助类只绑定可见的单元格，所以只有少部分ViewModel去请求元数据。</p>

<p>运行后，以看到以下效果：</p>

<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/06/WithMetadata-333x500.png" alt="image" /></p>

<p>是不是很酷？</p>

<h2>节流</h2>

<p>慢着，还有一个问题没有解决。当我们快速地滚动滑动栏，如果不做特殊，会同时加载大量的元数据和图片，这将明显地降低我们程序的性能。为了解决这个问题，程序应该只在照片显示在界面上的的时候去初始化元数据请求。现在ViewModel的isVisible属性被设置为YES，但不会被设置成NO。我们现在来处理这个问题。</p>

<p>打开RWTSearchResultsTableViewCell.m，然后修改刚才添加到bindViewModel:的代码，以设置isVisible属性：</p>

<pre><code>photo.isVisible = YES;
[self.rac_prepareForReuseSignal subscribeNext:^(id x) {
  photo.isVisible = NO;
}];
</code></pre>

<p>当ViewModel绑定到View时，isVisible属性会被设置成YES。但是当cell被移出table view进行重用时会被设置成NO。我们通过rac_prepareForReuseSignal信号来实现这步操作。</p>

<p>返回到RWTSearchResultsItemViewModel中。ViewModel需要监听isVisible属性的修改，当属性被设置成YES后一秒钟，将发送一个元数据的请求。</p>

<p>在RWTSearchResultsItemViewModel.m中，更新initialize方法，移除fetchMetadata信号的创建。使用以下代码来替换：</p>

<pre><code>// 1. 通过监听isVisible属性来创建信号。该信号发出的第一个next事件将包含这个属性的初始状态。
// 因为我们只关心这个值的改变，所以在第一个事件上调用skip操作。
RACSignal *visibleStateChanged = [RACObserve(self, isVisible) skip:1];

// 2. 通过过滤visibleStateChanged信号来创建一个信号对，一个标识从可见到隐藏的转换，另一个标识从隐藏到可见的转换
RACSignal *visibleSignal = [visibleStateChanged filter:^BOOL(NSNumber *value) {
  return [value boolValue];
}];

RACSignal *hiddenSignal = [visibleStateChanged filter:^BOOL(NSNumber *value) {
  return ![value boolValue];
}];

// 3. 这里是最神奇的地方。通过延迟visibleSignal信号1秒钟来创建fetchMetadata信号，在获取元数据之前暂停一会。
// takeUntil操作确保如果cell在1秒的时间间隔内又一次隐藏时，来自visibleSignal的next事件被挂起且不获取元数据。
RACSignal *fetchMetadata = [[visibleSignal delay:1.0f]
                           takeUntil:hiddenSignal];
</code></pre>

<p>你可以想像一下如果没有ReactiveCocoa，这会有多复杂。</p>

<p>运行程序，现在我们和滑动显示平滑多了。</p>

<h2>错误处理</h2>

<p>当前搜索Flickr的代码只处理了OFFlickrAPIRequestDelegate协议中的flickrAPIRequest:didCompleteWithResponse:方法。不过，这样网络请求由于多种原因会出错。一个好的应用程序必须处理这些错误，以给用户一个良好的用户体验。代理同时定义了flickrAPIRequest:didFailWithError:方法，这个方法在请求出错时调用。我们将用这个方法来处理错误并显示一个提示框给用户。</p>

<p>我们之前讲过信号会发出next，completed和错误事件。其结果是，我们并不需要做太多的事情。</p>

<p>打开RWTFlickrSearchImpl.m，并定位到signalFromAPIMethod:arguments:transform:方法。在这个方法中，在创建successSignal变量前添加以下代码：</p>

<pre><code>RACSignal *errorSignal =
  [self rac_signalForSelector:@selector(flickrAPIRequest:didFailWithError:)
                 fromProtocol:@protocol(OFFlickrAPIRequestDelegate)];

[errorSignal subscribeNext:^(RACTuple *tuple) {
  [subscriber sendError:tuple.second];
}];
</code></pre>

<p>上面的代码从代理方法中创建了一个信号，订阅了该信号，如果发生错误则发送一个错误。传递给subscribeNext块的元组包含传递给flickrAPIRequest:didFailWithError:方法的变量。结果是，tuple.second获取源错误并使用它来为错误事件服务。这是一个很好的解决方案，你觉得呢？不是所有的API请求都有内建的错误处理。接下来我们使用它。</p>

<p>RWTFlickrSearchViewModel不直接暴露信号给视图。相反它暴露一个状态和一个命令。我们需要扩展接口来提供错误报告。</p>

<p>打开RWTFlickrSearchViewModel.h并添加以下属性：</p>

<pre><code>@property (strong, nonatomic) RACSignal *connectionErrors;
</code></pre>

<p>打开RWTFlickrSearchViewModel.m并添加以下代码到initialize实现的最后：</p>

<pre><code>self.connectionErrors = self.executeSearch.errors;
</code></pre>

<p>executeSearch属性是一个ReactiveCococa框架的RACCommand对象。RACCommand类有一个errors属性，用于发送命令执行时产生的任何错误。</p>

<p>为了处理这些错误，打开RWTFlickrSearchViewController.m并添加以下的代码到initWithViewModel:方法中：</p>

<pre><code>[_viewModel.connectionErrors subscribeNext:^(NSError *error) {
  UIAlertView *alert =
  [[UIAlertView alloc] initWithTitle:@"Connection Error"
                             message:@"There was a problem reaching Flickr."
                            delegate:nil
                   cancelButtonTitle:@"OK"
                   otherButtonTitles:nil];
  [alert show];
}];
</code></pre>

<p>运行后，处理错误的效果如下：</p>

<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2014/06/ErrorMessages-281x500.png" alt="image" /></p>

<p>想知道为什么获取收藏和评论的请求不报告错误么？这是由设计决定的，主要是这些不会影响程序的可用性。</p>

<h2>添加最近搜索列表</h2>

<p>用户可能会回去查看一些重复的图片。所以，我们可以做些简化操作。回想一下本文的开头，最后的程序在搜索输入框下面有一个显示最近搜索结果的列表。</p>

<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2014/06/FinishedApp-671x500.png" alt="image" /></p>

<p>现在我们只需要添加上这个功能，这次我要向你发起一个挑战了。我将这一部分的实现留给读者您来处理，来练习练习MVVM技能吧。</p>

<p>在开始之前，我在这些做些总结：</p>

<ol>
<li>我将创建一个ViewModel来表示每个先前的搜索，它包含一些属性，这些属性包括搜索文本，匹配的数量和第一个匹配的图片</li>
<li>我将修改RWTFlickrSearchViewModel来暴露这些新的ViewModel对象的数组做为一个属性。</li>
<li>使用CETableViewBindingHelper可以非常简单地渲染ViewModel的数组，我已经添加了一个合适的cell(RWTRecentSearchItemTableViewCell)到工程中。</li>
</ol>


<h2>接下来何去何从？</h2>

<p>在<a href="https://github.com/ColinEberhardt/ReactiveFlickrSearch">这里</a>可以下载最终的程序。这两部分的内容已经包含了很多内容，这里我们可以好好回顾一下主要点：</p>

<ol>
<li>MVVM是MVC模式的一个变种，它正逐渐流行起来</li>
<li>MVVM模式让View层代码变得更清晰，更易于测试</li>
<li>严格遵守View=>ViewModel=>Model这样一个引用层次，然后通过绑定来将ViewModel的更新反映到View层上。</li>
<li>ViewModel层决不应该维护View的引用</li>
<li>ViewModel层可以看作是视图的模型(model-of-the-view)，它暴露属性，以直接反映视图的状态，以及执行用户交互相关的命令。</li>
<li>Model层暴露服务。</li>
<li>针对MVVM程序的测试可以在没有UI的情况下运行。</li>
<li>ReactiveCocoa框架提供强大的机制来将ViewModel绑定到View。它同时也广泛地使用在ViewModel和Model层中。</li>
</ol>


<p>怎么样，下次创建程序的时候，是不是试试MVVM？试试吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MVVM指南一：Flickr搜索实例]]></title>
    <link href="http://southpeak.github.io/blog/2014/08/08/mvvmzhi-nan-yi-:flickrsou-suo-shi-li/"/>
    <updated>2014-08-08T18:54:42+08:00</updated>
    <id>http://southpeak.github.io/blog/2014/08/08/mvvmzhi-nan-yi-:flickrsou-suo-shi-li</id>
    <content type="html"><![CDATA[<p>本文由Colin Eberhardt发表于raywenderlich，原文可查看<a href="http://www.raywenderlich.com/74106/mvvm-tutorial-with-reactivecocoa-part-1">MVVM Tutorial with ReactiveCocoa: Part &frac12;</a></p>

<p>你可能已经在Twitter上听过这个这个笑话了：</p>

<p>“iOS Architecture, where MVC stands for Massive View Controller”</p>

<p>当然这在iOS开发圈内，这是个轻松的笑话，但我敢确定你大实践中遇到过这个问题：即视图控制器太大且难以管理。</p>

<p>这篇文章将介绍另一种构建应用程序的模式&mdash;MVVM(Model-View-ViewModel)。通过结合ReactiveCocoa便利性，这个模式提供了一个很好的代替MVC的方案，它保证了让视图控制器的轻量性。</p>

<p>在本文我，我们将通过构建一个简单的Flickr查询程序来一步步了解MVVM，这个程序的效果图如下所示：</p>

<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/06/FinishedApp.png" alt="image" /></p>

<p>在开始写代码之前，我们先来了解一些基本的原理。</p>

<p>原文简要介绍了一下ReactiveCocoa，在此不在翻译，可以查看以下文章：</p>

<p><a href="http://southpeak.github.io/blog/2014/08/02/reactivecocoazhi-nan-%5B%3F%5D-:xin-hao/">ReactiveCocoa指南一：信号</a></p>

<p><a href="http://southpeak.github.io/blog/2014/08/02/reactivecocoazhi-nan-er-:twittersou-suo-shi-li/">ReactiveCocoa指南二：Twitter搜索实例</a></p>

<h2>MVVM模式介绍</h2>

<p>正如其名称一下，MVVM是一个UI设计模式。它是MV*模式集合中的一员。MV*模式还包含MVC(Model View Controller)、MVP(Model View Presenter)等。这些模式的目的在于将UI逻辑与业务逻辑分离，以让程序更容易开发和测试。为了更好的理解MVVM模式，我们可以看看其来源。</p>

<p>MVC是最初的UI设计模式，最早出现在Smalltalk语言中。下图展示了MVC模式的主要组成：</p>

<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/06/MVCPattern-2.png" alt="image" /></p>

<p>这个模式将UI分成Model(表示程序状态)、View(由UI控件组成)、Controller(处理用户交互与更新model)。MVC模式的最大问题是其令人相当困惑。它的概念看起来很好，但当我们实现MVC时，就会产生上图这种Model-View-Controller之间的环状关系。这种相互关系将会导致可怕的混乱。</p>

<p>最近Martin Fowler介绍了MVC模式的一个变种，这种模式命名为MVVM，并被微软广泛采用并推广。</p>

<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/06/MVVMPattern.png" alt="image" /></p>

<p>这个模式的核心是ViewModel，它是一种特殊的model类型，用于表示程序的UI状态。它包含描述每个UI控件的状态的属性。例如，文本输入域的当前文本，或者一个特定按钮是否可用。它同样暴露了视图可以执行哪些行为，如按钮点击或手势。</p>

<p>我们可以将ViewModel看作是视图的模型(model-of-the-view)。MVVM模式中的三部分比MVC更加简洁，下面是一些严格的限制</p>

<ol>
<li>View引用了ViewModel，但反过来不行。</li>
<li>ViewModel引用了Model，但反过来不行。</li>
</ol>


<p>如果我们破坏了这些规则，便无法正确地使用MVVM。</p>

<p>这个模式有以下一些立竿见影的优势：</p>

<ol>
<li>轻量的视图：所有的UI逻辑都在ViewModel中。</li>
<li>便于测试：我们可以在没有视图的情况下运行整个程序，这样大大地增加了它的可测试性。</li>
</ol>


<p>现在你可能注意到一个问题。如果View引用了ViewModel，但ViewModel没有引用View，那ViewModel如何更新视图呢？哈哈，这就得靠MVVM模式的私密武器了。</p>

<h2>MVVM和数据绑定</h2>

<p>MVVM模式依赖于数据绑定，它是一个框架级别的特性，用于自动连接对象属性和UI控件。例如，在微软的WPF框架中，下面的标签将一个TextField的Text属性绑定到ViewModel的Username属性中。</p>

<pre><code>&lt;TextField Text=”{DataBinding Path=Username, Mode=TwoWay}”/&gt;
</code></pre>

<p>WPF框架将这两个属性绑定到一起。</p>

<p>不过可惜的是，iOS没有数据绑定框架，幸运的是我们可以通过ReactiveCocoa来实现这一功能。我们从iOS开发的角度来看看MVVM模式，ViewController及其相关的UI(nib, stroyboard或纯代码的View)组成了View:</p>

<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/06/MVVMReactiveCocoa.png" alt="image" /></p>

<p>&hellip;&hellip;而ReactiveCocoa绑定了View和ViewModel。</p>

<p>理论讲得差不多了，我们可以开始新的历程了。</p>

<h2>启动项目结构</h2>

<p>可以从<a href="http://cdn5.raywenderlich.com/wp-content/uploads/2014/06/FlickrSearchStarterProject1.zip">FlickrSearchStarterProject.zip</a>中下载启动项目。我们使用Cocoapods来管理第三方库，在对应目录下执行pod install命令生成依赖库后，我们就可以打开生成的RWTFlickrSearch.xcworkspace来运行我们的项目了，初始运行效果如下图：</p>

<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/06/first-launch.jpg" alt="image" /></p>

<p>我们行熟悉下工程的结构：</p>

<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2014/06/EmptyInterface.png" alt="image" /></p>

<p>Model和ViewModel分组目前是空的，我们会慢慢往里面添加东西。View分组包含以下几个类</p>

<ol>
<li>RWTFlickSearchViewController：程序的主屏幕，包含一个搜索输入域和一个GO按钮。</li>
<li>RWTRecentSearchItemTableViewCell：用于在主页中显示搜索结果的table cell</li>
<li>RWTSearchResultsViewController：搜索结果页，显示来自Flickr的tableview</li>
<li>RWTSearchResultsTableViewCell：渲染来自Flickr的单个图片的table cell。</li>
</ol>


<p>现在来写我们的第一个ViewModel吧。</p>

<h2>第一个ViewModel</h2>

<p>在ViewModel分组中添加一个继承自NSObject的新类RWTFlickrSearchViewModel。然后在该类的头文件中，添加以下两行代码：</p>

<pre><code>@property (nonatomic, strong) NSString *searchText;
@property (nonatomic, strong) NSString *title;
</code></pre>

<p>searchText属性表示文本域中显示文本，title属性表示导航条上的标题。</p>

<p>打开RWTFlickrSearchViewModel.m文件添加以下代码：</p>

<pre><code>@implementation RWTFlickrSearchViewModel

- (instancetype)init
{
    self = [super init];

    if (self)
    {
        [self initialize];
    }

    return self;
}

- (void)initialize
{
    self.searchText = @"search text";
    self.title = @"Flickr Search";
}

@end
</code></pre>

<p>这段代码简单地设置了ViewModel的初始状态。</p>

<p>接下来我们将连接ViewModel到View。记住View保存了一个ViewModel的引用。在这种情况下，添加一个给定ViewModel的初始化方法来构造View是很有必要的。打开RWTFlickrSearchViewController.h，并导入ViewModel头文件：</p>

<pre><code>#import "RWTFlickrSearchViewModel.h"
</code></pre>

<p>并添加以下初始化方法：</p>

<pre><code>@interface RWTFlickrSearchViewController : UIViewController

- (instancetype)initWithViewModel:(RWTFlickrSearchViewModel *)viewModel;

@end
</code></pre>

<p>在RWTFlickrSearchViewController.m中，在类的扩展中添加以下私有属性：</p>

<pre><code>@property (weak, nonatomic) RWTFlickrSearchViewModel *viewModel;
</code></pre>

<p>然后添加以下方法：</p>

<pre><code>- (instancetype)initWithViewModel:(RWTFlickrSearchViewModel *)viewModel
{
    self = [super init];

    if (self)
    {
        _viewModel = viewModel;
    }

    return self;
}
</code></pre>

<p>这就在view中存储了一个到ViewModel的引用。<em>注意这是一个弱引用，这样View引用了ViewModel，但没有拥有它。</em></p>

<p>接下来在viewDidLoad里面添加下面代码：</p>

<pre><code>[self bindViewModel];
</code></pre>

<p>该方法的实现如下：</p>

<pre><code>- (void)bindViewModel
{
    self.title = self.viewModel.title;
    self.searchTextField.text = self.viewModel.searchText;
}
</code></pre>

<p>最后我们需要创建ViewModel，并将其提供给View。在RWTAppDelegate.m中，添加以下头文件：</p>

<pre><code>#import "RWTFlickrSearchViewModel.h"
</code></pre>

<p>同时添加一个私有属性：</p>

<pre><code>@property (nonatomic, strong) RWTFlickrSearchViewModel *viewModel;
</code></pre>

<p>我们会发现这个类中已以有一个createInitialViewController方法了，我们用以下代码来更新它：</p>

<pre><code>- (UIViewController *)createInitialViewController {
    self.viewModel = [RWTFlickrSearchViewModel new];
    return [[RWTFlickrSearchViewController alloc] initWithViewModel:self.viewModel];
}
</code></pre>

<p>这个方法创建了一个ViewModel实例，然后构造并返回了View。这个视图作程序导航控制器的初始视图。</p>

<p>运行后的状态如下：</p>

<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/06/ViewWithState-333x500.png" alt="image" /></p>

<p>这样我们就得到了第一个ViewModel。不过仍然有许多东西要学的。你可能已经发现了我们还没有使用ReactiveCocoa。到目前为止，用户在输入框上的输入操作不会影响到ViewModel。</p>

<h2>检测可用的搜索状态</h2>

<p>现在，我们来看看如何用ReactiveCocoa来绑定ViewModel和View，以将搜索输入框和按钮连接到ViewModel。</p>

<p>在RWTFlickrSearchViewController.m中，我们使用如下代码更新bindViewModel方法。</p>

<pre><code>- (void)bindViewModel
{
    self.title = self.viewModel.title;
    RAC(self.viewModel, searchText) = self.searchTextField.rac_textSignal;
}
</code></pre>

<p>在ReactiveCocoa中，使用了分类将rac_textSignal属性添加到UITextField类中。它是一个信号，在文本域每次更新时会发送一个包含当前文本的next事件。</p>

<p>RAC是一个用于做绑定操作的宏，上面的代码会使用rac_textSignal发出的next信号来更新viewModel的searchText属性。</p>

<p>搜索按钮应该只有在用户输入有效时才可点击。为了方便起见，我们以输入字符大于3时输入有效为准。在RWTFlickrSearchViewModel.m中导入以下头文件。</p>

<pre><code>#import &lt;ReactiveCocoa/ReactiveCocoa.h&gt;
</code></pre>

<p>然后更新初始化方法：</p>

<pre><code>- (void)initialize
{
    self.title = @"Flickr Search";

    RACSignal *validSearchSignal =
    [[RACObserve(self, searchText)
      map:^id(NSString *text) {
        return @(text.length &gt; 3);
    }]
     distinctUntilChanged];

    [validSearchSignal subscribeNext:^(id x) {
        NSLog(@"search text is valid %@", x);
    }];
}
</code></pre>

<p>运行程序并在输入框中输入一些字符，在控制台中我们可以看到以下输出：</p>

<pre><code>2014-08-07 21:50:44.078 RWTFlickrSearch[3116:60b] search text is valid 0
2014-08-07 21:50:59.493 RWTFlickrSearch[3116:60b] search text is valid 1
2014-08-07 21:51:02.594 RWTFlickrSearch[3116:60b] search text is valid 0
</code></pre>

<p>上面的代码使用RACObserve宏来从ViewModel的searchText属性创建一个信号。map操作将文本转化为一个true或false值的流。</p>

<p>最后，distinctUntilChanges确保信号只有在状态改变时才发出值。</p>

<p>到目前为止，我们可以看到ReactiveCocoa被用于将绑定View绑定到ViewModel，确保了这两者是同步的。另进一步地，ViewModel内部的ReactiveCocoa代码用于观察自己的状态及执行其它操作。</p>

<p>这就是MVVM模式的基本处理过程。ReactiveCocoa通常用于绑定View和ViewModel，但在程序的其它层也非常有用。</p>

<h2>添加搜索命令</h2>

<p>本节将上面创建的validSearchSignal来创建绑定到View的操作。打开RWTFlickrSearchViewModel.h并添加以下头文件</p>

<pre><code>#import &lt;ReactiveCocoa/ReactiveCocoa.h&gt;
</code></pre>

<p>同时添加以下属性</p>

<pre><code>@property (strong, nonatomic) RACCommand *executeSearch;
</code></pre>

<p>RACCommand是ReactiveCocoa中用于表示UI操作的一个类。它包含一个代表了UI操作的结果的信号以及标识操作当前是否被执行的一个状态。</p>

<p>在RWTFlickrSearchViewModel.m的initialize方法的最后添加以下代码：</p>

<pre><code>self.executeSearch = [[RACCommand alloc] initWithEnabled:validSearchSignal
                                             signalBlock:^RACSignal *(id input) {
                                                 return [self executeSearchSignal];
                                             }];
</code></pre>

<p>这创建了一个在validSearchSignal发送true时可用的命令。另外，需要在下面实现executeSearchSignal方法，它提供了命令所执行的操作。</p>

<pre><code>- (RACSignal *)executeSearchSignal
{
    return [[[[RACSignal empty] logAll] delay:2.0] logAll];
}
</code></pre>

<p>在这个方法中，我们执行一些业务逻辑操作，以作为命令执行的结果，并通过信号异步返回结果。</p>

<p>到目前为止，上述代码只提供了一个简单的实现：空信号会立即完成。delay操作会将其所接收到的next或complete事件延迟两秒执行。</p>

<p>最后一步是将这个命令连接到View中。打开RWTFlickrSearchViewController.m并在bindViewModel方法的结尾中添加以下代码：</p>

<pre><code>self.searchButton.rac_command = self.viewModel.executeSearch;
</code></pre>

<p>rac_command属性是UIButton的ReactiveCocoa分类中添加的属性。上面的代码确保点击按钮执行给定的命令，且按钮的可点击状态反应了命令的可用状态。</p>

<p>运行代码，输入一些字符并点击GO，得到如下结果：</p>

<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/06/GoButtonEnabled-333x500.png" alt="image" /></p>

<p>可以看到，当输入有效点击按钮时，按钮会置灰2秒钟，当执行的信号完成时又可点击。我们可以看下控制台的输出，可以发现空信号会立即完成，而延迟操作会在2秒后发出事件：</p>

<pre><code>2014-08-07 22:21:25.128 RWTFlickrSearch[3161:60b] &lt;RACDynamicSignal: 0x17005ba20&gt; name: +empty completed
2014-08-07 22:21:27.329 RWTFlickrSearch[3161:60b] &lt;RACDynamicSignal: 0x17005dd30&gt; name: [+empty] -delay: 2.000000 completed
</code></pre>

<p>是不是很酷？</p>

<h2>绑定、绑定还是绑定</h2>

<p>RACCommand监听了搜索按钮状态的更新，但处理activity indicator的可见性则由我们负责。RACCommand暴露了一个executing属性，它是一个信号，发送true或false来标明命令开始和结束执行的时间。我们可以用这个来影响当前命令的状态。</p>

<p>在RWTFlickrSearchViewController.m中的bindViewModel方法结尾处添加以下代码：</p>

<pre><code>RAC([UIApplication sharedApplication], networkActivityIndicatorVisible) = self.viewModel.executeSearch.executing;
</code></pre>

<p>这将UIApplication的networkActivityIndicatorVisible属性绑定到命令的executing信号中。这确保了不管命令什么时候执行，状态栏中的网络activity indicator都会显示。</p>

<p>接下来添加以下代码：</p>

<pre><code>RAC(self.loadingIndicator, hidden) = [self.viewModel.executeSearch.executing not];
</code></pre>

<p>当命令执行时，应该隐藏加载indicator。这可以通过not操作来反转信号。</p>

<p>最后，添加以下代码：</p>

<pre><code>[self.viewModel.executeSearch.executionSignals subscribeNext:^(id x) {
    [self.searchTextField resignFirstResponder];
}];
</code></pre>

<p>这段代码确保命令执行时隐藏键盘。executionSignals属性发送由命令每次执行时生成的信号。这个属性是信号的信号(见<a href="http://southpeak.github.io/blog/2014/08/02/reactivecocoazhi-nan-%5B%3F%5D-:xin-hao/">ReactiveCocoa指南一：信号</a>)。当创建和发出一个新的命令执行信号时，隐藏键盘。</p>

<p>运行程序看看效果如何吧。</p>

<h2>Model在哪？</h2>

<p>到目前为止，我们已经有了一个清晰的View(RWTFlickrSearchViewController)和ViewModel(RWTFlickrSearchViewModel)，但是Model在哪呢？</p>

<p>答案很简单：没有！</p>

<p>当前的程序执行一个命令来响应用户点击搜索按钮的操作，但是实现不做任何值的处理。ViewModel真正需要做的是使用当前的searchText来搜索Flickr，并返回一个匹配的列表。</p>

<p>我们应该可以直接在ViewModel添加业务逻辑，但相信我，你不希望这么做。如果这是一个viewcontroller，我打赌你一定会直接这么做。</p>

<p>ViewModel暴露属性来表示UI状态，它同样暴露命令来表示UI操作(通常是方法)。ViewModel负责管理基于用户交互的UI状态的改变。然而它不负责实际执行这些交互产生的的业务逻辑，那是Model的工作。</p>

<p>接下来，我们将在程序中添加Model层。</p>

<p>在Model分组中，添加RWTFlickrSearch协议并提供以下实现</p>

<pre><code>#import &lt;ReactiveCocoa/ReactiveCocoa.h&gt;

@protocol RWTFlickrSearch &lt;NSObject&gt;

- (RACSignal *)flickrSearchSignal:(NSString *)searchString;

@end
</code></pre>

<p>这个协议定义了Model层的初始接口，并将搜索Flickr的责任移出ViewModel。</p>

<p>接下来在Model分组中添加RWTFlickrSearchImpl类，其继承自NSObject，并实现了RWTFlickrSearch协议，如下代码所示：</p>

<pre><code>#import "RWTFlickrSearch.h"

@interface RWTFlickrSearchImpl : NSObject &lt;RWTFlickrSearch&gt;

@end
</code></pre>

<p>打开RWTFlickrSearchImpl.m文件，提供以下实现：</p>

<p>@implementation RWTFlickrSearchImpl</p>

<pre><code>- (RACSignal *)flickrSearchSignal:(NSString *)searchString
{
    return [[[[RACSignal empty] logAll] delay:2.0] logAll];
}

@end
</code></pre>

<p>看着是不是有hkko眼熟？没错，我们在上面的ViewModel中有相同的实现。</p>

<p>接下来我们需要在ViewModel层中使用Model层。在ViewModel分组中添加RWTViewModelServices协议并如下实现：</p>

<pre><code>#import "RWTFlickrSearch.h"

@protocol RWTViewModelServices &lt;NSObject&gt;

- (id&lt;RWTFlickrSearch&gt;)getFlickrSearchService;

@end
</code></pre>

<p>这个协议定义了唯一的一个方法，以允许ViewModel获取一个引用，以指向RWTFlickrSearch协议的实现对象。</p>

<p>打开RWTFlickrSearchViewModel.h并导入头文件</p>

<pre><code>#import "RWTViewModelServices.h"
</code></pre>

<p>更新初始化方法并将RWTViewModelServices作为一个参数：</p>

<pre><code>- (instancetype)initWithServices:(id&lt;RWTViewModelServices&gt;)services;
</code></pre>

<p>在RWTFlickrSearchViewModel.m中，添加类的分类并提供一个私有属性来维护一个到RWTViewModelServices的引用：</p>

<pre><code>@interface RWTFlickrSearchViewModel ()

@property (nonatomic, weak) id&lt;RWTViewModelServices&gt; services;

@end
</code></pre>

<p>在该文件下面，添加初始化方法的实现：</p>

<pre><code>- (instancetype)initWithServices:(id&lt;RWTViewModelServices&gt;)services
{
    self = [super init];

    if (self)
    {
        _services = services;
        [self initialize];
    }

    return self;
}
</code></pre>

<p>这只是简单的存储了services的引用。</p>

<p>最后，更新executeSearchSignal方法：</p>

<pre><code>- (RACSignal *)executeSearchSignal
{
    return [[self.services getFlickrSearchService] flickrSearchSignal:self.searchText];
}
</code></pre>

<p>最后是连接Model和ViewModel。</p>

<p>在工程的根分组中，添加一个NSObject的子类RWTViewModelServicesImpl。打开RWTViewModelServicesImpl.h并实现RWTViewModelServices协议：</p>

<pre><code>#import "RWTViewModelServices.h"

@interface RWTViewModelServicesImpl : NSObject &lt;RWTViewModelServices&gt;

@end
</code></pre>

<p>打开RWTViewModelServicesImpl.m，并添加实现：</p>

<pre><code>#import "RWTFlickrSearchImpl.h"

@interface RWTViewModelServicesImpl ()

@property (strong, nonatomic) RWTFlickrSearchImpl *searchService;

@end

@implementation RWTViewModelServicesImpl

- (instancetype)init
{
    if (self = [super init])
    {
        _searchService = [RWTFlickrSearchImpl new];
    }

    return self;
}

- (id&lt;RWTFlickrSearch&gt;)getFlickrSearchService
{
    return self.searchService;
}

@end
</code></pre>

<p>这个类简单创建了一个RWTFlickrSearchImpl实例，用于Model层搜索Flickr服务，并将其提供给ViewModel的请求。</p>

<p>最后，在RWTAppDelegate.m中添加以下头文件</p>

<pre><code>#import "RWTViewModelServicesImpl.h"
</code></pre>

<p>并添加一个新的私有属性</p>

<pre><code>@property (nonatomic, strong) RWTViewModelServicesImpl *viewModelServices;
</code></pre>

<p>再更新createInitialViewController方法：</p>

<pre><code>- (UIViewController *)createInitialViewController {
    self.viewModelServices = [RWTViewModelServicesImpl new];
    self.viewModel = [[RWTFlickrSearchViewModel alloc] initWithServices:self.viewModelServices];
    return [[RWTFlickrSearchViewController alloc] initWithViewModel:self.viewModel];
}
</code></pre>

<p>运行程序，验证程序有没有按之前的方式来工作。当然，这不是最有趣的变化，不过，可以看看新代码的形状了。</p>

<p>Model层暴露了一个ViewModel层使用的&#8217;服务&#8217;。一个协议定义了这个服务的接口，提供了松散的组合。</p>

<p>我们可以使用这种方式来为单元测试提供一个类似的服务实现。程序现在有了正确的MVVM结构，让我们小结一下：</p>

<ol>
<li>Model层暴露服务并负责提供程序的业务逻辑实现。</li>
<li>ViewModel层表示程序的视图状态(view-state)。同时响应用户交互及来自Model层的事件，两者都受view-state变化的影响。</li>
<li>View层很薄，只提供ViewModel状态的显示及输出用户交互事件。</li>
</ol>


<h2>搜索Flickr</h2>

<p>我们继续来完成Flickr的搜索实现，事情变得越来越有趣了。</p>

<p>首先我们创建表示搜索结果的模型对象。在Model分组中，添加RWTFlickrPhoto类，并为其添加三个属性。</p>

<pre><code>@interface RWTFlickrPhoto : NSObject

@property (nonatomic, strong) NSString *title;
@property (nonatomic, strong) NSURL *url;
@property (nonatomic, strong) NSString *identifier;

@end
</code></pre>

<p>这个模型对象表示由Flickr搜索API返回一个图片。</p>

<p>打开RWTFlickrPhoto.m，并添加以下描述方法的实现：</p>

<pre><code>- (NSString *)description
{
    return self.title;
}
</code></pre>

<p>接下来，新建一个新的模型对象类RWTFlickrSearchResults，并添加以下属性：</p>

<pre><code>@interface RWTFlickrSearchResults : NSObject

@property (strong, nonatomic) NSString *searchString;
@property (strong, nonatomic) NSArray *photos;
@property (nonatomic) NSInteger totalResults;

@end
</code></pre>

<p>这个类表示由Flickr搜索返回的照片集合。</p>

<p>是时候实现搜索Flickr了。打开RWTFlickrSearchImpl.m并导入以下头文件：</p>

<pre><code>#import "RWTFlickrSearchResults.h"
#import "RWTFlickrPhoto.h"
#import &lt;objectiveflickr/ObjectiveFlickr.h&gt;
#import &lt;LinqToObjectiveC/NSArray+LinqExtensions.h&gt;
</code></pre>

<p>然后添加以下类扩展：</p>

<pre><code>@interface RWTFlickrSearchImpl () &lt;OFFlickrAPIRequestDelegate&gt;

@property (strong, nonatomic) NSMutableSet *requests;
@property (strong, nonatomic) OFFlickrAPIContext *flickrContext;

@end
</code></pre>

<p>这个类实现了OFFlickrAPIRequestDelegate协议，并添加了两个私有属性。我们会很快看到如何使用这些值。</p>

<p>继续添加代码：</p>

<pre><code>- (instancetype)init
{
    self = [super init];

    if (self)
    {
        NSString *OFSampleAppAPIKey = @"YOUR_API_KEY_GOES_HERE";
        NSString *OFSampleAppAPISharedSecret = @"YOUR_SECRET_GOES_HERE";

        _flickrContext = [[OFFlickrAPIContext alloc] initWithAPIKey:OFSampleAppAPIKey sharedSecret:OFSampleAppAPISharedSecret];

        _requests = [NSMutableSet new];
    }

    return self;
}
</code></pre>

<p>这段代码创建了一个Flickr的上下文，用于存储ObjectiveFlickr请求的数据。</p>

<p>当前Model层服务类提供的API有一个单独的方法，用于查找基于文本搜索字符的图片。不过我们一会会添加更多的方法。</p>

<p>在RWTFlickrSearchImpl.m中添加以下方法：</p>

<pre><code>- (RACSignal *)signalFromAPIMethod:(NSString *)method arguments:(NSDictionary *)args transform:(id (^)(NSDictionary *response))block
{
    // 1. 创建请求信号
    return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {

        // 2. 创建一个Flick请求对象
        OFFlickrAPIRequest *flickrRequest = [[OFFlickrAPIRequest alloc] initWithAPIContext:self.flickrContext];
        flickrRequest.delegate = self;
        [self.requests addObject:flickrRequest];

        // 3. 从代理方法中创建一个信号
        RACSignal *successSignal = [self rac_signalForSelector:@selector(flickrAPIRequest:didCompleteWithResponse:)
                                                  fromProtocol:@protocol(OFFlickrAPIRequestDelegate)];

        // 4. 处理响应
        [[[successSignal
         map:^id(RACTuple *tuple) {
             return tuple.second;
         }]
         map:block]
         subscribeNext:^(id x) {
             [subscriber sendNext:x];
             [subscriber sendCompleted];
         }];

        // 5. 开始请求
        [flickrRequest callAPIMethodWithGET:method arguments:args];

        // 6. 完成后，移除请求的引用
        return [RACDisposable disposableWithBlock:^{
            [self.requests removeObject:flickrRequest];
        }];
    }];
}
</code></pre>

<p>这个方法需要传入请求方法及请求参数，然后使用block参数来转换响应对象。我们重点看一下第4步：</p>

<pre><code>[[[successSignal
  // 1. 从flickrAPIRequest:didCompleteWithResponse:代理方法中提取第二个参数
  map:^id(RACTuple *tuple) {
    return tuple.second;
  }]
  // 2. 转换结果
  map:block]
  subscribeNext:^(id x) {
    // 3. 将结果发送给订阅者
    [subscriber sendNext:x];
    [subscriber sendCompleted];
  }];
</code></pre>

<p>rac_signalForSelector:fromProtocol: 方法创建了successSignal，同样也在代理方法的调用中创建了信号。</p>

<p>代理方法每次调用时，发出的next事件会附带包含方法参数的RACTuple。</p>

<p>实现Flickr搜索的最后一步如下：</p>

<pre><code>- (RACSignal *)flickrSearchSignal:(NSString *)searchString {
  return [self signalFromAPIMethod:@"flickr.photos.search"
                         arguments:@{@"text": searchString,
                                     @"sort": @"interestingness-desc"}
                         transform:^id(NSDictionary *response) {

    RWTFlickrSearchResults *results = [RWTFlickrSearchResults new];
    results.searchString = searchString;
    results.totalResults = [[response valueForKeyPath:@"photos.total"] integerValue];

    NSArray *photos = [response valueForKeyPath:@"photos.photo"];
    results.photos = [photos linq_select:^id(NSDictionary *jsonPhoto) {
      RWTFlickrPhoto *photo = [RWTFlickrPhoto new];
      photo.title = [jsonPhoto objectForKey:@"title"];
      photo.identifier = [jsonPhoto objectForKey:@"id"];
      photo.url = [self.flickrContext photoSourceURLFromDictionary:jsonPhoto
                                                              size:OFFlickrSmallSize];
      return photo;
    }];

    return results;
  }];
}
</code></pre>

<p>上面的方法使用signalFromAPIMethod:arguments:transform:方法。flickr.photos.search方法提供的字典来搜索照片。</p>

<p>传递给transform参数的block简单地将NSDictionary响应转化为一个等价的模型对象，让它在ViewModel中更容易使用。</p>

<p>最后一步是打开RWTFlickrSearchViewModel.m方法，然后更新搜索信号来记录日志：</p>

<pre><code>- (RACSignal *)executeSearchSignal {
  return [[[self.services getFlickrSearchService]
           flickrSearchSignal:self.searchText]
           logAll];
}
</code></pre>

<p>编译，运行并输入一些字符后可在控制台看到以下日志：</p>

<pre><code>2014-06-03 [...] &lt;RACDynamicSignal: 0x8c368a0&gt; name: +createSignal: next: searchString=wibble, totalresults=1973, photos=(
    "Wibble, wobble, wibble, wobble",
    "unoa-army",
    "Day 277: Cheers to the freakin' weekend!",
    [...]
    "Angry sky",
    Nemesis
)
</code></pre>

<p>这样我们MVVM指南的第一部分就差不多结束了，但在结束之前，让我们先看看内存问题吧。</p>

<h2>内存管理</h2>

<p>正如在<a href="http://southpeak.github.io/blog/2014/08/02/reactivecocoazhi-nan-er-:twittersou-suo-shi-li/">ReactiveCocoa指南二：Twitter搜索实例</a>中所讲的一样，我们在block中使用了self，这可能会导致循环引用的问题。而为了避免此问题，我们需要使用@weakify和@strongify宏来打破这种循环引用。</p>

<p>不过看看signalFromAPIMethod:arguments:transform:方法，你可能会迷惑为什么没有使用这两个宏来引用self？这是因为block是作为createSignal:方法的一个参数，它不会在self和block之间建立一个强引用关系。迷茫了吧？不相信的话只需要测试一样这段代码有没有内存泄露就行。当然这时候就得用Instruments了，自己去看吧。哈哈。</p>

<h2>何去何从？</h2>

<p>例子工程的完整代码可以在<a href="http://cdn4.raywenderlich.com/wp-content/uploads/2014/06/FlickrSearchPart1Project1.zip">这里</a>下载。在下一部分中，我们将看看如何从ViewModel中初始化一个视图控制器并实现更多的Flickr请求操作。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ReactiveCocoa指南二：Twitter搜索实例]]></title>
    <link href="http://southpeak.github.io/blog/2014/08/02/reactivecocoazhi-nan-er-:twittersou-suo-shi-li/"/>
    <updated>2014-08-02T23:20:48+08:00</updated>
    <id>http://southpeak.github.io/blog/2014/08/02/reactivecocoazhi-nan-er-:twittersou-suo-shi-li</id>
    <content type="html"><![CDATA[<p>原文由Colin Eberhardt发表于raywenderlich，<a href="http://www.raywenderlich.com/62796/reactivecocoa-tutorial-pt2">ReactiveCocoa Tutorial – The Definitive Introduction: Part 2/2</a></p>

<p><a href="http://southpeak.github.io/blog/2014/08/02/reactivecocoazhi-nan-%5B%3F%5D-:xin-hao/">第一部分</a>我们学习了ReactiveCocoa处理信号的基本流程，如何发送流事件，以及分割及组合信号。在这一部分中，我们将继续学习ReactiveCocoa更多的特性，包括：</p>

<ol>
<li>error和completed事件类型</li>
<li>节流(Throttling)</li>
<li>线程</li>
<li>扩展</li>
</ol>


<h2>Twitter Instant</h2>

<p>本部分我们将要开发的是一个称为Twitter Instant的程序，这是一个Twitter搜索应用，用于裡更新搜索结果。可以在<a href="http://cdn5.raywenderlich.com/wp-content/uploads/2014/01/TwitterInstant-Starter2.zip">这里</a>下载初始程序，同时我们需要通过Cocoapods来下载依赖库，这个过程与第一部分相同。完成之后，运行程序，将得到下面的界面：</p>

<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/01/TwitterInstantStarter.png" alt="image" /></p>

<p>我们花点时间熟悉一下。这个程序很简单。左侧控制面板是RWSearchFormViewController，有一个搜索框。右侧是RWSearchResultsViewController。如果我们打开RWSearchFormViewController.m，我们可以看到viewDidLoad方法中指定了resultsViewController属性，这个程序的主要逻辑是在RWSearchFormViewController中，这个属性将搜索结果提供给RWSearchResultsViewController。</p>

<h2>验证搜索框</h2>

<p>首先我们来校验输入框的字符长度是否大于2。我们在RWSearchFormViewController.m的viewDidLoad方法下面添加以下代码：</p>

<pre><code>- (BOOL)isValidSearchText:(NSString *)text
{
    return text.length &gt; 2;
}
</code></pre>

<p>接下来，我们在RWSearchFormViewController.m中导入ReactiveCocoa</p>

<pre><code>#import &lt;ReactiveCocoa/ReactiveCocoa.h&gt;
</code></pre>

<p>同时在viewDidLoad方法最后加上以下代码：</p>

<pre><code>[[self.searchText.rac_textSignal map:^id(NSString *text) {
    return [self isValidSearchText:text] ? [UIColor whiteColor] : [UIColor yellowColor];
}] subscribeNext:^(UIColor *color) {
    self.searchText.backgroundColor = color;
}];
</code></pre>

<p>这段代码通过信号来检测输入是否有效，并设置相应的输入框背影颜色值。运行后，可以看到如下效果：</p>

<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/01/ValidatedTextField.png" alt="image" /></p>

<p>其管道流程图如下所示：</p>

<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/01/TextValidationPipeline.png" alt="image" /></p>

<p>rac_textSignal在每次输入时发出next事件，并包含当前输入框的文本。然后map操作将其转换为颜色值，最后subscribeNext:获取这个颜色值并用它来设置输入框的背景颜色。</p>

<p>在添加Twitter查找逻辑之前，我们先看看一些有趣的东西。</p>

<h2>格式化管道代码</h2>

<p>在调用信号的方法时，我们建议每个操作都新起一行，并排列所有的步骤。如下图所示，一个复杂的管道通过分行，看起来会更加清晰</p>

<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/01/PipelineFormatting.png" alt="image" /></p>

<h2>内存管理</h2>

<p>考虑下我们添加到TwitterInstant程序中的代码，想知道我们创建的管道是如何被保存的么？当然，因为它没有被指定给变量或属性，所以它没有增加引用计数，因此注定被销毁？ReactiveCocoa设计的目的之一是允许这样一种编程样式，即管道可以匿名创建。到目前为止，我们的管道都是这么处理的。为了支持这种模式，ReactiveCocoa维护了一个全局的信号集合。如果信号有一个或多个订阅者，它就是可用的。如果所有订阅者都被移除了，信号就被释放了。</p>

<p>剩下最后一个问题：如何取消对信号的订阅？在一个completed事件或error事件后，一个订阅者会自动将自己移除。手动移除可能通过<strong>RACDisposable</strong>来完成。RACSignal的所有订阅方法都返回一个RACDisposable实例，我们可以调用它的dispose方法来手动移除订阅者。如下代码所示：</p>

<pre><code>RACSignal *backgroundColorSignal =
    [self.searchText.rac_textSignal
     map:^id(NSString *text) {
         return [self isValidSearchText:text] ? [UIColor whiteColor] : [UIColor yellowColor];
     }];

RACDisposable *subscripion =
    [backgroundColorSignal subscribeNext:^(UIColor *color) {
        self.searchText.backgroundColor = color;
    }];

// 在某个位置调用
[subscripion dispose];
</code></pre>

<p>当然实际上我们不需要这样来写，只需要知道是这么回事就行。</p>

<p><em>注意：如果我们创建了一个管道，但不去订阅它，则管理永远不会执行，包括任何如doNext:块这样的附加操作。</em></p>

<h2>避免循环引用</h2>

<p>ReactiveCocoa在幕后做了许多事情，让我们不需要担心信号的内存管理问题，但有一点关于内存管理的问题需要特别注意。我们先来看看下面的代码：</p>

<pre><code>[[self.searchText.rac_textSignal map:^id(NSString *text) {
    return [self isValidSearchText:text] ? [UIColor whiteColor] : [UIColor yellowColor];
}] subscribeNext:^(UIColor *color) {
    self.searchText.backgroundColor = color;
}];
</code></pre>

<p>subscribeNext:块使用了self，以获取文本输入域。Block会捕获并保留闭包中的值，因此如果在self与信号之间有一个强引用，则会导致循环引用问题。这是不是问题取决于self对象的生命周期。如果self的生命周期是整个程序生存期，则没问题，好好用吧。但在大多数情况下，它确实是一个问题。</p>

<p>为了避循环引用，根据苹果的文档中推荐的捕获self的一个弱引用。如下代码所示：</p>

<pre><code>__typeof(self) __weak weakSelf = self;

[[self.searchText.rac_textSignal map:^id(NSString *text) {
    return [weakSelf isValidSearchText:text] ? [UIColor whiteColor] : [UIColor yellowColor];
}] subscribeNext:^(UIColor *color) {
    weakSelf.searchText.backgroundColor = color;
}];
</code></pre>

<p>在上面的代码中weakSelf是self对象的一个弱引用。现在subscribeNext:中使用了这个变量。不过ReactiveCocoa框架给我们提供了一个更好的选择。首先导入以下头文件：</p>

<pre><code>#import &lt;RACEXTScope.h&gt;
</code></pre>

<p>然后使用以下代码：</p>

<pre><code>@weakify(self)

[[self.searchText.rac_textSignal map:^id(NSString *text) {
    return [self isValidSearchText:text] ? [UIColor whiteColor] : [UIColor yellowColor];
}] subscribeNext:^(UIColor *color) {
    @strongify(self)
    self.searchText.backgroundColor = color;
}];
</code></pre>

<p>宏@weakify与@strongify在<a href="https://github.com/jspahrsummers/libextobjc">Extended Objective-C</a>库中引用，它们包含在ReactiveCocoa框架中。@weakify允许我们创建一些影子变量，它是都是弱引用(可以同时创建多个)，@strongify允许创建变量的强引用，这些变量是先前传递给@weakify的。</p>

<p>最后需要注意的是，当在block中使用实例变量时，block同样会捕获self的一个强引用。我们可以打开编译器警告，来提示我们这种情况。如下所求来处理</p>

<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/01/AvoidRetainSelf.png" alt="image" /></p>

<p>OK，内存问题说得差不多了，现在我们回到正题。</p>

<h2>请求访问Twitter</h2>

<p>我们将使用Social Framework以允许TwitterInstant程序搜索Tweets，同时使用Accounts Framework来获取对Twitter的访问。</p>

<p>在添加代码前，我们需要先登录Twitter。可以在系统的设置中登录，如下图所示：</p>

<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/01/TwitterCredentials.png" alt="image" /></p>

<p>我们的工程已经添加了所需要的框架，所以只需要在RWSearchFormViewController.m导入头文件。</p>

<pre><code>#import &lt;Accounts/Accounts.h&gt;
#import &lt;Social/Social.h&gt;
</code></pre>

<p>然后在下面添加枚举及常量用于标识错误：</p>

<pre><code>typedef NS_ENUM(NSInteger, RWTwitterInstantError) {
    RWTwitterInstantErrorAccessDenied,
    RWTwitterInstantErrorNoTwitterAccounts,
    RWTwitterInstantErrorInvalidResponse
};

static NSString * const RWTwitterInstantDomain = @"TwitterInstant";
</code></pre>

<p>然后我们RWSearchFormViewController()分类中添加以下代码：</p>

<pre><code>@property (strong, nonatomic) ACAccountStore *accountStore;
@property (strong, nonatomic) ACAccountType *twitterAccountType;
</code></pre>

<p>ACAccountsStore类提供了我们的设备可连接的多种社交账号，ACAccountType类表示账号的指定类型。</p>

<p>我们在viewDidLoad的结尾处添加以下代码，来创建账户存储及Twitter账户标识：</p>

<pre><code>self.accountStore = [[ACAccountStore alloc] init];
self.twitterAccountType = [self.accountStore accountTypeWithAccountTypeIdentifier:ACAccountTypeIdentifierTwitter];
</code></pre>

<p>当账户请求社账号时，用户可以看到一个弹出框。这是一个异步操作，所以将其包装到一个信号中是很好的选择。</p>

<p>仍然在这个文件中，添加以下代码：</p>

<pre><code>- (RACSignal *)requestAccessToTwitterSignal
{
    // 定义一个错误，如果用户拒绝访问则发送
    NSError *accessError = [NSError errorWithDomain:RWTwitterInstantDomain code:RWTwitterInstantErrorAccessDenied userInfo:nil];

    // 创建并返回信号
    @weakify(self)
    return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {

        // 请求访问twitter
        @strongify(self)
        [self.accountStore requestAccessToAccountsWithType:self.twitterAccountType
                                                   options:nil
                                                completion:^(BOOL granted, NSError *error) {
                                                    // 处理响应
                                                    if (!granted)
                                                    {
                                                        [subscriber sendError:accessError];
                                                    }
                                                    else
                                                    {
                                                        [subscriber sendNext:nil];
                                                        [subscriber sendCompleted];
                                                    }
                                                }];
        return nil;
    }];
}
</code></pre>

<p>一个信号可以发送三种事件类型：next, completed, error。</p>

<p>在信号的整个生命周期中，都可能不会发送事件，或者发送一个或多个next事件，其后跟着completed或error事件。</p>

<p>最后，为了使用这个信号，在viewDidLoad中添加以下代码：</p>

<pre><code>[[self requestAccessToTwitterSignal]
 subscribeNext:^(id x) {
     NSLog(@"Access granted");
 } error:^(NSError *error) {
     NSLog(@"An error occurred: %@", error);
 }];
</code></pre>

<p>运行程序，可以看到下面的提示</p>

<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2014/01/RequestAccessToTwitter.png" alt="image" /></p>

<p>如果点击OK，subscribeNext:块中的日志会打印出来。如果点击Don&rsquo;t allow，则会执行错误块并打印期望的信息。</p>

<h2>链接信号</h2>

<p>一旦用户获取了Twitter账户的访问权限，程序需要继续监听搜索框的输入，以查询twitter。程序需要等待请求访问Twitter的信号来发出完成事件，然后订阅广西输入框的信号。不同信号的顺序链接是一个问题，但ReactiveCocoa已经做了很好的处理。</p>

<p>在viewDidLoad中用下面代码来替换当前的管道：</p>

<pre><code>[[[self requestAccessToTwitterSignal]
 then:^RACSignal *{
     @strongify(self)
     return self.searchText.rac_textSignal;
 }]
 subscribeNext:^(id x) {
     NSLog(@"%@", x);
 } error:^(NSError *error) {
     NSLog(@"An error occurred: %@", error);
 }];
</code></pre>

<p>then方法会等到completed事件发出后调用，然后订阅由block参数返回的信号。这有效地将控制从一个信号传递给下一个信号。运行程序，获取访问，然后在输入框输入，会在控制台看到以下输出：</p>

<pre><code>2014-01-04 08:16:11.444 TwitterInstant[39118:a0b] m
2014-01-04 08:16:12.276 TwitterInstant[39118:a0b] ma
2014-01-04 08:16:12.413 TwitterInstant[39118:a0b] mag
2014-01-04 08:16:12.548 TwitterInstant[39118:a0b] magi
2014-01-04 08:16:12.628 TwitterInstant[39118:a0b] magic
2014-01-04 08:16:13.172 TwitterInstant[39118:a0b] magic!
</code></pre>

<p>下一步，我们添加一个filter操作到管道，以移除无效的搜索字符串。在这个实例中，是要求输入长度不小于3：</p>

<pre><code>[[[[self requestAccessToTwitterSignal]
 then:^RACSignal *{
     @strongify(self)
     return self.searchText.rac_textSignal;
 }]
 filter:^BOOL(NSString *text) {
     @strongify(self)
     return [self isValidSearchText:text];
 }]
 subscribeNext:^(id x) {
     NSLog(@"%@", x);
 } error:^(NSError *error) {
     NSLog(@"An error occurred: %@", error);
 }];
</code></pre>

<p>运行后的输出是</p>

<pre><code>2014-01-04 08:16:12.548 TwitterInstant[39118:a0b] magi
2014-01-04 08:16:12.628 TwitterInstant[39118:a0b] magic
2014-01-04 08:16:13.172 TwitterInstant[39118:a0b] magic!
</code></pre>

<p>当前管道如下图所示：</p>

<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/01/PipelineWithThen.png" alt="image" /></p>

<p>现在我们有一个发送搜索文本的信号了，是时候用它来搜索Twitter了。接下来才是正题。</p>

<h2>搜索Twitter</h2>

<p>Social Framework是访问Twitter搜索API的一个选择。但是Social Framework不是响应式的。接下来是封装所需要的API方法到信号中。现在，我们需要挂起这个过程。</p>

<p>在RWSearchFormViewController.m中，添加以下方法：</p>

<pre><code>- (SLRequest *)requestforTwitterSearchWithText:(NSString *)text
{
    NSURL *url = [NSURL URLWithString:@"https://api.twitter.com/1.1/search/tweets.json"];
    NSDictionary *params = @{@"q": text};

    SLRequest *request = [SLRequest requestForServiceType:SLServiceTypeTwitter
                                            requestMethod:SLRequestMethodGET
                                                      URL:url
                                               parameters:params];
    return request;
}
</code></pre>

<p>这个方法通过<a href="https://dev.twitter.com/docs/api/1.1">v1.1 REST API</a>创建了一个搜索Twitter的请求。关于这个API，可以在<a href="https://dev.twitter.com/docs/api/1.1/get/search/tweets">Twitter API docs</a>中查看更多信息。</p>

<p>接下来创建一个基于请求的信号。在同一文件中，添加以下代码：</p>

<pre><code>- (RACSignal *)signalForSearchWithText:(NSString *)text {
    // 定义错误
    NSError *noAccountError = [NSError errorWithDomain:RWTwitterInstantDomain code:RWTwitterInstantErrorNoTwitterAccounts userInfo:nil];

    NSError *invalidResponseError = [NSError errorWithDomain:RWTwitterInstantDomain code:RWTwitterInstantErrorInvalidResponse userInfo:nil];

    // 创建信号block
    @weakify(self)
    return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
        @strongify(self)

        // 创建请求
        SLRequest *request = [self requestforTwitterSearchWithText:text];

        // 提供Twitter账户
        NSArray *twitterAccounts = [self.accountStore accountsWithAccountType:self.twitterAccountType];
        if (twitterAccounts.count == 0) {
            [subscriber sendError:noAccountError];
        } else {
            [request setAccount:[twitterAccounts lastObject]];

            // 执行请求
            [request performRequestWithHandler:^(NSData *responseData, NSHTTPURLResponse *urlResponse, NSError *error) {
                if (urlResponse.statusCode == 200) {
                    // 成功，解析响应
                    NSDictionary *timelineData = [NSJSONSerialization JSONObjectWithData:responseData options:NSJSONReadingAllowFragments error:nil];
                    [subscriber sendNext:timelineData];
                    [subscriber sendCompleted];
                } else {
                    // 失败，发送一个错误
                    [subscriber sendError:invalidResponseError];
                }
            }];
        }

        return nil;
    }];
}
</code></pre>

<p>现在我们来使用这个新信号。</p>

<p>在第一部分中我们学习了如何使用flattenMap来将每个next事件映射到一个新的被订阅的信号。这里我们再次使用它们。在viewDidLoad的最后用如下代码更新：</p>

<pre><code>[[[[[self requestAccessToTwitterSignal]
 then:^RACSignal *{
     @strongify(self)
     return self.searchText.rac_textSignal;
 }]
 filter:^BOOL(NSString *text) {
     @strongify(self)
     return [self isValidSearchText:text];
 }]
 flattenMap:^RACStream *(NSString *text ) {
     @strongify(self)
     return [self signalForSearchWithText:text];
 }]
 subscribeNext:^(id x) {
     NSLog(@"%@", x);
 } error:^(NSError *error) {
     NSLog(@"An error occurred: %@", error);
 }];
</code></pre>

<p>运行并在搜索框中输入一些文本。一旦文本字符串长度大于3后，我们可以在控制台查看搜索的结果。如下显示了返回数据的一个片断：</p>

<pre><code>2014-01-05 07:42:27.697 TwitterInstant[40308:5403] {
    "search_metadata" =     {
        "completed_in" = "0.019";
        count = 15;
        "max_id" = 419735546840117248;
        "max_id_str" = 419735546840117248;
        "next_results" = "?max_id=419734921599787007&amp;q=asd&amp;include_entities=1";
        query = asd;
        "refresh_url" = "?since_id=419735546840117248&amp;q=asd&amp;include_entities=1";
        "since_id" = 0;
        "since_id_str" = 0;
    };
    statuses =     (
                {
            contributors = "&lt;null&gt;";
            coordinates = "&lt;null&gt;";
            "created_at" = "Sun Jan 05 07:42:07 +0000 2014";
            entities =             {
                hashtags = ...
</code></pre>

<p>signalForSearchText:方法同样发出了一个error事件，其由subscribeNext:error:块来处理。</p>

<h2>线程</h2>

<p>现在一定想把返回的JSON数据显示到UI上了吧，不过，在此之前我们还有一件事情需要处理。要了解这是什么，我们还需要探索一下。</p>

<p>在下图的subscribeNext:error:中打个断点：</p>

<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/01/BreakpointLocation.png" alt="image" /></p>

<p>重新运行程序，如果需要则再次输入Twitter账号密码，在搜索框中输入一些文本。当程序运行到断点位置时可以看到类似于下图的场景：</p>

<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/01/BreakpointResult.png" alt="image" /></p>

<p>注意，从左侧的线程列表中我们可以看到debugger到的代码并没有运行在主线程，即线程Thread 1。记住，更新UI的操作一定得在主线程中操作；因此，如果要在UI上显示tweet列表，则必须切换线程。</p>

<p>这说明了ReactiveCocoa框架的一个重要点。上面显示的操作是在信号初始发出事件时的那个线程执行。尝试在管道的其它步骤添加断点，我们会很惊奇的发现它们会运行在多个不同的线程上。</p>

<p>因此，我们应该如何来更新UI呢？当然ReactiveCocoa也为我们解决了这个问题。我们只需要在flattenMap:后面添加deliverOn:操作：</p>

<pre><code>[[[[[[self requestAccessToTwitterSignal]
 then:^RACSignal *{
     @strongify(self)
     return self.searchText.rac_textSignal;
 }]
 filter:^BOOL(NSString *text) {
     @strongify(self)
     return [self isValidSearchText:text];
 }] flattenMap:^RACStream *(NSString *text) {
     @strongify(self)
     return [self signalForSearchWithText:text];
 }]
 deliverOn:[RACScheduler mainThreadScheduler]]
 subscribeNext:^(id x) {
     NSLog(@"%@", x);
 } error:^(NSError *error) {
     NSLog(@"An error occurred: %@", error);
 }];
</code></pre>

<p>现在重新运行，此时我们可以看到subscribeNext:error:是运行在主线程了。</p>

<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/01/BreakpointNowOnUIThread.png" alt="image" /></p>

<p>这样我们就可以安全地更新我们的UI了。</p>

<h2>更新UI</h2>

<p>打开RWSearchResultsViewController.h文件，我们可以看到displayTweets:方法，这个方法会让右侧的ViewController来渲染tweet数组。实现非常简单，它只是一个标准UITableView数据源。displayTweets:只需要一个包含RWTweet实例的数组作为参数。我们同样发现RWTweet实例是作为初始工程的一部分提供的。</p>

<p>在subscibeNext:error:步骤中获取到的数据现在是一个NSDictionary，它是在signalForSearchWithText:解析JSON数据时构造的。那么，我们如何处理这个字典的内容呢？</p>

<p>如果看一看<a href="https://dev.twitter.com/docs/api/1.1/get/search/tweets">Twitter API documentation</a>，我们可以发现一个示例响应。在NSDictionary反映了这种结构，所以我们需要找到一个键名为statues的字典，其值为一个tweets数组。具体如何解析我们就不在此说明。这里给个更好的实现方式。</p>

<p>我们现在讲的是ReactiveCocoa及函数式编程。当我们使用函数式API时，数据从一种格式转换到另一种格式会变得更优雅。我们可以使用<a href="https://github.com/ColinEberhardt/LinqToObjectiveC">LinqToObjectiveC</a>来执行这个任务。</p>

<p>我们需要使用Cocoapods来导入LinqToObjectiveC。在配置文件中加入以下代码：</p>

<pre><code>pod 'LinqToObjectiveC', '2.0.0'
</code></pre>

<p>关闭工程，在终端执行pod update命令，完成后在我们的Pods工程中就可以看到LinqToObjectiveC了。</p>

<p>打开RWSearchFormViewController.m并导入以下文件：</p>

<pre><code>#import "RWTweet.h"
#import "NSArray+LinqExtensions.h"
</code></pre>

<p>NSArray+LinqExtensions.h头文件来自于LinqToObjectiveC，并为NSArray添加了许多方法以允许我们使用一个流畅的API来转换、排序、分组及过滤数组的数据。</p>

<p>现在我们使用这些API来更新当前管道操作，在viewDidLoad代码中做如下修改：</p>

<pre><code>[[[[[[self requestAccessToTwitterSignal]
     then:^RACSignal *{
         @strongify(self)
         return self.searchText.rac_textSignal;
     }]
    filter:^BOOL(NSString *text) {
        @strongify(self)
        return [self isValidSearchText:text];
    }]
   flattenMap:^RACStream *(NSString *text) {
       @strongify(self)
       return [self signalForSearchWithText:text];
   }]
  deliverOn:[RACScheduler mainThreadScheduler]]
 subscribeNext:^(NSDictionary *jsonSearchResult) {
     NSArray *statuses = jsonSearchResult[@"statuses"];
     NSArray *tweets = [statuses linq_select:^id(id tweet) {
         return [RWTweet tweetWithStatus:tweet];
     }];
     [self.resultsViewController displayTweets:tweets];
 } error:^(NSError *error) {
     NSLog(@"An error occurred: %@", error);
 }];
</code></pre>

<p>如上所看到的，subscribeNext:块首先获取twetts的NSArray对象。linq_select方法通过执行应用于每个数组元素的block来转换NSDictionary字典的数组，并生成一个RWTweet实例的数组。</p>

<p>一旦转换完成，tweets将结果发送给ViewController。</p>

<p>运行程序后我们可以看到以下UI：</p>

<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/01/FinallyWeSeeTweets.png" alt="image" /></p>

<h2>异步加载图片</h2>

<p>在上图中，我们可以看到每行数据前面有一片空白，这是用来显示用户头像的。RWTweet类已经有一个profileImageUrl属性，它是一个图片的URL地址。为了让UITableTable滑动得更平滑，我们需要让获取指定URL的图片的操作不运行在主线程中。这可以使用GCD或者是NSOperationQueue。不过，ReactiveCocoa同样为我们提供了解决方案。</p>

<p>打开RWSearchResultsViewController.m，添加以下代码：</p>

<pre><code>-(RACSignal *)signalForLoadingImage:(NSString *)imageUrl {

    RACScheduler *scheduler = [RACScheduler
                               schedulerWithPriority:RACSchedulerPriorityBackground];

    return [[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
        NSData *data = [NSData dataWithContentsOfURL:[NSURL URLWithString:imageUrl]];
        UIImage *image = [UIImage imageWithData:data];
        [subscriber sendNext:image];
        [subscriber sendCompleted];
        return nil;
    }] subscribeOn:scheduler];

}
</code></pre>

<p>现在我们应该熟悉这种模式了。以上的方法首先获取一个后台scheduler作为信号执行的线程，而不是主线程。接下来，创建一个下载图片数据的信号并在其有订阅者时创建一个UIImage。最后我们调用subscribeOn:，以确保信号在给定的scheduler上执行。</p>

<p>现在，我们可以更新tableView:cellForRowAtIndex:，在return之前添加以下代码：</p>

<pre><code>cell.twitterAvatarView.image = nil;

[[[self signalForLoadingImage:tweet.profileImageUrl]
  deliverOn:[RACScheduler mainThreadScheduler]]
  subscribeNext:^(UIImage *image) {
   cell.twitterAvatarView.image = image;
  }];
</code></pre>

<p>上面的代码首先重新设置图片，因为重用的单元格可能包含之前的数据。然后创建一个请求信号去获取数据，在deliverOn:中我们将后面的next事件运行在主线程，这样subscribeNext:可以安全运行。</p>

<p>运行后得到如下结果：</p>

<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2014/01/AvatarsAtAlast.png" alt="image" /></p>

<h2>节流</h2>

<p>你可能已经发现每次我们输入一个新的字符时，搜索操作都会立即执行。如果我们快速输入，可能会导致程序在一秒钟内执行了多次搜索操作。这当然是不好的，因为：</p>

<ol>
<li>我们多次调用了Twitter搜索API，同时扔掉了大部分结果。</li>
<li>我们不断更新结果会分散用户的注意力。</li>
</ol>


<p>一个更好的方案是如果搜索文本在一个较短时间内没有改变时我们再去执行搜索操作，如500毫秒。ReactiveCocoa框架让这一任务变得相当简单。</p>

<p>打开RWSearchFormViewController.m并更新管道操作：</p>

<pre><code>[[[[[[[self requestAccessToTwitterSignal]
      then:^RACSignal *{
          @strongify(self)
          return self.searchText.rac_textSignal;
      }]
     filter:^BOOL(NSString *text) {
         @strongify(self)
         return [self isValidSearchText:text];
     }]
    throttle:0.5]
   flattenMap:^RACStream *(NSString *text) {
       @strongify(self)
       return [self signalForSearchWithText:text];
   }]
  deliverOn:[RACScheduler mainThreadScheduler]]
 subscribeNext:^(NSDictionary *jsonSearchResult) {
     NSArray *statuses = jsonSearchResult[@"statuses"];
     NSArray *tweets = [statuses linq_select:^id(id tweet) {
         return [RWTweet tweetWithStatus:tweet];
     }];
     [self.resultsViewController displayTweets:tweets];
 } error:^(NSError *error) {
     NSLog(@"An error occurred: %@", error);
 }];
</code></pre>

<p>throttle操作只有在两次next事件间隔指定的时间时才会发送第二个next事件。相当简单吧。运行程序看看效果吧。</p>

<h2>小结</h2>

<p>在庆祝胜利前，看看程序最终的管道是值得的。</p>

<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2014/01/CompletePipeline.png" alt="image" /></p>

<p>这是一个相当复杂的数据流，但可以作为一个响应管道简洁地表示出来。看起来不错吧。如果使用非响应式技术，你会觉得这会有多复杂呢？在这样一个程序中，数据流的流动又会是多难以理解呢？听起来很麻烦吧。但有了ReactiveCocoa，我们不必再考虑这些了。现在我们知道ReactiveCocoa有多棒了吧。</p>

<p>最后，ReactiveCocoa让使用Model View ViewModel(MVVM)设计模式变成可能。如果有兴趣研究MVVM，可以去网上搜索相关的文章。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ReactiveCocoa指南一：信号]]></title>
    <link href="http://southpeak.github.io/blog/2014/08/02/reactivecocoazhi-nan-%5B%3F%5D-:xin-hao/"/>
    <updated>2014-08-02T23:03:12+08:00</updated>
    <id>http://southpeak.github.io/blog/2014/08/02/reactivecocoazhi-nan-[?]-:xin-hao</id>
    <content type="html"><![CDATA[<p>原文由Colin Eberhardt发表于raywenderlich，<a href="http://www.raywenderlich.com/62699/reactivecocoa-tutorial-pt1">ReactiveCocoa Tutorial – The Definitive Introduction: Part &frac12;</a></p>

<p>在编写iOS代码时，我们的大部分代码都是在响应一些事件：按钮点击、接收网络消息、属性变化等等。但是这些事件在代码中的表现形式却不一样：如target-action、代理方法、KVO、回调或其它。ReactiveCocoa的目的就是定义一个统一的事件处理接口，这样它们可以非常简单地进行链接、过滤和组合。</p>

<p>ReactiveCocoa结合了一些编程模式：</p>

<ol>
<li>函数式编程：利用高阶函数，即将函数作为其它函数的参数。</li>
<li>响应式编程：关注于数据流及变化的传播。</li>
</ol>


<p>基于以上两点，ReactiveCocoa被当成是函数响应编程(Functional Reactive Programming, FRP)框架。我们将在下面以实例来看看ReactiveCocoa的实用价值。</p>

<h2>Reactive Playground实例</h2>

<p>虽然这是一篇指南性质的文章，但我们将以一个简单的实例来介绍ReactiveCocoa。可以在<a href="http://cdn2.raywenderlich.com/wp-content/uploads/2014/01/ReactivePlayground-Starter.zip">这里</a>下载源代码，然后编译并运行以确保程序可以运行。</p>

<p>ReactivePlayground是个非常简单的应用，只有一个用户登录界面。只需要提供正确的用户名及密码，就可以显示一幅可爱的小猫的图片。如下图所示：</p>

<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/01/ReactivePlaygroundStarter.jpg" alt="image" /></p>

<p>这个工程很简单，所以花几分钟来熟悉一下这个工程。打开RWViewController.m，可以快速查找一下如何设置Sign in按钮可用的代码，以及显示/隐藏signInFailure Label的规则。在简单的实现中，我们能快速定位这些问题，但如果实现很复杂，那可能需要花一些时间来分析代码。</p>

<p>现在，我们有了ReactiveCocoa，它能让代码变得更清晰。来看看它是怎么做到的吧。</p>

<h2>添加ReactiveCocoa框架</h2>

<p>添加ReactiveCocoa框架到我们工程的最简单的方法是使用Cocoapods。我们先关闭ReactivePlayground工程。Cocoapods会创建一个Xcode workspace，它会替代我们的原始工程文件。</p>

<p>首先创建一个名为Podfile的空文件，打开并添加如下信息：</p>

<pre><code>platform :ios, '6.0'
inhibit_all_warnings!
xcodeproj 'RWReactivePlayground'

target :RWReactivePlayground do

    pod 'ReactiveCocoa', '~&gt; 2.3.1'

end

post_install do |installer|
installer.project.targets.each do |target|
puts "#{target.name}"
end
end
</code></pre>

<p>配置完成后保存文件，打开终端并转到工程所在目录，然后输入以下命令：</p>

<pre><code>pod install
</code></pre>

<p>然后终端会有如下输出</p>

<pre><code>Analyzing dependencies
Downloading dependencies
Installing ReactiveCocoa (2.3.1)
Generating Pods project
Pods-RWReactivePlayground-ReactiveCocoa
Pods-RWReactivePlayground
Integrating client project

[!] From now on use `RWReactivePlayground.xcworkspace`.
</code></pre>

<p>这表示已经下载了ReactiveCocoa框架，同时Cocoapods创建了一个Xcode workspace，同时将框架整合到了我们的工程中。打开新生成的workspace文件(RWReactivePlayground.xcworkspace)，将看到如下的工程结构：</p>

<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/01/AddedCocoaPods.png" alt="image" /></p>

<p>我们看到有一个命名为ReactivePlayground的工程，这实际上是我们的初始工程，它依赖于Pods工程。做完这一切后，我们就可以开始玩了，哈哈。</p>

<h2>Time to Play</h2>

<p>如上所述，ReactiveCocoa提供了一个标准的接口来处理不同的事件流。在ReactiveCocoa中，这些被统一称为信号，由RACSignal类表示。</p>

<p>打开程序的初始视图控制器RWViewController.m文件，在文件头部导入以下头文件：</p>

<pre><code>#import &lt;ReactiveCocoa/ReactiveCocoa.h&gt;
</code></pre>

<p>我们暂时先不替换原来的代码，先看看如何使用ReactiveCocoa。在viewDidLoad方法中加入如下代码：</p>

<pre><code>[self.usernameTextField.rac_textSignal subscribeNext:^(id x) {

    NSLog(@"%@", x);
}];
</code></pre>

<p>运行程序并在用户名输入框中键入&#8221;reactive cocoa&#8221;，我们可以看到控制台会有如下输出：</p>

<pre><code>2014-07-31 15:32:30.890 RWReactivePlayground[9191:60b] r
2014-07-31 15:32:32.007 RWReactivePlayground[9191:60b] re
2014-07-31 15:32:32.289 RWReactivePlayground[9191:60b] rea
2014-07-31 15:32:33.990 RWReactivePlayground[9191:60b] reac
2014-07-31 15:32:34.889 RWReactivePlayground[9191:60b] react
2014-07-31 15:32:35.557 RWReactivePlayground[9191:60b] reacti
2014-07-31 15:32:36.022 RWReactivePlayground[9191:60b] reactiv
2014-07-31 15:32:36.505 RWReactivePlayground[9191:60b] reactive
2014-07-31 15:32:42.328 RWReactivePlayground[9191:60b] reactive 
2014-07-31 15:32:47.223 RWReactivePlayground[9191:60b] reactive c
2014-07-31 15:32:47.794 RWReactivePlayground[9191:60b] reactive co
2014-07-31 15:32:48.191 RWReactivePlayground[9191:60b] reactive coc
2014-07-31 15:32:48.657 RWReactivePlayground[9191:60b] reactive coco
2014-07-31 15:32:49.141 RWReactivePlayground[9191:60b] reactive cocoa
</code></pre>

<p>我们可以看到，每次在text field中输入时，都会执行block中的代码。没有target-action，没有代理，只有信号与block。是不是很棒？</p>

<p>ReactiveCocoa信号发送一个事件流到它们的订阅者中。我们需要知道三种类型的事件：next, error和completed。一个信号可能由于error事件或completed事件而终止，在此之前它会发送很多个next事件。在这一部分中，我们将重点关注next事件。在学习关于error和completed事件前，请仔细阅读第二部分。</p>

<p>RACSignal有许多方法用于订阅这些不同的事件类型。每个方法会有一个或多个block，每个block执行不同的逻辑处理。在上面这个例子中，我们看到subscribeNext:方法提供了一个响应next事件的block。</p>

<p>ReactiveCocoa框架通过类别来为大部分标准UIKit控件添加信号，以便这些控件可以添加其相应事件的订阅，如上面的UITextField包含了rac_textSignal属性。</p>

<p>理论讲得差不多了，我们继续吧！！！</p>

<p>ReactiveCocoa有大量的操作右用于处理事件流。例如，如果我们只对长度大于3的用户名感兴趣，则我们可以使用filter操作。在viewDidLoad中更新我们的代码如下：</p>

<pre><code>[[self.usernameTextField.rac_textSignal filter:^BOOL(id value) {
    NSString *text = value;
    return text.length &gt; 3;
}] subscribeNext:^(id x) {
    NSLog(@"%@", x);
}];
</code></pre>

<p>运行并在用户名输入框中输入&#8221;reactive cocoa&#8221;，我们可以看到控制台会有如下输出：</p>

<pre><code>2014-07-31 15:52:13.558 RWReactivePlayground[9249:60b] reac
2014-07-31 15:52:15.960 RWReactivePlayground[9249:60b] react
2014-07-31 15:52:16.589 RWReactivePlayground[9249:60b] reacti
2014-07-31 15:52:17.158 RWReactivePlayground[9249:60b] reactiv
2014-07-31 15:52:17.807 RWReactivePlayground[9249:60b] reactive
2014-07-31 15:52:18.674 RWReactivePlayground[9249:60b] reactive 
2014-07-31 15:52:19.176 RWReactivePlayground[9249:60b] reactive c
2014-07-31 15:52:19.710 RWReactivePlayground[9249:60b] reactive co
2014-07-31 15:52:20.057 RWReactivePlayground[9249:60b] reactive coc
2014-07-31 15:52:20.530 RWReactivePlayground[9249:60b] reactive coco
2014-07-31 15:52:20.978 RWReactivePlayground[9249:60b] reactive cocoa
</code></pre>

<p>可以看到当长度小于3时，并不执行后续的操作。通过这种方式，我们创建了一个简单的管道。这就是响应式编程的实质，我们将我们程序的功能表示为数据流的形式。我们可以将上述调用表示为以下图例：</p>

<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/01/FilterPipeline.png" alt="image" /></p>

<p>从上图中我们可以看到rac_textSignal是事件的初始源头。通过filter的数据流只有在其长度大于3时，才会被传递到下一处理流程中。管道的最后一步是subscribeNext:，在这个block中，我们记录日志。</p>

<p>在这里需要注意的是filter操作的输出仍然是一个RACSignal对象。我们可以将上面这段管道处理拆分成如下代码：</p>

<pre><code>RACSignal *usernameSourceSignal = self.usernameTextField.rac_textSignal;

RACSignal *filteredUsername = [usernameSourceSignal filter:^BOOL(id value) {

    NSString *text = value;
    return text.length &gt; 3;
}];

[filteredUsername subscribeNext:^(id x) {

    NSLog(@"%@", x);
}];
</code></pre>

<p>因为RACSignal对象的每个操作都返回一个RACSignal对象，所以我们不需要使用变量就可以构建一个管道。</p>

<h2>事件是什么</h2>

<p>目前为止，我们已经描述了3种不同的事件类型，但还没有深入这些事件的结构。有趣的是，事件可以包含任何东西。为了证明这一点，我们在上面的管道中加入另一个操作。更新我们的代码：</p>

<pre><code>[[[self.usernameTextField.rac_textSignal map:^id(NSString *text) {
    return @(text.length);
 }]
 filter:^BOOL(NSNumber *length) {
     return [length intValue] &gt; 3;
 }]
 subscribeNext:^(id x) {
     NSLog(@"%@", x);
 }];
</code></pre>

<p>编译并运行，我们会发现控制台输出如下信息：</p>

<pre><code>2014-07-31 16:13:47.652 RWReactivePlayground[9321:60b] 4
2014-07-31 16:13:47.819 RWReactivePlayground[9321:60b] 5
2014-07-31 16:13:47.985 RWReactivePlayground[9321:60b] 6
2014-07-31 16:13:48.134 RWReactivePlayground[9321:60b] 7
2014-07-31 16:13:48.284 RWReactivePlayground[9321:60b] 8
2014-07-31 16:13:48.417 RWReactivePlayground[9321:60b] 9
2014-07-31 16:13:48.583 RWReactivePlayground[9321:60b] 10
2014-07-31 16:13:48.734 RWReactivePlayground[9321:60b] 11
2014-07-31 16:13:48.883 RWReactivePlayground[9321:60b] 12
</code></pre>

<p>新添加的map操作使用提供的block来转换事件数据。对于收到的每一个next事件，都会运行给定的block，并将返回值作为next事件发送。在上面的代码中，map操作获取一个NSString输入，并将其映射为一个NSNumber对象，并返回。下图演示了这个管道处理：</p>

<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2014/01/FilterAndMapPipeline.png" alt="image" /></p>

<p>我们可以看到，map操作后的每一步接收的都是一个NSNumber对象。我们可以使用map操作来转换我们想要的数据，只需要它是一个对象。</p>

<p>OK，是时候修改ReactivePlayground应用的代码了。</p>

<h2>创建有效的状态信号</h2>

<p>我们要做的第一件事就是创建一对信号来校验用户名与密码的输入是否有效。添加如下代码到RWViewController.m的viewDidLoad中。</p>

<pre><code>RACSignal *validUsernameSignal = [self.usernameTextField.rac_textSignal map:^id(NSString *text) {
    return @([self isValidUsername:text]);
}];

RACSignal *validPasswordSignal = [self.passwordTextField.rac_textSignal map:^id(NSString *text) {
    return @([self isValidPassword:text]);
}];
</code></pre>

<p>我们使用将map操作应用于文本输入框的rac_textSignal，输出是一个NSNumber对象。接着将转换这些信号，以便其可以为文本输入框提供一个合适的背影颜色。我们可以订阅这个信号并使用其结果来更新文本输入框的颜色。可以如下操作：</p>

<pre><code>[[validPasswordSignal map:^id(NSNumber *passwordValid) {
    return [passwordValid boolValue] ? [UIColor clearColor] : [UIColor yellowColor];
}] subscribeNext:^(UIColor *color) {
    self.passwordTextField.backgroundColor = color;
}];
</code></pre>

<p>从概念上讲，我们将信号的输出值赋值给文本输入框的backgroundColor属性。但是这段代码有点糟糕。我们可以以另外一种方式来做相同的处理。这得益于ReactiveCocoa定义的一些宏。如下代码所示：</p>

<pre><code>RAC(self.passwordTextField, backgroundColor) = [validPasswordSignal map:^id(NSNumber *passwordValid) {
    return [passwordValid boolValue] ? [UIColor clearColor] : [UIColor yellowColor];
}];

RAC(self.usernameTextField, backgroundColor) = [validUsernameSignal map:^id(NSNumber *passwordValid) {
    return [passwordValid boolValue] ? [UIColor clearColor] : [UIColor yellowColor];
}];
</code></pre>

<p>RAC宏我们将信号的输入值指派给对象的属性。它带有两个参数，第一个参数是对象，第二个参数是对象的属性名。每次信号发送下一个事件时，其输出值都会指派给给定的属性。这是个非常优雅的解决方案，对吧？</p>

<p>在运行前，我们先找到updateUIState方法，并注释掉下面两行代码：</p>

<pre><code>self.usernameTextField.backgroundColor = self.usernameIsValid ? [UIColor clearColor] : [UIColor yellowColor];
self.passwordTextField.backgroundColor = self.passwordIsValid ? [UIColor clearColor] : [UIColor yellowColor];
</code></pre>

<p>运行程序，我们可以看到当输入无效时文本输入框是高亮的，有效时则清除高亮。在这里，我们可以看到两条带有文本信号的简单的管道，都是将它们映射到标明是否有效的布尔对象，然后再映射到UIColor对象。如下图所示：</p>

<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/01/TextFieldValidPipeline.png" alt="image" /></p>

<h2>组合信号</h2>

<p>在当前的程序中，Sign in按钮只有在两个输入框都有效时才可点击。是时候处理这个响应了。</p>

<p>当前代码有两个信号来标识用户名和密码是否有效：validUsernameSignal和validPasswordSignal。我们的任务是要组合这两个信号，来确定按钮是否可用。</p>

<p>在viewDidLoad中添加下面的代码</p>

<pre><code>RACSignal *signUpActiveSignal = [RACSignal combineLatest:@[validUsernameSignal, validPasswordSignal]
                                                  reduce:^id(NSNumber *usernameValid, NSNumber *passwordValid){

                                                      return @([usernameValid boolValue] &amp;&amp; [passwordValid boolValue]);
                                                  }];
</code></pre>

<p>上面的代码使用了combineLatest:reduce:方法来组合validUsernameSignal与validPasswordSignal最后输出的值，并生成一个新的信号。每次两个源信号中的一个输出新值时，reduce块都会被执行，而返回的值会作为组合信号的下一个值。</p>

<p><em>注意：RACSignal组合方法可以组合任何数量的信号，而reduce块的参数会对应每一个信号。</em></p>

<p>现在我们已以有了一个合适的信号，接着在viewDidLoad结尾中添加以下代码，这将信号连接到按钮的enabled属性。</p>

<pre><code>[signUpActiveSignal subscribeNext:^(NSNumber *signupActive) {

    self.signInButton.enabled = [signupActive boolValue];
}];
</code></pre>

<p>同样，在运行前移除以下代码：</p>

<pre><code>@property (nonatomic) BOOL passwordIsValid;
@property (nonatomic) BOOL usernameIsValid;
</code></pre>

<p>同时移除viewDidLoad中以下代码：</p>

<pre><code>[self.usernameTextField addTarget:self action:@selector(usernameTextFieldChanged) forControlEvents:UIControlEventEditingChanged];
[self.passwordTextField addTarget:self action:@selector(passwordTextFieldChanged) forControlEvents:UIControlEventEditingChanged];
</code></pre>

<p>当然我们还需要移除updateUIState, usernameTextFieldChanged和passwordTextFieldChanged方法及相关的调用。瞧，我们已经删除了不少代码了。感谢自己吧！</p>

<p>运行，并检查Sign in按钮。如同之前一下，如果用户名和密码都有效，则按钮是可用的。</p>

<p>更新后程序的逻辑如下图所示：</p>

<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/01/CombinePipeline.png" alt="image" /></p>

<p>上面我们已经用ReactiveCocoa实现了一些非常棒的功能，它包含了两个重要的概念：</p>

<ol>
<li>Spliting: 信号可以有多个订阅者，且作为资源服务于序列化管道的多个步骤。</li>
<li>Combining: 多个信号可以组合起来创建新的信号。</li>
</ol>


<p>在上面的程序中，这些改变让程序不再需要私有属性，来标明两个输入域的有效状态。这是使用响应式编程的关键区别&mdash;我们不需要使用实例变量来跟踪短暂的状态。</p>

<h2>响应Sign-in</h2>

<p>程序目前使用了响应式管道来管理输入框与按钮的状态。按钮的点击操作仍然使用target-action。所以，这是我们下一步的目标。</p>

<p>Sign-in按钮的Touch Up Inside事件通过storyboard action连接到RWViewController.m的signInButtonTouched方法中。我们现在使用响应式方法来替换它，所以第一步我们需要解除当前storyboard action的连接。这个自己处理吧。</p>

<p>为了处理按钮事件，我们需要使用ReactiveCocoa添加到UIKit的另一个方法：rac_signalForControlEvents。我们在viewDidLoad结尾加入以下代码：</p>

<pre><code>[[self.signInButton rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(id x) {

    NSLog(@"Button clicked");
}];
</code></pre>

<p>上面的代码从按钮的UIControlEventTouchUpInside事件中创建一个信号，并添加订阅以在每次事件发生时添加日志。</p>

<p>运行程序，当按钮可点时点击按钮，会记录以下日志：</p>

<pre><code>2014-07-31 17:45:43.660 RWReactivePlayground[9617:60b] Button clicked
2014-07-31 17:45:44.493 RWReactivePlayground[9617:60b] Button clicked
2014-07-31 17:45:44.660 RWReactivePlayground[9617:60b] Button clicked
2014-07-31 17:45:44.810 RWReactivePlayground[9617:60b] Button clicked
2014-07-31 17:45:44.944 RWReactivePlayground[9617:60b] Button clicked
</code></pre>

<p>现在点击事件有一个信号了，接下来将信号与登录处理连接起来。打开RWDummySignInService.h文件，我们会看到下面的接口：</p>

<pre><code>typedef void (^RWSignInResponse)(BOOL);

@interface RWDummySignInService : NSObject

- (void)signInWithUsername:(NSString *)username password:(NSString *)password complete:(RWSignInResponse)completeBlock;

@end
</code></pre>

<p>这个方法带有一个用户名、密码和一个完成block。block会在登录成功或失败时调用。我们可以在subscribeNext:块中直接调用这个方法，但为什么不呢？因为这是一个异步操作，小心了。</p>

<h2>创建信号</h2>

<p>幸运的是，将一个已存在的异步API表示为一个信号相当简单。我们来看看。</p>

<p>首先，从RWViewController.m移除当前的signInButtonTouched:方法。我们通过响应式编程来取代它。</p>

<p>在RWViewController.m中添加以下方法：</p>

<pre><code>- (RACSignal *)signInSignal
{
    return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {

        [self.signInService signInWithUsername:self.usernameTextField.text
                                      password:self.passwordTextField.text
                                      complete:^(BOOL success) {
                                          [subscriber sendNext:@(success)];
                                          [subscriber sendCompleted];
                                      }];
        return nil;
    }];
}
</code></pre>

<p>上面的代码创建了一个使用当前用户名与密码登录的信号。现在我们来分解一下这个方法。createSignal:方法用于创建一个信号。描述信号的block是一个信号参数，当信号有一个订阅者时，block中的代码会被执行。</p>

<p>block传递一个实现RACSubscriber协议的subscriber(订阅者)，这个订阅者包含我们调用的用于发送事件的方法；我们也可以发送多个next事件，这些事件由一个error事件或complete事件结束。在上面这种情况下，它发送一个next事件来表示登录是否成功，后续是一个complete事件。</p>

<p>这个block的返回类型是一个RACDisposable对象，它允许我们执行一些清理任务，这些操作可能发生在订阅取消或丢弃时。上面这个这个信号没有任何清理需求，所以返回nil。</p>

<p>可以看到，我们就这样在信号中封装了一个异步API。现在，我们可以使用这个新的信号了，更新viewDidLoad中我们的代码吧：</p>

<pre><code>[[[self.signInButton rac_signalForControlEvents:UIControlEventTouchUpInside] map:^id(id value) {
    return [self signInButton];
}] subscribeNext:^(id x) {
    NSLog(@"Sign in result: %@", x);
}];
</code></pre>

<p>上面的代码使用map方法将按钮点击信号转换为登录信号。订阅者简单输出了结果。</p>

<p>运行程序，点击按钮，可以看到以下输出：</p>

<pre><code>2014-07-31 18:29:27.134 RWReactivePlayground[9749:60b] Sign in result: &lt;UIButton: 0x13651ed40; frame = (192 201; 76 30); opaque = NO; autoresize = RM+BM; layer = &lt;CALayer: 0x178224c00&gt;&gt;
</code></pre>

<p>可以看到subscribeNext:块传递了一个正确的信号，但结果不是登录信号。我们用图来展示这个管道操作：</p>

<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/01/SignalOfSignals.png" alt="image" /></p>

<p>当点击按钮时rac_signalForControlEvents发出了一个next事件。map这一步创建并返回一个登录信号，意味着接下来的管理接收一个RACSignal。这是我们在subscribeNext:中观察到的对象。</p>

<p>上面这个方案有时候称为信号的信号(signal of signals)，换句话说，就是一个外部信号包含一个内部信号。可以在输出信号的subscribeNext:块中订阅内部信号。但这会引起嵌套的麻烦。幸运的是，这是个普遍的问题，而ReactiveCocoa已经提供了解决方案。</p>

<h2>Signal of Signals</h2>

<p>这个问题有解决方案是直观的，只需要使用flattenMap来替换map。如下代码所示：</p>

<pre><code>[[[self.signInButton rac_signalForControlEvents:UIControlEventTouchUpInside] flattenMap:^RACStream *(id value) {
    return [self signInSignal];
}] subscribeNext:^(id x) {
    NSLog(@"Sign in result: %@", x);
}];
</code></pre>

<p>这将按钮点击事件映射到一个登录信号，但同时通过将事件从内部信号发送到外部信号，使这个过程变得扁平化。再次运行程序，我们将得到以下的输出</p>

<pre><code>2014-07-31 18:46:19.535 RWReactivePlayground[9785:60b] Sign in result: 1
</code></pre>

<p>这回对了。</p>

<p>现在管道处理得到了我们想要的结果，最后我们在subscriptNext中添加登录处理逻辑。使用以下代码：</p>

<pre><code>[[[self.signInButton rac_signalForControlEvents:UIControlEventTouchUpInside] flattenMap:^RACStream *(id value) {
    return [self signInSignal];
}] subscribeNext:^(NSNumber *signedIn) {

    BOOL success = [signedIn boolValue];
    self.signInFailureText.hidden = success;
    if (success)
    {
        [self performSegueWithIdentifier:@"signInSuccess" sender:self];
    }
}];
</code></pre>

<p>运行程序，我们就可以得到下面的结果了：</p>

<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/01/ReactivePlaygroundStarter.jpg" alt="image" /></p>

<p>不知道你是否注意到一个细节问题。当点击登录进行验证时，我们应该置灰登录按钮。这样可以阻止用户在验证的过程中再次去点击登录。那么这个逻辑添加在哪呢？改变按钮的可用状态不是个转换、过滤或其它的信号。这就是下一步要讲的。</p>

<h2>添加附加操作(side-effects)</h2>

<p>使用下面的代码替换当前管道：</p>

<pre><code>[[[[self.signInButton rac_signalForControlEvents:UIControlEventTouchUpInside]
 doNext:^(id x) {
     self.signInButton.enabled = NO;
     self.signInFailureText.hidden = YES;
 }]
 flattenMap:^RACStream *(id value) {
     return [self signInSignal];
 }]
 subscribeNext:^(NSNumber *signedIn) {
     self.signInButton.enabled = YES;
     BOOL success = [signedIn boolValue];
     self.signInFailureText.hidden = success;
     if (success) {
         [self performSegueWithIdentifier:@"signInSuccess" sender:self];
     }
 }];
</code></pre>

<p>我们可以看到在按钮点击事件后添加了doNext:步骤。注意doNext:并不返回一个值，因为它是附加操作。它完成时不改变事件。下图展示了这个过程：</p>

<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/01/SideEffects.png" alt="image" /></p>

<p>运行程序看看效果。如何？</p>

<p>注意：在执行异步方法时禁用按钮是个普遍的问题，ReactiveCocoa同样解决了这个问题。<strong>RACCommand</strong>类封装了这个概念，同时有一个enabled信号以允许我们将一个按钮的enabled属性连接到信号。可以试试。</p>

<h2>小结</h2>

<p>ReactiveCocoa的核心是信号，它是一个事件流。使用ReactiveCocoa时，对于同一个问题，可能会有多种不同的方法来解决。ReactiveCocoa的目的就是为了简化我们的代码并更容易理解。如果使用一个清晰的管道，我们可以很容易理解问题的处理过程。在下一部分，我们将会讨论错误事件的处理及完成事件的处理。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Core Bluetooth框架之三：最佳实践]]></title>
    <link href="http://southpeak.github.io/blog/2014/08/01/core-bluetoothkuang-jia-zhi-san-:zui-jia-shi-jian/"/>
    <updated>2014-08-01T23:03:22+08:00</updated>
    <id>http://southpeak.github.io/blog/2014/08/01/core-bluetoothkuang-jia-zhi-san-:zui-jia-shi-jian</id>
    <content type="html"><![CDATA[<p>在iOS设备中使用BLE时，无论是将其作为central端还是peripheral端，其在通信时都会使用设备自身的无线电来发送信号。考虑到其它形式的无线通信也需要使用无线电，因此开发程序时应该尽量少使用无线电。另外，这对于设备电池的寿命及程序的性能也有所帮助。以此为出发点，我们将介绍一些使用BLE时的最佳实践，希望有所帮助。</p>

<h2>与Peripheral设备交互的最佳实践</h2>

<p>Core Bluetooth框架让程序的大部分Central端交互变得透明。即程序能够控制且有责任实现大部分Central端的操作，如设备搜索及连接，解析并与远程peripheral数据交互。下面我们将介绍一些Central端的最佳实践。</p>

<h4>留意无线电的使用及电量消耗</h4>

<h5>只有当需要时才扫描设备</h5>

<p>当调用CBCentralManager类的scanForPeripheralsWithServices:options:方法来搜索正在广告服务的peripheral设备时，central设备使用无线电来监听广告的设备，直到我们显示停止它。除非需要搜索更多的设备，否则当发现想要连接的设备时就停止扫描操作。此时可以调用CBCentralManager实例的stopScan方法来处理。</p>

<h5>只有当需要时才指定CBCentralManagerScanOptionAllowDuplicatesKey选项</h5>

<p>远程peripheral设备可能每秒发送多个广告包来声明它们的存在。当我们使用scanForPeripheralsWithServices:options:方法扫描设备时，该方法的默认行为是将多个搜索到的广告peripheral事件归集为一个事件&mdash;即central管理器在只有在每次发现新的peripheral时都调用其代理对象的centralManager:didDiscoverPeripheral:advertisementData:RSSI:，而不管它收到多少个广告包。central管理器在已发现的peripheral改变广告的数据时也会调用这个代理方法。</p>

<p>如果想要改变默认行为，可以指定CBCentralManagerScanOptionAllowDuplicatesKey作为扫描选项。此时，central管理器会在每次收到peripheral端的广告包时都触发一个事件。在某些情况下关闭默认行为很有用处，但记住指定CBCentralManagerScanOptionAllowDuplicatesKey扫描选项不利于电池的寿命及程序性能。因此，只在需要的时候使用这个选项以完成特定的任务。</p>

<h5>解析peripheral数据</h5>

<p>一个peripheral设备可能有多个服务和特性，但在我们的应用中，可能只对其中一些感兴趣。搜索peripheral设备的所有服务和特性可能不利于电池的寿命及程序性能。因此，我们只去搜索那些与我们的的应用相关的服务和特性。</p>

<p>例如，假设我们正在连接一个有很多可用服务的peripheral设备，但是我们的程序只需要访问其中两个。我们可以只查找这两个服务，即在调用CBPeripheral对象的discoverServices:方法时传入感兴趣服务的UUID的数组即可。如下代码所示：</p>

<pre><code>[peripheral discoverServices:@[firstServiceUUID, secondServiceUUID]];
</code></pre>

<p>在搜索到这两个感兴趣的服务后，我们可以用类似的方法去搜索我们感兴趣的服务中的特性。此时调用CBPeripheral实例的discoverCharacteristics:forService:方法并传入特性UUID的数组。</p>

<h5>订阅经常改变的特性值</h5>

<p>我们可以通过两种方式获取特性的值：</p>

<ol>
<li>在我们每次需要值时调用readValueForCharacteristic:方法来显示的轮循特性的值</li>
<li>调用setNotifyValue:forCharacteristic:方法来订阅特性的值，这样当值改变时我们可以收到来自于peripheral的通知。</li>
</ol>


<p>通常最好是去订阅特性的值，特别是特性值经常改变时。</p>

<h5>当获取到所有需要的数据时断开到设备的连接</h5>

<p>当连接不再需要时，我们可以断开连接，以减少无线电的使用。在下面两种情况下，我们应该断开连接：</p>

<ol>
<li>所有订阅的特性值已经停止发送通知(我们可以访问特性的isNotifying属性来查看属性值是否正在被通知)</li>
<li>我们已以获取来来自peripheral设备的全部值。</li>
</ol>


<p>两种情况下，取自我们有的所有订阅并断开连接。我们通过调用setNotifyValue:forCharacteristic:方法并设置第一个参数为NO来取消订阅。同时调用CBCentralManager实例的cancelPeripheralConnection:方法来断开连接。注意这个cancelPeripheralConnection:方法是非阻塞的，如果我们尝试断开连接的peripheral设备仍然挂起，则CBPeripheral实例的命令可能完成执行，也可能没有。因为其它程序可能也连接着那个peripheral设备。取消一个本地连接不能保证底层物理链接会立即断开。</p>

<h4>重新链接Peripheral</h4>

<p>使用Core Bluetooth框架，有三种方式来重新连接peripheral设备：</p>

<ol>
<li>使用retrievePeripheralsWithIdentifiers:方法获取已知peripheral设备的列表，这些设备是我们已经搜索并连接过的设备。如果我们查找的peripheral在列表中，则尝试重新连接。</li>
<li>使用retrieveConnectedPeripheralsWithServices:方法获取当前连接到系统的peripheral设备的列表。如果我们查找的peripheral设备在列表中，则连接它。</li>
<li>使用scanForPeripheralsWithServices:options:方法扫描并搜索peripheral设备。如果找到，则连接它。</li>
</ol>


<p>根据使用的场景，我们可能不希望每次重新连接设备时，都去扫描并搜索设备。相反，我们可能想首先使用其它方式来重新连接。如下图所示，一个可能的重新连接操作流是按照上面列出来的方式去重新连接：</p>

<h5>获取已知peripheral设备的列表</h5>

<p>我们第一次发现一个peripheral设备时，系统生成一个标识符(NSUUID对象)来标识peripheral设备。我们可以存储这些设备，后续我们可以使用CBCentralManager实例的retrievePeripheralsWithIdentifiers:方法来重新连接这个peripheral设备。</p>

<p>当我们启动程序时，调用retrievePeripheralsWithIdentifiers:方法，传递一个我们先前搜索并连接过的peripheral设备的标识符的数组，如下代码所示：</p>

<pre><code>knownPeripherals = [myCentralManager retrievePeripheralsWithIdentifiers:savedIdentifiers];
</code></pre>

<p>central管理器尝试在这个列表中匹配我们提供的标识符，并返回一个CBPeripheral对象的数组。如果没找到，则返回的数组为空，那么我们需要尝试另外两种方法。如果返回的数组不为空，则让用户选择连接哪一个peripheral设备。当用户选择后，调用CBCentralManager实例的connectPeripheral:options:方法来尝试连接。如果peripheral设备仍然可以连接，则central管理器调用代理对象的centralManager:didConnectPeripheral:方法，且成功连接上peripheral设备。</p>

<h5>获取已连接peripheral设备的列表</h5>

<p>另一种重新连接peripheral设备的方法是查看我们正在查找的设备是否正由系统连接着(如被其它程序连接着)。我们可以调用CBCentralManager实例的retrieveConnectedPeripheralsWithServices:方法，它返回一个表示当前系统正在连接着的peripheral设备的CBPeripheral对象的数组。</p>

<p>因为可以有多于一个peripheral设备正在连接着系统，我们可以传递一个CBUUID对象的数组来获取只包含指定UUID所标识服务的设备。如果当前系统没有连接任何peripheral设备，则返回数组为空，我们应该尝试其它两种方法。如果返回数组不为空，则让用户选择连接哪个设备。</p>

<p>假设用户找到并选择了需要的peripheral设备，则调用CBCentralManager实例的connectPeripheral:options:方法来连接它(即使系统已经连接了它，我们的程序仍然需要连接它以开始解析并交互数据)。当连接建立后，central管理器调用代理对象的centralManager:didConnectPeripheral:方法，然后成功连接peripheral设备。</p>

<h2>将本地设备设置为peripheral设备的最佳实践</h2>

<h4>广告注意事项</h4>

<p>在设置本地设备作为peripheral端时，广告peripheral数据是非常重要的一部分。我们下面将介绍一下如何以适当的方式来实现这一功能。</p>

<p>我们广告peripheral数据时，是将其放在一个字典中传递给CBPeripheralManager对象的startAdvertising:方法中。当创建一个广告字典时，需要知道我们可以广告什么及能广告多少数据。</p>

<p>虽然广告数据包通常可以放置关于peripheral设备的多种信息，但建议只放置设备的本地名及我们需要广告的服务的UUID。即，当创建广告字典时，可能只指定下面两个键：CBAdvertisementDataLocalNameKey和CBAdvertisementDataServiceUUIDsKey。如果指定其它键，则会收到一个错误。</p>

<p>同样，广告数据时也限定了可以使用多少空间。当程序在前台时，可广告的数据对于上述两个key值的任意组合来说，初始值不能超过28个字节。如果这个空间用完了，在扫描响应时可以有额外的10个字节的空间，但这只能用于本地名。任何超出的数据都会被放到一个指定的“溢出”区域；它们只能被显示扫描它们的iOS设备发现。当程序在后台时，本地名不能被广告，且所有的服务UUID都被放在溢出区域。</p>

<p>为了符合这此限制条件，我们需要将广告的服务UUID限制在主要服务的标识上。</p>

<p>另外，因为广告peripheral数据使用本地设备的无线电，所以只在需要其它设备连接的时候广告数据。一旦连接后，这些设备可以直接解析并交互数据，而不需要任何广告包。因此，为了减少无线电的使用、提高程序的性能及节省电量，当不再需要任何试图进行BLE交易时可以停止广告。为了停止本地peripheral，可以调用CBPeripheralManager对象的stopAdvertising方法，如下所示：</p>

<pre><code>[myPeripheralManager stopAdvertising];
</code></pre>

<p>通常，只有用户才知道什么时候广告数据。例如，当我们知道没有任何BLE设备在附近时，在我们的设备上广告服务没有任何意义。因为我们的程序通常不知道是否有其它设备在附近，所以提供一个界面让用户来决定什么时候广告数据。</p>

<h4>配置特性</h4>

<p>当创建一个可变的特性时，我们设置它的属性、值和权限。这些设置决定了如何连接central访问及交互特性值。虽然我们可能基于程序的需求来配置特性的属性和权限，但当执行下面两种任务时，我们还是有章可循的</p>

<ol>
<li>允许连接的central订阅属性</li>
<li>保护敏感特性值，不让其被未配对的central访问</li>
</ol>


<p>对于这两种情况，首先我们配置特性以支持通知。通常建议central去订阅那些经常改变的特性值。当我们创建一个可变特性时，可以通过使用CBCharacteristicPropertyNotify常量来设置特性属性以支持订阅，如下所示：</p>

<pre><code>myCharacteristic = [[CBMutableCharacteristic alloc] initWithType:myCharacteristicUUID properties:CBCharacteristicPropertyRead | CBCharacteristicPropertyNotify value:nil permissions:CBAttributePermissionsReadable];
</code></pre>

<p>在这个例子中，特性值是可读的，且可以被连接的central端订阅。</p>

<p>其它，要求配对的连接才能访问敏感数据。根据场景的不同，我们可能想要提供一个服务，这个服务有一个或多个需要加密值的特性。例如，假设我们想要提供一个社交媒体配置文件服务。这个服务有一些特性，它们的值表示成员的配置信息，如姓名、电子邮件地址。更可能的是，我们只允许受信任的设备来获取成员的电子邮件地址。</p>

<p>我们可以设置合适的特性属性及权限来确保只有受信任的设备可以访问敏感的特性值。继续上面的例子，为了只允许受信任的设备来获取成员的邮箱地址，可以如下设置合适的特性属性与权限：</p>

<pre><code>emailCharacteristic = [[CBMutableCharacteristic alloc] initWithType:emailCharacteristicUUID properties:CBCharacteristicPropertyRead | CBCharacteristicPropertyNotifyEncryptionRequired value:nil permissions:CBAttributePermissionsReadEncryptionRequired];
</code></pre>

<p>在这个例子中，特性配置为只有受信任的设备才可以读取或订阅它的值。当一个连接的central尝试读取或订阅特性值时，Core Bluetooth尝试配对本地peripheral和central端来创建安全连接。</p>

<p>例如，如果central和peripheral都是iOS设备，两端都接收一个提示显示对方想要配对。central设备上的提示包含包含一个确认码，这个确认码必须在peripheral设备提示框的输入域中输入，来完成配对操作。</p>

<p>在配对成功后，peripheral认为配对的central是一个受信任的设备且允许central访问它的加密特性值。</p>

<h2>小结</h2>

<p>在使用BLE时，基于以下几点，程序开发过程中我们合理地使用蓝牙</p>

<ol>
<li>程序性能</li>
<li>电池电量消耗</li>
<li>与其它通信方法争抢无线电资源</li>
</ol>


<p>通常我们只在需要时才使用BLE，尽量减少设备扫描搜索操作。</p>

<h2>参考</h2>

<p><a href="https://developer.apple.com/library/ios/documentation/NetworkingInternetWeb/Conceptual/CoreBluetooth_concepts/AboutCoreBluetooth/Introduction.html">Core Bluetooth Programming Guide</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Core Bluetooth框架之二：后台处理]]></title>
    <link href="http://southpeak.github.io/blog/2014/07/31/core-bluetoothkuang-jia-zhi-er-:hou-tai-chu-li/"/>
    <updated>2014-07-31T23:28:24+08:00</updated>
    <id>http://southpeak.github.io/blog/2014/07/31/core-bluetoothkuang-jia-zhi-er-:hou-tai-chu-li</id>
    <content type="html"><![CDATA[<p>在开发BLE相关应用时，由于应用在后台时会有诸多资源限制，需要考虑应用的后台处理问题。默认情况下，当程序位于后台或挂起时，大多数普通的Core Bluetooth任务都无法使用，不管是Central端还是Peripheral端。但我们可以声明我们的应用支持Core Bluetooth后台执行模式，以允许程序从挂起状态中被唤醒以处理蓝牙相关的事件。</p>

<p>然而，即使我们的应用支持两端的Core Bluetooth后台执行模式，它也不能一直运行。在某些情况下，系统可能会关闭我们的应用来释放内存，以为当前前台的应用提供更多的内存空间。在iOS7及后续版本中，Core Bluetooth支持保存Central及Peripheral管理器对象的状态信息，并在程序启动时恢复这些信息。我们可以使用这个特性来支持与蓝牙设备相关的长时间任务。</p>

<p>下面我们将详细讨论下这些问题。</p>

<h2>只支持前台操作(Foreground-Only)的应用</h2>

<p>大多数应用在进入到后台后都会在短时间内进入挂起状态，除非我们请求执行一些特定的后台任务。当处理挂起状态时，我们的应用无法继续执行蓝牙相关的任务。</p>

<p>在Central端，Foreground-Only应用在进入后台或挂起时，无法继续扫描并发现下在广告的Peripheral设备。而在Peripheral端，无法广告自身，同时Central端对其的任何访问操作都会返回一个错误。</p>

<p>Foreground-Only应用挂起时，所有蓝牙相关的事件都会被系统放入一个队列，当应用进入前台后，系统会将这些事件发送给我们的应用。也就是说，当某些事件发生时，Core Bluetooth提供了一种方法来提示用户。用户可以使用这些提示来决定是否将应用放到前台。在《Core Bluetooth框架之一：Central与Peripheral》中我们介绍了connectPeripheral:options:方法，在调用这个方法时，我们可以设备options参数来设置这些提示：</p>

<ol>
<li>CBConnectPeripheralOptionNotifyOnConnectionKey：当应用挂起时，如果有一个连接成功时，如果我们想要系统为指定的peripheral显示一个提示时，就使用这个key值。</li>
<li>CBConnectPeripheralOptionNotifyOnDisconnectionKey：当应用挂起时，如果连接断开时，如果我们想要系统为指定的peripheral显示一个断开连接的提示时，就使用这个key值。</li>
<li>CBConnectPeripheralOptionNotifyOnNotificationKey：当应用挂起时，使用该key值表示只要接收到给定peripheral端的通知就显示一个提示。</li>
</ol>


<h2>Core Bluetooth后台执行模式</h2>

<p>我们可以在Info.plist文件中设置Core Bluetooth后台执行模式，以让应用支持在后台执行一些蓝牙相关的任务。当应用声明了这一功能时，系统会将应用唤醒以允许它处理蓝牙相关的任务。这个特性对于与那种定时发送数据的BLE交互的应用非常有用。</p>

<p>有两种Core Bluetooth后台执行模式，一种用于实现Central端操作，一种用于实现Peripheral端操作。如果我们的应用同时实现了这两端的功能，则需要声明同时支持两种模式。我们需要在Info.plist文件添加UIBackgroundModes键，同时添加以下两个值或其中之一：</p>

<ol>
<li>bluetooth-central(App communicates using CoreBluetooth)</li>
<li>bluetooth-peripheral(App shares data using CoreBluetooth)</li>
</ol>


<h4>bluetooth-central模式</h4>

<p>如果设置了bluetooth-central值，则我们的应用在后台时，仍然可以查找并连接到Peripheral设备，以及查找相应数据。另外，系统会在CBCentralManagerDelegate或CBPeripheralDelegate代理方法被调用时唤醒我们的应用，允许应用处理事件，如建立连接或断开连接等等。</p>

<p>虽然应用在后台时，我们可以执行很多蓝牙相关任务，但需要记住应用在前后台扫描Peripheral设备时还是不一样的。当我们的应用在后台扫描Peripheral设备时，</p>

<ol>
<li>CBCentralManagerScanOptionAllowDuplicatesKey扫描选项会被忽略，同一个Peripheral端的多个发现事件会被聚合成一个发现事件。</li>
<li>如果扫描Peripheral设备的多个应用都在后台，则Central设备扫描广告数据的时间间隔会增加。结果是发现一个广告的Peripheral设备可能需要很长时间。</li>
</ol>


<p>这些处理在iOS设备中最小化无线电的使用及改善电池的使用寿命非常有用。</p>

<h4>bluetooth-peripheral模式</h4>

<p>如果设置了bluetooth-peripheral值，则我们的应用在后台时，应用会被唤醒以处理来自于连接的Central端的读、写及订阅请求，Core Bluetooth还允许我们在后台进行广告。与Central端类似，也需要注意前后台的操作区别。特别是在广告时，有以下几点区别：</p>

<ol>
<li>CBAdvertisementDataLocalNameKey广告key值会被忽略，Peripheral端的本地名不会被广告</li>
<li>CBAdvertisementDataServiceUUIDsKey键的所有服务的UUID都被放在一个&#8221;overflow&#8221;区域中，它们只能被那些显示要扫描它们的网络设备发现。</li>
<li>如果多个应用在后台广告，则Peripheral设备发送广告包的时间间隔会变长。</li>
</ol>


<h2>在后台执行长(Long-Term)任务</h2>

<p>虽然建议尽快完成后台任务，但有些应该仍然需要使用Core Bluetooth来执行一个长任务。这时就涉及到状态的保存与恢复操作。</p>

<h4>状态保存与恢复</h4>

<p>因为状态保存与恢复是内置于Core Bluetooth的，我们的程序可以选择这个特性，让系统保存Central和Peripheral管理器的状态并继续执行一些蓝牙相关的任务，即使此时程序不再运行。当这些任务中的一个完成时，系统会在后台重启程序，程序可以恢复先前的状态以处理事件。Core Bluetooth支持Central端、Peripheral端的状态保存与恢复，也可以同时支持两者。</p>

<p>在Central端，系统会在关闭程序释放内存时保存Central管理器对象的状态(如果有多个Central管理器，我们可以选择系统跟踪哪个管理器)。对于给定的CBCentralManager对象，系统会跟踪如下信息：</p>

<ol>
<li>Central管理器扫描的服务</li>
<li>Central管理器尝试或已经连接的Peripheral</li>
<li>Central管理器订阅的特性</li>
</ol>


<p>在Peripheral端，对于给定的CBPeripheralManager对象，系统会跟踪以下信息：</p>

<ol>
<li>Peripheral管理器广告的数据</li>
<li>Peripheral管理器发布到设备数据库的服务和特性</li>
<li>订阅Peripheral管理器的特性值的Central端</li>
</ol>


<p>当系统将程序重启到后台后，我们可以重新重新初始化我们程序的Central和Peripheral管理器并恢复状态。我们接下来将详细介绍一下如何使用状态保存与恢复。</p>

<h4>添加状态保存和恢复支持</h4>

<p>Core Bluetooth中的状态保存与恢复是可选的特性，需要程序的支持才能工作。我们可以按照以下步骤来添加这一特性的支持：</p>

<ol>
<li>(必要步骤)当分配及初始化Central或Peripheral管理器对象时，选择性加入状态保存与恢复。</li>
<li>(必要步骤)在系统重启程序时，重新初始化Central或Peripheral管理器对象</li>
<li>(必要步骤)实现适当的恢复代理方法</li>
<li>(可选步骤)更新Central或Peripheral管理器初始化过程</li>
</ol>


<h5>选择性加入状态保存与恢复</h5>

<p>为了选择性加入状态保存与恢复特性，在分配及初始化Central或Peripheral管理器时提供一个一个唯一恢复标识。<strong>恢复标识</strong>是一个字条串，用来让Core Bluetooth和程序标识Central或Peripheral管理器。字符串的值只在自己的代码中有意义，但这个字符串告诉Core Bluetooth我们需要保存对象的状态。Core Bluetooth只保存那些有恢复标识的对象。</p>

<p>例如，在实现Central端时，为了选择性加入状态保存与恢复特性，在初始化CBCentralManager对象时，可以指定初始化选项CBCentralManagerOptionRestoreIdentifierKey，并提供一个恢复标识，如下代码所示：</p>

<pre><code>centralManager = [[CBCentralManager alloc] initWithDelegate:self queue:nil options:@{CBCentralManagerOptionRestoreIdentifierKey: @"restoreIdentifier"}];
</code></pre>

<p>实现Peripheral端时的操作也类似，只不过我们使用选项CBPeripheralManagerOptionRestoreIdentifierKey键。</p>

<p>因为程序可以有多个Central或Peripheral管理器，所以需要确保恢复标识是唯一的，这样系统可以区分这些管理器对象。</p>

<h5>重新初始化Central或Peripheral管理器对象</h5>

<p>当系统重启程序到后台后，我们所需要做的第一件事就是使用恢复标识来重新初始化这些对象。如果我们的应用只有一个Central管理器或Peripheral管理器，且管理器在程序的整个生命周期都存在，则后续我们便不需要再做更多的处理。但如果我们有多个管理器，或者管理器不是存在于程序的整个生命周期，则系统重启应用时，我们需要知道重新初始化哪一个管理器。我们可以通过在程序代理对象的application:didFinishLaunchingWithOptions:方法中，使用合适的启动选项键来访问管理器对象的列表(这个列表是程序关闭是系统为程序保存的)。</p>

<p>下面代码展示了程序重新启动时，我们获取所有Central管理器对象的恢复标识:</p>

<pre><code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
    // Override point for customization after application launch.

    NSArray *centralManagerIdentifiers = launchOptions[UIApplicationLaunchOptionsBluetoothCentralsKey];

    // TODO: ...

    return YES;
}
</code></pre>

<p>有了这个恢复标识的列表后，我们就可以重新初始化我们所需要的管理器对象了。</p>

<h5>实现适当的恢复代理方法</h5>

<p>重新初始化Central或Peripheral管理器对象后，我们通过使用蓝牙系统的状态同步这些对象的状态来恢复它们。此时，我们需要实现一些恢复代理方法。对于Central管理器，我们实现centralManager:willRestoreState:代理方法；对于Peripheral管理器管理器，我们实现peripheralManager:willRestoreState:代理方法。</p>

<p><em>对于选择性加入保存与恢复特性的应用来说，这些方法是程序启动到后台以完成一些蓝牙相关任务所调用的第一个方法。而对于非选择性加入特性的应用来说，会首先调用centralManagerDidUpdateState:和peripheralManagerDidUpdateState:代理方法。</em></p>

<p>在上述两个代理方法中，最后一个参数是一个字典，包含程序关闭时保存的关于管理器的信息。如下代码所示，我们可以使用CBCentralManagerRestoredStatePeripheralsKey键来获取Central管理器已连接的或尝试连接的所有Peripheral设备的列表:</p>

<pre><code>- (void)centralManager:(CBCentralManager *)central willRestoreState:(NSDictionary *)state
{
    NSArray *peripherals = state[CBCentralManagerRestoredStatePeripheralsKey];

    // TODO: ...
}
</code></pre>

<p>获取到这个列表后，我们便可以根据需要来做处理。</p>

<h5>更新初始化过程</h5>

<p>在实现了前面的三个步骤后，我们可能想更新我们的管理器的初始化过程。虽然这一步是可选的，但如果要确认任务是否运行正常时，非常有用。例如，我们的程序可能在解析所连接的Peripheral设备的数据的过程中被关闭。当程序使用这个Peripheral设备作恢复操作时，无法知道数据处理到哪了。我们需要确保程序从数据操作停止的位置继续开始操作。</p>

<p>又如下面的代码展示了在centralManagerDidUpdateState:代理方法中初始化程序操作时，我们可以找出是否成功发现了被恢复的Peripheral设备的指定服务：</p>

<pre><code>NSUInteger serviceUUIDIndex = [peripheral.services indexOfObjectPassingTest:^BOOL(CBService *obj, NSUInteger index, BOOL *stop) {        return [obj.UUID isEqual:myServiceUUIDString];    }];
    if (serviceUUIDIndex == NSNotFound) {       [peripheral discoverServices:@[myServiceUUIDString]];       ...
}    
</code></pre>

<p>如上例所述，如果系统在程序完成搜索服务时关闭了应用，则通过调用discoverServices:方法在关闭的那个点开始解析恢复的Peripheral数据。如果程序成功搜索到服务，我们可以确认是否搜索到正确的特性。通过更新初始化过程，我们可以确保在正确的时间调用正确的方法。</p>

<h2>小结</h2>

<p>虽然我们可能需要声明应用支持Core Bluetooth后台执行模式，以完成特定的任务，但总是应该慎重考虑执行后台操作。因为执行太多的蓝牙相关任务需要使用iOS设备的内置无线电，而无线电的使用会影响到电池的寿命，所以尽量减少在后台执行的任务。任何会被蓝牙相关任务唤醒的应用应该尽快处理任务并在完成时重新挂起。</p>

<p>下面是一些基础的准则：</p>

<ol>
<li>应用应该是基于会话的，并提供接口以允许用户决定什么时候开始及结束蓝牙相关事件的分发。</li>
<li>一旦被唤醒，一个应用大概有10s的时间来完成任务。理想情况下，应用应该尽快完成任务并重新挂起。系统可以对执行时间太长的后台任务进行限流甚至杀死。</li>
<li>应用被唤醒时，不应该执行一些无关紧要的操作。</li>
</ol>


<h2>参考</h2>

<p><a href="https://developer.apple.com/library/ios/documentation/NetworkingInternetWeb/Conceptual/CoreBluetooth_concepts/AboutCoreBluetooth/Introduction.html">Core Bluetooth Programming Guide</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Core Bluetooth框架之一：Central与Peripheral]]></title>
    <link href="http://southpeak.github.io/blog/2014/07/29/core-bluetoothkuang-jia-zhi-%5B%3F%5D-:centralyu-peripheral/"/>
    <updated>2014-07-29T21:52:48+08:00</updated>
    <id>http://southpeak.github.io/blog/2014/07/29/core-bluetoothkuang-jia-zhi-[?]-:centralyu-peripheral</id>
    <content type="html"><![CDATA[<p>iOS和Mac应用使用Core Bluetooth framework来与BLE(低功耗蓝牙)设备通信。我们的程序可以发现、搜索并与低功耗外围(Peripheral)蓝牙设备通信，如心跳监听器、数字温控器、甚至是其它iOS设备。这个框架抽象了支持蓝牙4.0标准低功耗设备的基本操作，隐藏了4.0标准的底层实现细节，让我们可以方便的使用BLE设备。</p>

<h2>蓝牙通信中的角色</h2>

<p>在BLE通信中，主要有两个角色：Central和Peripheral。类似于传统的客户端-服务端架构，一个Peripheral端是提供数据的一方(相当于服务端)；而Central是使用Peripheral端提供的数据完成特定任务的一方(相当于客户端)。下图以心跳监听器为例展示了这样一个架构：</p>

<p><img src="https://developer.apple.com/library/ios/documentation/NetworkingInternetWeb/Conceptual/CoreBluetooth_concepts/Art/CBDevices1_2x.png" alt="image" /></p>

<p>Peripheral端以广告包的形式来广播一些数据。一个广告包(advertising packet)是一小束相关数据，可能包含Peripheral提供的有用的信息，如Peripheral名或主要功能。在BLE下，广告是Peripheral设备表现的主要形式。</p>

<p>Central端可以扫描并监听其感兴趣的任何广播信息的Peripheral设备。</p>

<p>数据的广播及接收需要以一定的数据结构来表示。而服务就是这样一种数据结构。Peripheral端可能包含一个或多个服务或提供关于连接信号强度的有用信息。一个服务是一个设备的数据的集合及数据相关的操作。</p>

<p>而服务本身又是由特性或所包含的服务组成的。一个特性提供了关于服务的更详细的信息。下图展示了心率监听器中的各种数据结构</p>

<p><img src="https://developer.apple.com/library/ios/documentation/NetworkingInternetWeb/Conceptual/CoreBluetooth_concepts/Art/CBPeripheralData_Example_2x.png" alt="image" /></p>

<p>在一个Central端与Peripheral端成功建立连接后，Central可以发现Peripheral端提供的完整的服务及特性的集合。一个Central也可以读写Peripheral端的服务特性的值。我们将会在下面详细介绍。</p>

<h2>Central、Peripherals及Peripheral数据的表示</h2>

<p>当我们使用本地Central与Peripheral端交互时，我们会在BLE通信的Central端执行操作。除非我们设置了一个本地Peripheral设备，否则大部分蓝牙交互都是在Central端进行的。(下文也会讲Peripheral端的基本操作)</p>

<p>在Central端，本地Central设备由CBCentralManager对象表示。这个对象用于管理发现与连接Peripheral设备(CBPeripheral对象)的操作，包括扫描、查找和连接。下图本地Central端与peripheral对象</p>

<p><img src="https://developer.apple.com/library/ios/documentation/NetworkingInternetWeb/Conceptual/CoreBluetooth_concepts/Art/CBObjects_CentralSide_2x.png" alt="image" /></p>

<p>当与peripheral设备交互时，我们主要是在处理它的服务及特性。在Core Bluetooth框架中，服务是一个CBService对象，特性是一个CBCharacteristic对象，下图演示了Central端的服务与特性的基本结构：</p>

<p><img src="https://developer.apple.com/library/ios/documentation/NetworkingInternetWeb/Conceptual/CoreBluetooth_concepts/Art/TreeOfServicesAndCharacteristics_Remote_2x.png" alt="image" /></p>

<p>苹果在OS X 10.9和iOS 6版本后，提供了BLE外设(Peripheral)功能，可以将设备作为Peripheral来处理。在Peripheral端，本地Peripheral设备表示为一个CBPeripheralManager对象。这些对象用于管理将服务及特性发布到本地Peripheral设备数据库，并广告这些服务给Central设备。Peripheral管理器也用于响应来自Central端的读写请求。如下图展示了一个Peripheral端角色：</p>

<p><img src="https://developer.apple.com/library/ios/documentation/NetworkingInternetWeb/Conceptual/CoreBluetooth_concepts/Art/CBObjects_PeripheralSide_2x.png" alt="image" /></p>

<p>当在本地Peripheral设备上设置数据时，我们实际上处理的是服务与特性的可变版本。在Core Bluetooth框架中，本地Peripheral服务由CBMutableService对象表示，而特性由CBMutableCharacteristic对象表示，下图展示了本地Peripheral端服务与特性的基本结构：</p>

<p><img src="https://developer.apple.com/library/ios/documentation/NetworkingInternetWeb/Conceptual/CoreBluetooth_concepts/Art/TreeOfServicesAndCharacteristics_Local_2x.png" alt="image" /></p>

<h2>Peripheral(Server)端操作</h2>

<p>一个Peripheral端操作主要有以下步骤：</p>

<ol>
<li>启动一个Peripheral管理对象</li>
<li>在本地Peripheral中设置服务及特性</li>
<li>将服务及特性发布给设备的本地数据库</li>
<li>广告我们的服务</li>
<li>针对连接的Central端的读写请求作出响应</li>
<li>发送更新的特性值到订阅Central端</li>
</ol>


<p>我们将在下面结合代码对每一步分别进行讲解</p>

<h4>启动一个Peripheral管理器</h4>

<p>要在本地设备上实现一个Peripheral端，我们需要分配并初始化一个Peripheral管理器实例，如下代码所示</p>

<pre><code>// 创建一个Peripheral管理器
// 我们将当前类作为peripheralManager，因此必须实现CBPeripheralManagerDelegate
// 第二个参数如果指定为nil，则默认使用主队列
peripheralManager = [[CBPeripheralManager alloc] initWithDelegate:self queue:nil];
</code></pre>

<p>创建Peripheral管理器后，Peripheral管理器会调用代理对象的peripheralManagerDidUpdateState:方法。我们需要实现这个方法来确保本地设备支持BLE。</p>

<pre><code>- (void)peripheralManagerDidUpdateState:(CBPeripheralManager *)peripheral
{
    NSLog(@"Peripheral Manager Did Update State");
    switch (peripheral.state) {
        case CBPeripheralManagerStatePoweredOn:
            NSLog(@"CBPeripheralManagerStatePoweredOn");
            break;

        case CBPeripheralManagerStatePoweredOff:
            NSLog(@"CBPeripheralManagerStatePoweredOff");
            break;

        case CBPeripheralManagerStateUnsupported:
            NSLog(@"CBPeripheralManagerStateUnsupported");
            break;

        default:
            break;
    }
}
</code></pre>

<h4>设置服务及特性</h4>

<p>一个本地Peripheral数据库以类似树的结构来组织服务及特性。所以，在设置服务及特性时，我们将其组织成树结构。</p>

<p>一个Peripheral的服务和特性通过128位的蓝牙指定的UUID来标识，该标识是一个CBUUID对象。虽然SIG组织没的预先定义所有的服务与特性的UUID，但是SIG已经定义并发布了一些通过的UUID，这些UUID被简化成16位以方便使用。例如，SIG定义了一个16位的UUID作为心跳服务的标识(180D)。</p>

<p>CBUUID类提供了方法，以从字符串中生成一个CBUUID对象。当字条串使用的是预定义的16位UUID时，Core Bluetooth使用它时会预先自动补全成128位的标识。</p>

<pre><code>CBUUID *heartRateServiceUUID = [CBUUID UUIDWithString:@"180D"];
</code></pre>

<p>当然我们也可以自己生成一个128位的UUID来标识我们的服务与特性。在命令行中使用uuidgen命令会生成一个128位的UUID字符串，然后我们可以使用它来生成一个CBUUID对象。</p>

<p>生成UUID对象后，我们就可以用这个对象来创建我们的服务及特性，然后再将它们组织成树状结构。</p>

<p>创建特性的代码如下所示</p>

<pre><code>CBUUID *characteristicUUID1 = [CBUUID UUIDWithString:@"C22D1ECA-0F78-463B-8C21-688A517D7D2B"];
CBUUID *characteristicUUID2 = [CBUUID UUIDWithString:@"632FB3C9-2078-419B-83AA-DBC64B5B685A"];

CBMutableCharacteristic *character1 = [[CBMutableCharacteristic alloc] initWithType:characteristicUUID1 properties:CBCharacteristicPropertyRead value:nil permissions:CBAttributePermissionsReadable];

CBMutableCharacteristic *character2 = [[CBMutableCharacteristic alloc] initWithType:characteristicUUID2 properties:CBCharacteristicPropertyNotify value:nil permissions:CBAttributePermissionsWriteable];
</code></pre>

<p>我们需要设置特性的属性、值及权限。属性及权限值确定了属性值是可读的还是可写的，及连接的Central端是否可以订阅特性的值。另外，如果我们指定了特性的值，则这个值会被缓存且其属性及权限被设置成可读的。如果我们要让特性的值是可写的，或者期望属性所属的服务的生命周期里这个值可以被修改，则必须指定值为nil。</p>

<p>创建的特性之后，我们便可以创建一个与特性相关的服务，然后将特性关联到服务上，如下代码所示:</p>

<pre><code>CBUUID *serviceUUID = [CBUUID UUIDWithString:@"3655296F-96CE-44D4-912D-CD83F06E7E7E"];
CBMutableService *service = [[CBMutableService alloc] initWithType:serviceUUID primary:YES];
service.characteristics = @[character1, character2];    // 组织成树状结构
</code></pre>

<p>上例中primary参数传递的是YES，表示这是一个主服务，即描述了一个设备的主要功能且能被其它服务引用。与之相对的是次要服务(secondary service)，其只在引用它的另一个服务的上下文中描述一个服务。</p>

<h4>发布服务及特性</h4>

<p>创建服务及特性后交将其组织成树状结构后，我们需要将这些服务发布到设备的本地数据库上。我们可以使用CBPeripheralManager的addService:方法来完成此工作。如下代码所示：</p>

<pre><code>[peripheralManager addService:service];
</code></pre>

<p>在调用些方法发布服务时，CBPeripheralManager对象会调用它的代理的peripheralManager:didAddService:error:方法。如果发布过程中出现错误导致无法以布，则可以实现该代理方法来处理错误，如下代码所示：</p>

<pre><code>- (void)peripheralManager:(CBPeripheralManager *)peripheral didAddService:(CBService *)service error:(NSError *)error
{
    NSLog(@"Add Service");

    if (error)
    {
        NSLog(@"Error publishing service: %@", [error localizedDescription]);
    }
}
</code></pre>

<p>在将服务与特性发布到设备数据库后，服务将会被缓存，且我们不能再修改这个服务。</p>

<h4>广告服务</h4>

<p>处理完以上步骤，我们便可以将这些服务广告给对服务感兴趣的Central端。我们可以通过调用CBPeripheralManager实例的startAdvertising:方法来完成这一操作，如下代码所示：</p>

<pre><code>[peripheralManager startAdvertising:@{CBAdvertisementDataServiceUUIDsKey: @[service.UUID]}];
</code></pre>

<p>startAdvertising:的参数是一个字典，Peripheral管理器支持且仅支持两个key值：CBAdvertisementDataLocalNameKey与CBAdvertisementDataServiceUUIDsKey。这两个值描述了数据的详情。key值所对应的value期望是一个表示多个服务的数组。</p>

<p>当广告服务时，CBPeripheralManager对象会调用代码对象的peripheralManagerDidStartAdvertising:error:方法，我们可以在此做相应的处理，如下代码所示：</p>

<pre><code>- (void)peripheralManagerDidStartAdvertising:(CBPeripheralManager *)peripheral error:(NSError *)error
{
    NSLog(@"Start Advertising");

    if (error)
    {
        NSLog(@"Error advertising: %@", [error localizedDescription]);
    }
}
</code></pre>

<p>广告服务之后，Central端便可以发现设备并初始化一个连接。</p>

<h4>对Central端的读写请求作出响应</h4>

<p>在与Central端进行连接后，可能需要从其接收读写请求，我们需要以适当的方式作出响应。</p>

<p>当连接的Central端请求读取特性的值时，CBPeripheralManager对象会调用代理对象的peripheralManager:didReceiveReadRequest:方法，代理方法提供一个CBATTRequest对象以表示Central端的请求，我们可以使用它的属性来填充请求。下面代码简单展示了这样一个过程：</p>

<pre><code>- (void)peripheralManager:(CBPeripheralManager *)peripheral didReceiveReadRequest:(CBATTRequest *)request
{
    // 查看请求的特性是否是指定的特性
    if ([request.characteristic.UUID isEqual:cha1.UUID])
    {
        NSLog(@"Request character 1");

        // 确保读请求所请求的偏移量没有超出我们的特性的值的长度范围
        // offset属性指定的请求所要读取值的偏移位置
        if (request.offset &gt; cha1.value.length)
        {
            [peripheralManager respondToRequest:request withResult:CBATTErrorInvalidOffset];
            return;
        }

        // 如果读取位置未越界，则将特性中的值的指定范围赋给请求的value属性。
        request.value = [cha1.value subdataWithRange:(NSRange){request.offset, cha1.value.length - request.offset}];

        // 对请求作出成功响应
        [peripheralManager respondToRequest:request withResult:CBATTErrorSuccess];
    }
}
</code></pre>

<p>在每次调用代理对象的peripheralManager:didReceiveReadRequest:时调用respondToRequest:withResult:方法以对请求做出响应。</p>

<p>处理写请求类似于上述过程，此时会调用代理对象的peripheralManager:didReceiveWriteRequests:方法。不同的是代理方法会给我们一个包含一个或多个CBATTRequest对象的数组，每一个都表示一个写请求。我们可以使用请求对象的value属性来给我们的特性属性赋值，如下代码所示：</p>

<pre><code>- (void)peripheralManager:(CBPeripheralManager *)peripheral didReceiveWriteRequests:(NSArray *)requests
{
    CBATTRequest *request = requests[0];

    cha1.value = request.value;

    [peripheralManager respondToRequest:request withResult:CBATTErrorSuccess];
}
</code></pre>

<p>响应处理与请求类似。</p>

<h4>发送更新的特性值给订阅的Central端</h4>

<p>如果有一个或多个Central端订阅了我们的服务的特性时，当特性发生变化时，我们需要通知这些Central端。为此，代理对象需要实现peripheralManager:central:didSubscribeToCharacteristic:方法。如下所示：</p>

<pre><code>- (void)peripheralManager:(CBPeripheralManager *)peripheral central:(CBCentral *)central didUnsubscribeFromCharacteristic:(CBCharacteristic *)characteristic
{
    NSLog(@"Central subscribed to characteristic %@", characteristic);

    NSData *updatedData = characteristic.value;

    // 获取属性更新的值并调用以下方法将其发送到Central端
    // 最后一个参数指定我们想将修改发送给哪个Central端，如果传nil，则会发送给所有连接的Central
    // 将方法返回一个BOOL值，表示修改是否被成功发送，如果用于传送更新值的队列被填充满，则方法返回NO
    BOOL didSendValue = [peripheralManager updateValue:updatedData forCharacteristic:(CBMutableCharacteristic *)characteristic onSubscribedCentrals:nil];

    NSLog(@"Send Success ? %@", (didSendValue ? @"YES" : @"NO"));
}
</code></pre>

<p>在上述代码中，当传输队列有可用的空间时，CBPeripheralManager对象会调用代码对象的peripheralManagerIsReadyToUpdateSubscribers:方法。我们可以在这个方法中调用updateValue:forCharacteristic:onSubscribedCentrals:来重新发送值。</p>

<p>我们使用通知来将单个数据包发送给订阅的Central。当我们更新订阅的Central时，我们应该通过调用一次updateValue:forCharacteristic:onSubscribedCentrals:方法将整个更新的值放在一个通知中。</p>

<p>由于特性的值大小不一，所以不是所有值都会被通知传输。如果发生这种情况，需要在Central端调用CBPeripheral实例的readValueForCharacteristic:方法来处理，该方法可以获取整个值。</p>

<h2>Central(Client)端操作</h2>

<p>一个Central端主要包含以下操作：</p>

<ol>
<li>启动一个Central端管理器对象</li>
<li>搜索并连接正在广告的Peripheral设备</li>
<li>在连接到Peripheral端后查询数据</li>
<li>发送一个对特性值的读写请求到Peripheral端</li>
<li>当Peripheral端特性值改变时接收通知</li>
</ol>


<p>我们将在下面结合代码对每一步分别进行讲解</p>

<h4>启动一个Central管理器</h4>

<p>CBCentralManager对象在Core Bluetooth中表示一个本地Central设备，我们在执行任何BLE交互时必须分配并初始化一个Central管理器对象。创建代码如下所示：</p>

<pre><code>// 指定当前类为代理对象，所以其需要实现CBCentralManagerDelegate协议
// 如果queue为nil，则Central管理器使用主队列来发送事件
centralManager = [[CBCentralManager alloc] initWithDelegate:self queue:nil options:nil];
</code></pre>

<p>创建Central管理器时，管理器对象会调用代理对象的centralManagerDidUpdateState:方法。我们需要实现这个方法来确保本地设备支持BLE。</p>

<pre><code>- (void)centralManagerDidUpdateState:(CBCentralManager *)central
{
    NSLog(@"Central Update State");

    switch (central.state) {
        case CBCentralManagerStatePoweredOn:
            NSLog(@"CBCentralManagerStatePoweredOn");
            break;

        case CBCentralManagerStatePoweredOff:
            NSLog(@"CBCentralManagerStatePoweredOff");
            break;

        case CBCentralManagerStateUnsupported:
            NSLog(@"CBCentralManagerStateUnsupported");
            break;

        default:
            break;
    }
}
</code></pre>

<h4>发现正在广告的Peripheral设备</h4>

<p>Central端的首要任务是发现正在广告的Peripheral设备，以备后续连接。我们可以调用CBCentralManager实例的scanForPeripheralsWithServices:options:方法来发现正在广告的Peripheral设备。如下代码所示：</p>

<pre><code>// 查找Peripheral设备
// 如果第一个参数传递nil，则管理器会返回所有发现的Peripheral设备。
// 通常我们会指定一个UUID对象的数组，来查找特定的设备
[centralManager scanForPeripheralsWithServices:nil options:nil];
</code></pre>

<p>在调用上述方法后，CBCentralManager对象在每次发现设备时会调用代理对象的centralManager:didDiscoverPeripheral:advertisementData:RSSI:方法。</p>

<pre><code>- (void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary *)advertisementData RSSI:(NSNumber *)RSSI
{
    NSLog(@"Discover name : %@", peripheral.name);

    // 当我们查找到Peripheral端时，我们可以停止查找其它设备，以节省电量
    [centralManager stopScan];

    NSLog(@"Scanning stop");
}
</code></pre>

<h4>连接Peripheral设备</h4>

<p>在查找到Peripheral设备后，我们可以调用CBCentralManager实例的connectPeripheral:options:方法来连接Peripheral设备。如下代码所示</p>

<pre><code>[centralManager connectPeripheral:peripheral options:nil];
</code></pre>

<p>如果连接成功，则会调用代码对象的centralManager:didConnectPeripheral:方法，我们可以实现该方法以做相应处理。另外，在开始与Peripheral设备交互之前，我们需要设置peripheral对象的代理，以确保接收到合适的回调。</p>

<pre><code>- (void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral
{
    NSLog(@"Peripheral Connected");

    peripheral.delegate = self;
}
</code></pre>

<h4>查找所连接Peripheral设备的服务</h4>

<p>建立到Peripheral设备的连接后，我们就可以开始查询数据了。首先我们需要查找Peripheral设备中可用的服务。由于Peripheral设备可以广告的数据有限，所以Peripheral设备实际的服务可能比它广告的服务要多。我们可以调用peripheral对象的discoverServices:方法来查找所有的服务。如下代码所示：</p>

<pre><code>[peripheral discoverServices:nil];
</code></pre>

<p>参数传递nil可以查找所有的服务，但一般情况下我们会指定感兴趣的服务。</p>

<p>当调用上述方法时，peripheral会调用代理对象的peripheral:didDiscoverServices:方法。Core Bluetooth创建一个CBService对象的数组，数组中的元素是peripheral中找到的服务。</p>

<pre><code>- (void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(NSError *)error
{
    NSLog(@"Discover Service");

    for (CBService *service in peripheral.services)
    {
        NSLog(@"Discovered service %@", service);
    }
}
</code></pre>

<h4>查找服务中的特性</h4>

<p>假设我们已经找到感兴趣的服务，接下来就是查询服务中的特性了。为了查找服务中的特性，我们只需要调用CBPeripheral类的discoverCharacteristics:forService:方法，如下所示：</p>

<pre><code>NSLog(@"Discovering characteristics for service %@", service);
[peripheral discoverCharacteristics:nil forService:service];
</code></pre>

<p>当发现特定服务的特性时，peripheral对象会调用代理对象的peripheral:didDiscoverCharacteristicsForService:error:方法。在这个方法中，Core Bluetooth会创建一个CBCharacteristic对象的数组，每个元素表示一个查找到的特性对象。如下代码所示：</p>

<pre><code>- (void)peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(NSError *)error
{
    NSLog(@"Discover Characteristics");
    for (CBCharacteristic *characteristic in service.characteristics)
    {
        NSLog(@"Discovered characteristic %@", characteristic);
    }
}
</code></pre>

<h4>获取特性的值</h4>

<p>一个特性包含一个单一的值，这个值包含了Peripheral服务的信息。在获取到特性之后，我们就可以从特性中获取这个值。只需要调用CBPeripheral实例的readValueForCharacteristic:方法即可。如下所示：</p>

<pre><code>NSLog(@"Reading value for characteristic %@", characteristic);
[peripheral readValueForCharacteristic:characteristic];
</code></pre>

<p>当我们读取特性中的值时，peripheral对象会调用代理对象的peripheral:didUpdateValueForCharacteristic:error:方法来获取该值。如果获取成功，我们可以通过特性的value属性来访问它，如下所示：</p>

<pre><code>- (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error
{
    NSData *data = characteristic.value;

    NSLog(@"Data = %@", data);
}
</code></pre>

<h4>订阅特性的值</h4>

<p>虽然使用readValueForCharacteristic:方法读取特性值对于一些使用场景非常有效，但对于获取改变的值不太有效。对于大多数变动的值来讲，我们需要通过订阅来获取它们。当我们订阅特性的值时，在值改变时，我们会从peripheral对象收到通知。</p>

<p>我们可以调用CBPeripheral类的setNotifyValue:forCharacteristic:方法来订阅感兴趣的特性的值。如下所示：</p>

<pre><code>[peripheral setNotifyValue:YES forCharacteristic:characteristic];
</code></pre>

<p>当我们尝试订阅特性的值时，会调用peripheral对象的代理对象的peripheral:didUpdateNotificationStateForCharacteristic:error: 方法。如果订阅失败，我们可以实现该代理方法来访问错误，如下所示：</p>

<pre><code>- (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error
{
    ...

    if (error)
    {
        NSLog(@"Error changing notification state: %@", [error localizedDescription]);
    }
}
</code></pre>

<p>在成功订阅特性的值后，当特性值改变时，peripheral设备会通知我们的应用。</p>

<h4>写入特性的值</h4>

<p>一些场景下，我们需要写入特性的值。例如我们需要与BLE数字恒温器交互时，可能需要给恒温器提供一个值来设定房间的温度。如果特性的值是可写的，我们可以通过调用CBPeripheral实例的writeValue:forCharacteristic:type:方法来写入值。</p>

<pre><code>NSData *data = [NSData dataWithBytes:[@"test" UTF8String] length:@"test".length];
[peripheral writeValue:data forCharacteristic:characteristic type:CBCharacteristicWriteWithResponse];
</code></pre>

<p>当尝试写入特性值时，我们需要指定想要执行的写入类型。上例指定了写入类型是CBCharacteristicWriteWithResponse，表示peripheral让我们的应用知道是否写入成功。</p>

<p>指定写入类型为CBCharacteristicWriteWithResponse的peripheral对象，在响应请求时会调用代理对象的peripheral:didWriteValueForCharacteristic:error:方法。如果写入失败，我们可以在这个方法中处理错误信息。</p>

<h2>小结</h2>

<p>Core Bluetooth框架已经为我们封装了蓝牙通信的底层实现，我们只需要做简单的处理就可以在程序中实现基于蓝牙的通信。不过在游戏中，一般使用Game Kit中自带的蓝牙处理功能，以实现大数据量的通信。Core Bluetooth框架还是比较适合小数据量的通信。</p>

<h2>参考</h2>

<p><a href="https://developer.apple.com/library/ios/documentation/NetworkingInternetWeb/Conceptual/CoreBluetooth_concepts/AboutCoreBluetooth/Introduction.html">Core Bluetooth Programming Guide</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iBeacon技术初探]]></title>
    <link href="http://southpeak.github.io/blog/2014/07/27/ibeaconji-zhu-chu-tan/"/>
    <updated>2014-07-27T15:22:43+08:00</updated>
    <id>http://southpeak.github.io/blog/2014/07/27/ibeaconji-zhu-chu-tan</id>
    <content type="html"><![CDATA[<p>苹果在WWDC 2013上正式推出了iBeacon，并在iOS7设备上配备了该功能。苹果期望将其做为一种技术标准，这个标准允许移动App(包括iOS或Android设备)监听来自于iBeacon设备上的信号并做出响应。这种iBeacon设备配备有低功耗蓝牙(Bluetooth Low Energy, BLE)通信功能，并使用BLE向周围发送自己特有的ID，移动设备上的App在接收到该ID后可以做出相应的反应。比如，我们在店铺里设置iBeacon发射器，便可让应用接收到信息并将这一信息通知给服务器，服务器向我们的App返回与该店铺相关的产品或折扣信息。本质上讲，iBeacon技术允许移动应用了解它们在某个局部范围内的位置，并向用户分发基于位置的超文本上下文内容。本文将对iBeacon技术做个简要的介绍。</p>

<h2>低功耗蓝牙技术(Bluetooth Low Energy)</h2>

<p>iBeacon的底层通信技术是采用低功耗蓝牙技术，这种技术是在短距离范围内数据传输的无线区域网络技术。顾名思义，它即要求低功耗，又需要保证传统蓝牙技术的通信范围。</p>

<p>BLE与传统蓝牙有几点不同：</p>

<ol>
<li>耗电量：BLE是低耗电量的，iBeacon设备使用一个纽扣电池即可持续运作长达3年时间。</li>
<li>低成本：BLE的成本只相当于传统蓝牙设备的60%-80%</li>
<li>应用：BLE适用于只要求少量定期传输数据的简单应用。传统的蓝牙适用于需要持续通信和大量数据传输的复杂应用。</li>
</ol>


<p>BLE通信数据包主要由称为&#8221;Advertisements&#8221;的数据或小的数据包组成，并通过无线电波由Beacons或其它BLE设备以有规律的时间间隔来广播。BLE广告是一种单向通信(one-way communication)方法。希望被发现的Beacon设备可以以设定的时间间隔广播或&#8221;广告&#8221;自包含的数据包。这些数据包由智能手机等设备收集，并在设备上触发一些事件，如推送消息、提示等。</p>

<p>苹果iBeacon标准要求广播时间的间隔是100ms。频率超高越耗电，但可以让智能手机或其它监听设备越快地发现iBeacon。标准的BLE广播距离是100m，这使Beacon在室内位置跟踪场景下的效果更理想。</p>

<h2>监听Beacon区域</h2>

<p>Beacon区域监听使用iOS设备的内置无线电来检测用户何时在广告iBeacon信息的BLE设备附近。由于是地理位置的监听，当用户进入或在一个Beacon区域时，我们可以使用这些功能来生成提示或提供其它相关的信息。一个Beacon区域通过以下值的组合来进行标识：</p>

<ol>
<li>proximity UUID(全局唯一标识)：一个128位值，唯一标识一类或一个组织中的一个或多个Beacon。</li>
<li>major值，一个16位无符号整数，用于分组有相同proximity UUID值的相关的Beacon。</li>
<li>minor值，一个16位无符号整数，用于区分具有相同proximity UUID值和major的值。</li>
</ol>


<p>因为一个Beacon区域可以包含多个iBeacon设备，Beacon区域监听支持同时监听多个感兴趣的设备。例如，一个App为了在特定商场提高用户体验，可用使用相同的proximity UUID来监听商场的所有商铺。当用户进入一个商店时，App检测商铺的iBeacon设备并使用major和minor值来获取额外的信息，如用户进入哪家商店或用户在商店的哪个区域(注意：虽然每个iBeacon都必须有一个proximity UUID，但major和minor的值是可选的)。</p>

<h4>定义一个Beacon区域</h4>

<p>我们使用<strong>CLBeaconRegion</strong>类的初始化方法来定义一个beacon区域，并在系统中注册，以开启一个监听。当创建一个CLBeaconRegion对象时，我们指定需要监听的Beacon区域的proximityUUID, major和minor属性。我们必须提供一个唯一标识区域的字符串以便我们在代码中能引用它。注意一个区域的标识与Beacon标识信息无关。</p>

<p>为了注册一个beacon区域，调用CLLocationManager对象的startMonitoringForRegion方法。代码清单1是创建并注册的beacon区域的简单方法。</p>

<h6>代码清单1：创建和注册一个beacon区域</h6>

<pre><code>- (void)registerBeaconRegionWithUUID:(NSUUID *)proximityUUID andIdentifier:(NSString *)identifier
{
    CLBeaconRegion *beaconRegion = [[CLBeaconRegion alloc] initWithProximityUUID:proximityUUID identifier:identifier];

    [manager startMonitoringForRegion:beaconRegion];
}
</code></pre>

<p>App在注册并监听某个Beacon区域后，会立即开始监听此区域。当App监听到注册的Beacon区域时，系统会为App生成一个合适的区域事件。</p>

<h4>处理边界穿越事件</h4>

<p>当用户进入一个注册的Beacon区域时，CLLocationManager对象将调用其代理对象的locationManager:didEnterRegion:方法。类似的，当用户离开这个区域时，将调用代理对象的locationManager:didExitRegion:方法。注意，用户必须穿过区域边界来触发这些调用，如果用户已经在区域中，CLLocationManager对象将不会调用locationManager:didEnterRegion:。我们可以实现这些代理方法来提示用户或展示一个指定位置的UI。</p>

<p>我们可以设置Beacon区域的notifyOnEntry和notifyOnExit属性来指定哪个边界穿越事件应该通知给我们的App。例如，如果在用户离开区域时不需要通知App，则可以设置区域的notifyOnEntry属性为NO。</p>

<p>我们也可以在用户打开设备的屏幕时再通知用户已进入一个Beacon区域。我们只需要在注册Beacon区域时，简单的设置Beacon区域的notifyEntryStateOnDisplay属性为YES，以及设置notifyOnEntry属性为NO。为了防止多余的通知被发送给用户，只在进入一个区域时才发送一个本地通知。</p>

<p>当用户已经在注册的Beacon区域内时，App可以调用CLLocationManager类的startRangingBeaconsInRegion:方法来确定我们的设备与区域中的一个或多个iBeacon设备的相对距离，并在距离改变时被通知。(注意：我们总是在尝试查找区域内的iBeacon设备时调用CLLocationManager的类方法isRangingAvailable)。对于大多数程序来说，知道这个相对距离是很有用的。例如，想像一个在每个展品上安装了iBeacon设备的博物馆。如果我们使用这个博物馆相应的App，当我们走近某个展品时，就可以通过iBeacon来向我们的App发送关于展品的信息。</p>

<p>当指定Beacon区域的iBeacon设备进入范围、离开范围或相对距离改变时，CLLocationManager对象调用代理对象的locationManager:didRangeBeacons:inRegion:方法。这个代理方法提供一个CLBeacon对象的数组来表示当前设备范围内的iBeacon。iBeacon的数组根据离设备的相对距离来排序，最近的在最前面。我们可以使用这些对象中的信息来确定用户离每个iBeacon设备的距离。CLBeacon对象的proximity属性给出了到一个beacon的相对距离。</p>

<p><em>注：iBeacon的排列依赖于检测到的BLE无线信号的强度，以及这些信号受墙壁、门或其它物理实体的影响。当我们使用iBeacon时需要考虑这些影响因素。</em></p>

<p>代码清单2显示了如何使用一个Beacon的proximity属性来确定到用户设备的相对距离。</p>

<h6>代码清单2：确定用户设备与beacon的相对距离</h6>

<pre><code>- (void)locationManager:(CLLocationManager *)manager didRangeBeacons:(NSArray *)beacons inRegion:(CLBeaconRegion *)region
{
    if ([beacons count] &gt; 0)
    {
        CLBeacon *nearestExhibit = [beacons firstObject];

        if (CLProximityNear == nearestExhibit.proximity)
        {
            NSLog(@"%d", nearestExhibit.major.integerValue);
        }
        else
        {
            NSLog(@"test");
        }
    }
}
</code></pre>

<p>注意：当多个iBeacon设备广告了相同的proximityUUID, major和minor属性组合时，在locationManager:didRangeBeacons:inRegion:方法中它们可能会有不同的距离与精度。建议每一个beacon设备都是唯一标识的。</p>

<h2>在iOS设备中开启iBeacon功能</h2>

<p>支持使用BLE分享数据的iOS设备可以当作iBeacon设备来使用。由于应用必须运行于前台，因此iOS设备上的iBeacon支持主要用于测试目的和任何情况下都运行于前台的App。对于其它类型的iBeacon实现，我们必须从第三方的制造商那获取专用的iBeacon设备。</p>

<p>因为将iOS设备作为一个iBeacon设备需要使用Core Bluetooth framework，所以我们需要在XCode工程中链接CoreBluetooth.framework。同时在相关的资源文件中导入&lt;CoreBluetooth/CoreBluetooth.h>头文件。</p>

<p>要在一个iOS设备上创建和广告一个Beacon区域，首先我们需要生成一个128位的UUID作为我们的proximity UUID。我们可以在终端使用uuidgen命令来生成一个UUID。然后，我们使用这个UUID来创建一个Beacon区域，同时定义所需的major和minor值。代码清单3显示了如何创建一个新Beacon区域</p>

<h6>代码清单3</h6>

<pre><code>NSUUID *proximityUUID = [[NSUUID alloc] initWithUUIDString:@"D80415EC-AC22-4046-8497-4BDAC297323C"];

CLBeaconRegion *beaconRegion = [[CLBeaconRegion alloc] initWithProximityUUID:proximityUUID identifier:@"com.mycompany.myregion"];        
</code></pre>

<p>现在我们已经创建了一个Beacon区域，然后我们需要使用Core Bluetooth framework的CBPeripheralManager来广告我们的Beacon的proximity UUID(及major或minor值)。在Core Bluetooth中，一个peripheral是使用BLE来广告和分享数据的设备。广告Beacon的数据是其它设备能检测并排列我们的Beacon设备的唯一方法。</p>

<p>为了在Core Bluetooth中广告peripheral数据，我们调用CBPeripheralManager实例的startAdvertising:方法。这个方法需要广告数据的字典。然后我们创建一个CBPeripheralManager类的实例，并让其广告我们的Beacon来让其它设备监听。代码清单4所示了这一过程。</p>

<h6>代码清单4</h6>

<pre><code>NSDictionary *beaconPeripheralData = [beaconRegion peripheralDataWithMeasuredPower:nil];

manager = [[CBPeripheralManager alloc] initWithDelegate:self queue:nil options:nil];
[manager startAdvertising:beaconPeripheralData];
</code></pre>

<p><strong>重要：当我们创建一个peripheral管理对象时，peripheral管理对象会调用它的代理的peripheralManagerDidUpdateState:方法。我们必须实现这个代理方法以确保BLE在本地peripheral设备上可用。</strong></p>

<p>在广告我们的iBeacon后，我们必须在前台继续运行程序来广播所需要的蓝牙信号。</p>

<h2>小结</h2>

<p>iBeacon是苹果提出的近场定位技术，其目标直指NFC。在App中使用iBeacon并不复杂，苹果已经为我们解决了大部分的底层技术问题。我们只需要简单的创建一个Beacon区域并监听它，在代理对象中处理相应的事件即可。它的实质就是一种定位技术，其在室内导航方面前景光明，相信这一技术会在今后大有作为。</p>

<h2>参考</h2>

<ol>
<li><a href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/LocationAwarenessPG/Introduction/Introduction.html">Location and Maps Programming Guide</a></li>
<li><a href="http://www.cocoachina.com/applenews/devnews/2014/0115/7705.html">如何使用iOS 7的iBeacons来提高你的应用</a></li>
<li><a href="http://www.cocoachina.com/applenews/devnews/2014/0512/8377.html">开发使用 iBeacon 的 iOS 7 应用</a></li>
<li>代码示例：<a href="https://developer.apple.com/library/ios/samplecode/AirLocate/Introduction/Intro.html">AirLocate: Using CoreLocation to monitor, range, and configure your device as an iBeacon</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[URL加载系统之五：缓存、Cookies与协议]]></title>
    <link href="http://southpeak.github.io/blog/2014/07/20/urljia-zai-xi-tong-zhi-wu-:huan-cun-,-cookiesyu-xie-yi/"/>
    <updated>2014-07-20T22:56:30+08:00</updated>
    <id>http://southpeak.github.io/blog/2014/07/20/urljia-zai-xi-tong-zhi-wu-:huan-cun-,-cookiesyu-xie-yi</id>
    <content type="html"><![CDATA[<h2>缓存</h2>

<p>URL加载系统为请求提供了基于磁盘和内存的组合响应缓存。这个缓存让应用减少了对网络连接的依赖，提高了性能。</p>

<p>一个NSURLRequest实例通过设置缓存策略来指定本地缓存。默认的缓存策略是NSURLRequestUseProtocolCachePolicy，其行为是由协议指定的针对该协议最好的实现方式。另外几种缓存策略描述如下：</p>

<ol>
<li>NSURLRequestReloadIgnoringCacheData：URL加载系统将从服务端加载数据，而完全忽略缓存。</li>
<li>NSURLRequestReturnCacheDataElseLoad：URL加载系统使用缓存数据，忽略其过期时间；只有在没有缓存版本的时候才从源端加载数据。</li>
<li>NSURLRequestReturnCacheDataDontLoad：允许应用指定只有在缓存中的数据应该被返回。如果在创建NSURLConnection或NSURLDownload实例时使用这个缓存策略，如果响应没有在本地缓存中，则直接返回nil。这类似于使用离线模式，且从来不进行网络连接。</li>
</ol>


<p>需要注意的是，目前只有HTTP和HTTPS的响应还被缓存。</p>

<p>缓存最常用的场景是使用HTTP协议做网络请求，同时设置缓存策略为NSURLRequestUseProtocolCachePolicy。如果一个请求的NSCachedURLResponse不存在，则加载系统会从源端获取数据。如果请求的缓存响应存在于本地，则URL加载系统检查响应来确定它指定的内容必须被重新验证。如果内容必须验证，则加载系统发出一个HEAD请求到源端以确定资源是否已经改变。如果没有改变，则URL加载系统返回缓存响应对象。如果已经改变了，则URL加载系统从源端获取数据。</p>

<p>如果缓存响应对象没有指定内容必须被重新验证，则加载系统校验缓存响应对象的最大age或有效时间。如果缓存对象未过期，则加载系统返回缓存对象。如果响应过旧，则URL加载系统发起一个HEAD请求到源端查看资源是否已被修改。如果修改了，则URL加载系统从源端获取新的数据。否则，返回缓存响应对象。</p>

<p>默认情况下，连接的数据基于请求的缓存策略来进行缓存，同时由处理请求的NSURLProtocol子类来解析。如果我们需要对缓存做更精确的控制，我们可以实现一些代理方法来允许应用来确定请求是否应该缓存：</p>

<ol>
<li>对于NSURLSession数据和上传任务，实现URLSession:dataTask:willCacheResponse:completionHandler:方法。这个代理方法只用于数据请求和上传任务。而下载任务的缓存由指定的缓存策略来决定。</li>
<li>对于NSURLConnection，实现connection:willCacheResponse:方法</li>
</ol>


<p>对于NSURLSession，我们的代理方法调用一个完成处理器block来告知会话需要缓存什么东西。对于NSURLConnection，代理方法返回连接需要缓存的对象。不管是哪种情况，代理都会提供以下值之一：</p>

<ol>
<li>允许缓存的响应对象</li>
<li>新创建的响应对象，用于缓存被修改的响应</li>
<li>NULL，以阻止缓存</li>
</ol>


<p>代理方法也可以提供与NSCacheURLResponse对象相关的userInfo字典，将这些对象作为响应的一部分存储在缓存中。</p>

<p>需要注意的是，如果我们使用NSURLSession眀实现了代理方法，则代理方法必须总是调用提供的完成处理器，否则会导致内存泄露。</p>

<h2>Cookies</h2>

<p>由于HTTP协议是无状态的，客户端通常使用cookie来提供URL请求间数据的持久化存储。URL加载系统提供接口来创建和管理cookie，将cookie作为HTTP请求的一部分进行发送，并在解析一个服务端的响应时获取cookie。</p>

<p>NSHTTPCookie类封装了一个cookie，并提供了大量访问器来访问cookie的各种属性。该类同样提供了方法用于HTTP cookie头与NSHTTPCookie实例之间的互转。URL加载系统自动发送与NSURLRequest对象匹配的任何存储的cookie，除非该请求指明不需要发送cookie。同样，NSURLResponse对象是返回的cookie将根据当前设定的cookie接收策略来处理。</p>

<p>NSHTTPCookieStorage提供接口来管理NSHTTPCookie对象的集合。与MacOS不同的是，iOS的cookie不能在应用间共享。NSHTTPCookieStorage允许一个应用指定cookie接收策略。</p>

<h2>协议支持</h2>

<p>URL加载系统允许客户端程序扩展协议，以支持自定义的传输数据的方式。URL加载系统默认只支持http, https, file, ftp和data协议。</p>

<p>我们可以继承NSURLProtocol来实现一个自定义的协议，然后使用NSURLProtocol类的的registerClass:方法将其注册到URL加载系统中。当NSURLSession, NSURLConnection和NSURLDownload对象初始化一个NSURLRequest的连接时，URL加载系统以注册顺序的倒序来查询每一个注册类。每个类都将调用canInitWithRequest:方法，第一个返回YES的类将被用于处理请求。</p>

<p>如果自定义协议需要额外的属性业支持请求与响应，则通过创建NSURLRequest, NSMutableRequest和NSResponse类的类别来提供这些属性的访问器。NSURLProtocol类提供方法在这些访问器中设置和获取属性值。</p>

<p>URL加载系统负责在连接开始和完成时创建和释放NSURLProtocol实例。我们的应用不应该直接创建NSURLProtocol的实例。</p>

<p>当NSURLProtocol子类通过URL加载系统初始化时，它提供了一个实现NSURLProtocolClient协议的客户端对象。NSURLProtocol子类将消息从NSURLProtocolClient协议发送到客户端对象，来告诉URL加载系统它创建了响应，接收数据，重定向到新的URL，请求认证，完成加载等操作。如果自定义协议支持认证，还必须实现NSURLAuthenticationChallengeSender协议。</p>

<h4>参考</h4>

<p><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html">URL Loading System Programming Guide</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bonjour理论2：域命名约定、API及其操作]]></title>
    <link href="http://southpeak.github.io/blog/2014/07/20/bonjourde-yu-ming-ming-yue-ding-,-apiji-qi-cao-zuo/"/>
    <updated>2014-07-20T15:52:22+08:00</updated>
    <id>http://southpeak.github.io/blog/2014/07/20/bonjourde-yu-ming-ming-yue-ding-,-apiji-qi-cao-zuo</id>
    <content type="html"><![CDATA[<h2>域命名约定</h2>

<p>服务实例与服务类型的Bonjour名称与DNS域名相关。这里我们将介绍DNS域名，Bonjour本地“域”，和Bonjour服务实例与服务类型的命名规则。</p>

<h4>域名与DNS</h4>

<p>DNS使用specific-to-general命名方案来为域名命名。最能用的域是&#8221;.&ldquo;,称为根域名，这是类似于UNIX文件系统中的根目录&rdquo;/&ldquo;。所有其它域都在根域名的层次结构中。例如，域名www.apple.com.可以解析为根域&rdquo;.&ldquo;，其下包含顶级域名&#8221;com.&rdquo;,再下面是二级域&#8221;apple.com.&ldquo;, 其下就是&#8221;www.apple.com.&#8221;。下图显示了这种层次结构：</p>

<p><img src="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/NetServices/Art/names_01dns_2x.png" alt="image" /></p>

<p>在这棵倒树的顶部是根域。在其下面是一些顶级域：com., edu., org.等。在顶级域下面是一些二级域，如apple, darwin, zeroconf。这棵树可以无限延伸下去。</p>

<h4>Bonjour和本地链路</h4>

<p>Bonjour协议很大程度上都是在处理本地链路(网络的一部分)。一个主机的本地链路或才链路本地网络(link-lock network)包括主机本身及其它可以不修改IP分组数据就是交换包的主机。在实践中，这包含所有没被路由器分开的主机。</p>

<p>在Bonjour系统中，&#8221;local.&ldquo;用于标识在本地IP网络中应该使用IP多播查询来进行查找的名称。</p>

<p>注意：&#8221;local.&ldquo;不是一个真实的域。我们可以将&#8221;local.&#8221;当成一个伪域。它与传统的DNS域有一个根本的区别：其它域的名称是全局唯一的，而链路本地域名不是。www.apple.com在全球只有唯一的一个DNS入口。而以local.结尾的主机名是本地网络中由多播DNS响应者的集合管理的，所以命名范围就是&#8221;local.&rdquo;(本地)。所以只要不在同一个本地网络中，就可以有两台命名相同的主机，即使是在同一栋楼中。而在同一个本地网络中，也需要确保名称的唯一性。如果在本地网络中发生名称冲突，一个Bonjour主机会自动查找一个新的名称或让用户输入一个新的。</p>

<h4>现有服务类型的Bonjour名称</h4>

<p>Bonjour服务根据IP服务的现有网络标准(RFC 2782)来命名。Bonjour服务名结合服务类型和传输协议绑定以形成一个注册类型。注册类型用于注册一个服务并创建DNS资源记录。如果要在DNS资源记录中区分注册类型和域名，可以要注册类型每个组件前使用下划线。其格式如下</p>

<p><strong>_ServiceType._TransportProtocolName</strong></p>

<p>服务类型是该服务的官方IANA注册名称，如ftp,http或打印机。传输协议的名称是tcp或udp，取决于服务使用的传输协议。一个运行在TCP上的FTP服务注册类型应该是<em>ftp.</em>tcp，并将注册一个名称为<em>ftp.</em>tcp.local.的DNS PTR记录，以作为服务所在主机的多播DNS响应者。</p>

<h4>新服务的Bonjour名称</h4>

<p>如果我们正在设计一个新的协议以作为Bonjour网络服务来推广，则应该在IANA中注册它。</p>

<p>IANA目前要求每个每个注册的服务都与一个&#8221;众所周知的端口&#8221;或众所周知的端口范围相关联。例如，http的端口是80，所以我们在浏览器中访问一个站点时，程序都假设HTTP服务运行在80端口上，除非我们另行指定。</p>

<p>但在Bonjour中，我们不需要知道端口号。因为客户端程序通过对服务类型进行简单查询，就能发现我们的服务，因此不需要端口。</p>

<h4>服务实例的Bonjour名称</h4>

<p>服务实例名称是一种可读的字符串，因此，它们的名称具有描述性，并可以让用户重写我们提供的默认名称。由于它们是可浏览的，而不是类型化的，服务实例名可以是编码为UTF8的任何Unicode字符串，最多63个字节长度。</p>

<p>例如，一个在网络中分享音乐的程序可能使用本地用户名来分享服务(如Emille的曲库)。用户可以重写默认服务名，并将服务命名为Zealous Lizard&rsquo;s Tune Studio._music._tcp.local.</p>

<p>下图说明了一个Bonjour服务实例的名称结构。在树的顶部是域，如本地网络的local.。下一级是注册类型，它由前面加下划线的服务类型(_music)和传输协议(同样前面有开线)组成。在树的底部是可读的服务实例名，如Zealous Lizard&rsquo;s Tune Studio。完整的名称由底至顶，每个组件由&#8221;.&ldquo;分割。</p>

<p><img src="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/NetServices/Art/names_02services_2x.png" alt="image" /></p>

<h2>Bonjour的API架构</h2>

<p>Bonjour网络服务的API结构如下图所示：</p>

<p><img src="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/NetServices/Art/rendarch_04apilayers_2x.png" alt="image" /></p>

<p>其主要有这么几部分：
1. NSNetService和NSNetServiceBrowser类：在Foundation框架中
2. CFNetServices：Core Services中CFNetwork框架的一部分；
3. DNS Service Discovery for Java(OS X)
4. 底层DNS Service Discovery API：构建在BSD socket</p>

<p>所有这些API集合提供了发布、搜索和网络服务解析的基础方法。下面我们简单介绍一下这几个部分</p>

<h4>NSNetService和NSNetServiceBrowser</h4>

<p>NSNetService和NSNetServiceBrowser提供了服务搜索和发布的面向对象接口。NSNetService对象表示Bonjour服务的实例，用于客户端发布和服务搜索；NSNetServiceBrowser表示特定类型服务的浏览器。大多数Cocoa程序员应该使用这些类来处理需求。如果需要更多详细的控制，可以使用DNS Service Discovery API。</p>

<p>NSNetService和NSNetServiceBrowser被安排到默认的NSRunLoop对象中来异步执行发布、搜索和解析操作。所以NSNetService和NSNetServiceBrowser返回的结果都由代理对象来处理。这些对象必须与一个run loop相关联，但不必是默认的run loop。</p>

<h4>CFNetServices</h4>

<p>CFNetServices API位于Core Services框架中，提供Core Foundation样式的类型和函数来管理服务和服务搜索。CFNetServices定义了三个Core Foundation对象类型:</p>

<ol>
<li>CFNetService：服务实例的抽象表示，用于发布或其它用途。相关的函数提供了发布和解析服务的支持</li>
<li>CFNetServiceBrowser：表示特定域中特定类型服务的浏览者。通常只在基于Core Foundation编码时使用这个类型</li>
<li>CFNetServiceMonitor</li>
</ol>


<p>CFNetService和CFNetServiceBrowser对象通常在CFRunLoop中使用。为了获取结果，程序需要实现处理事件的回调函数，如新的服务产生和消失等。与NSNetService和NSNetServiceBrowser不同的是，CFNetServices类型可以不需要一个run loop，可以在需要的时候同步运行。但通常不建议同步使用。</p>

<h4>DNS Service Discovery</h4>

<p>DNS Service Discovery API声明在/usr/include/dns_sd.h中，它为Bonjour服务提供了低级别BSD socket通信。DNS Service Discovery作为软件与多播DNS响应者或DNS服务器之间的中介层。它为我们管理DNS响应者，让我们编写程序时专注于服务和服务浏览者而不是DNS资源记录。</p>

<p>由于DNS Service Discovery API是Darwin开源工程的一部分，我们应该在写跨平台代码使用它，或者在诸如在NSNetService这样的高级别API无法获取低级特性时使用它。</p>

<h2>Bonjour操作</h2>

<p>Bonjour的网络服务结构包含一个简单易用的机制来发布、搜索和使用基于IP的服务。Bonjour支持三种基础操作，每一种都是零配置网络服务所必须的：</p>

<ol>
<li>发布(Publication): 广告一个服务</li>
<li>搜索(Discovery): 浏览可用的服务</li>
<li>解析(Resolution): 将服务实例名转化为地址和端口</li>
</ol>


<p>下面将分别介绍这三个部分。</p>

<h4>Publication</h4>

<p>为了发布一个服务，程序或设备必须使用一个多播DNS响应者来注册服务，或者通过高级API，或者直接与响应者(mDNSResponser)通信。Bonjour同样支持在传统的DNS服务中存储记录。当注册服务后，会创建三个相关的DNS记录：服务记录(SRV), 指针记录(PTR)和文本记录(TXT)。其中TXT记录会包含额外的数据用于解析或使用服务，虽然这些数据通常是空的。</p>

<h5>服务记录</h5>

<p>服务记录将服务实例名称映射到实际使用服务所需要的信息。客户端通过持久化方式存储服务实例名以访问这些服务，并在连接的时候执行针对主机名和端口号的DNS查询。这个额外的indirection级提供了两个重要的特性</p>

<ol>
<li>服务由一个可读的名称标识，而不是域名和端口号</li>
<li>客户端可以在服务的端口号和IP地址变化时访问服务，只要服务名不变即可。</li>
</ol>


<p>SRV记录包含两部分信息来标识一个服务</p>

<ol>
<li>主机名</li>
<li>端口号</li>
</ol>


<p>主机名是服务可被发现的域名。用主机名代替IP地址的原因是一个主机可能对应多个IP地址，或者可以同时有IPv4地址和IPv6地址。使用主机名可以让所有这些情况被正确的处理。</p>

<p>端口号标识的服务的TCP或UDP端口号。</p>

<p>SRV记录以下面的规则来命名：</p>

<p><strong>&lt;Instance Name>.&lt;Service Type>.&lt;Domain></strong></p>

<p>&lt;Instance Name>是服务实例名称，可以是任何UTF-8编码的字符串，通常是可读的有意义的字符串</p>

<p>&lt;Service Type>是标准的IP协议名称，前面带有下划线，后面跟着传输协议(TCP/UDP，前缀也是下划线)。</p>

<p>&lt;Domain>是标准的DNS域名。这可能是一个特定的域名，如apple.com.，也可以是通用的以local.为后缀的域名(用于本地链路的服务)</p>

<p>下面是SRV记录的例子，它是一个运行在TCP上端口号为515上，名称为PrintsAlot的打印后台处理程序：</p>

<p><strong>PrintsAlot._printer._tcp.local. 120 IN src 0 0 515 blackhawk.local.</strong></p>

<p>这条记录将在本地链路的叫做blackhawk.local.的打印机的多播DNS响应者设备上被创建。初始的120是用于缓存的TTL值。两个0是分别表示权重和优先级，在传统DNS上选择多个与给定名匹配的记录时需要使用这两个值，而对于多播DNS，将忽略这两个值。</p>

<h5>指针记录</h5>

<p>PTR记录可以通过将实例的类型映射到服务的特定类型的实例的名字来开启服务搜索。这个记录添加了另一个indirection层，以便服务可以只通过查询使用服务类型标定的PTR记录就被找到。</p>

<p>这个记录只包含信息的一小块&mdash;服务实例的名称。PTR记录的命名与SRV记录类似，不过没有实例名，如下所示：</p>

<p><strong>&lt;Service Type>.&lt;Domain></strong></p>

<h5>文本记录</h5>

<p>TXT记录与相应的SRV记录有相同的名称，并且可以包含少量的关于服务实例的额外的信息，一般不超过100-200个字节。记录也可以是空的。例如，一个网络游戏可以在多人游戏中广告所使用的地图名称。如果需要传输大量的数据，主机需要与客户端建立一个连接并直接发送数据。</p>

<p>通常，这个记录用于运行在同一地址同一端口的多个服务上，例如在同一个打印服务器上运行的多个打印队列，在这种情况下，TXT记录中额外的信息可用于标识预期的打印队列。如下表所示：</p>

<p><img src="http://b140.photo.store.qq.com/psb?/V130i6W71atwfr/AFtWnv5ko6gDjydKCfEChHIKr1la*sMWMqfKcG8VTXg!/b/dCtmdVP4JAAA&amp;bo=TATAAAAAAAADAK0!&amp;rf=viewer_4" alt="image" /></p>

<p>这么做是必要的，因为服务类型曾经与众所周知的端口相关联。建议新的Bonjour协议的设计者在不同的动态分配的端口上来运行每一个服务的实例，而不是在相同的众所周知的端口号上运行它们(这种情况下还需要额外的信息来指定客户端试图通信的服务实例)。</p>

<p>TXT记录中的数据的特性和格式特定于每种服务的类型，所有每个新的服务类型需要为自己相关的TXT记录定义数据的格式，并将其作为协议规范的一部分发布。</p>

<h4>搜索</h4>

<p>服务搜索使用服务发布期间注册的DNS记录来查找特定类型的服务的所有实例。为了做到这一点，所有的应用执行一个匹配服务类型的PTR记录的查询。如_http._tcp，通常使用高级接口。运行于每个设备上的多播DNS响应者将使用服务实例名来返回PTR记录。以音乐共享服务为例，下图显示了搜索的过程</p>

<p><img src="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/NetServices/Art/rendarch_02discover_2x.png" alt="image" /></p>

<p>在搜索音乐共享服务的过程，主要有两步：</p>

<ol>
<li>客户端程序向标准多播地址224.0.0.251发出一个在local.域中服务类型为_music._tcp的查询。</li>
<li>网络中的每一个多播DNS响应者都将接收到这个请求，但只有音乐共享设备会使用一个PTR记录来作出响应。在这种情况下，PTR记录保存一个服务实例名Ed&rsquo;s Party Mix.<em>music.</em>tcp.local.，客户端程序可以从PTR记录中提取服务实例名然后将其添加到一个音乐服务器的离线列表中。</li>
</ol>


<h4>解析</h4>

<p>服务搜索通常只会发生一次，例如，当用户第一次选择打印机时。这个操作保存了服务实例名，和一个服务的任何给定实例的稳定的标识符。端口号，IP地址，主机名可能经常改变，但用户在每次连接服务时不需要再次选择一个打印机。因此，将一个服务名解析为socket信息只有在服务真正使用时才发生。</p>

<p>为了解析一个服务，程序使用服务名来执行SRV记录的DNS查询。多播DNS响应者使用包含当前信息的SRV记录来作出响应。下图演示了音乐共享实例中服务解析的这样一个过程：</p>

<p><img src="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/NetServices/Art/rendarch_03resolve_2x.png" alt="image" /></p>

<p>这个过程主要分为几步：</p>

<ol>
<li>解析进程发送一个DNS查询到多播地址224.0.0.251，查询Ed’s Party Mix._music._tcp.local.的SRV记录。</li>
<li>查询返回服务的主机名和端口号(eds-musicbox.local., 1010)</li>
<li>客户端发送一个IP地址的多播请求</li>
<li>请求解析为IP地址169.254.150.84.然后客户端使用这个IP地址和端口号来连接服务器。这个过程发生在服务被使用时，从而总是查找服务的最新地址和端口号。</li>
</ol>


<p>参考</p>

<p><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/NetServices/Introduction.html">Bonjour Overview</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bonjour理论1：基本概念]]></title>
    <link href="http://southpeak.github.io/blog/2014/07/19/bonjourji-ben-li-lun/"/>
    <updated>2014-07-19T11:38:39+08:00</updated>
    <id>http://southpeak.github.io/blog/2014/07/19/bonjourji-ben-li-lun</id>
    <content type="html"><![CDATA[<p>在过去的二十年里，IP协议已经成为计算机等硬件设备之间通信的基本协议。大部分计算机和其它网络设备都是基于TCP/IP进行通信的。在这种网络中，每个设备都需要一个唯一的IP地址，不管是手动设定的还是由DHCP服务器动态分配的。动态指定的地址是可以改变的，但是像打印机等设备是必须手动设定一个静态地址的，这样网络中的计算机才能连接到它们。然后网络管理员需要配置一个DNS服务器，这样计算机用户就不需要通过IP地址来连接打印机了。这样，一个看起来很小的工作需要比较复杂的配置。但是如果我们需要在自己家中搭建一个局域网，而我们对此一无所知的话，这就是个大问题了。即使对于专业的网络管理员，也需要去手动配置打印机。但我们很多时候并不希望去做这些配置，就可以直接连入局域网内去获取打印机、或在文件服务器、甚至游戏服务器去获取我们想要的东西。</p>

<p>我们希望找到可用的设备并从一个列表中选择它们，而不是必须知道每个服务名或IP地址。这便是Bonjour所需要解决的问题。它是基于IP的一组零配置网络的协议。零配置网络有很大的潜力。</p>

<p>假设我们带着笔记本电脑去客户的公司，这时我们需要打印一些东西。如果这家公司有一台支持Bonjour协议的打印机，那么只要两台设备在同一个局域网内，就可以直接打印。此时，我们的每户本会搜索到任何可用的设备。我们只需要打开文档，选择设备列表中的打印机，点击打印就可完成打印操作。图1演示了这样一个过程：</p>

<p><img src="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/NetServices/Art/about_01example_2x.png" alt="image" /></p>

<p>这种零配置网络能够满足手机游戏、家庭网络、分布式计算和其它很多网络应用的需求。</p>

<p>那么Bonjour到底是什么呢？</p>

<h2>Bonjour三要素</h2>

<p>Bonjour是由苹果提出的基于IP的无配置网络建议。它产生于ZEROCONF工作组的工作，是IETF的一部分。ZEROCONF工作组对于基于IP的零配置网络的需要主要有三个要求</p>

<ol>
<li>寻址(分配IP地址给主机)</li>
<li>命名(使用名字而非IP地址来表示主机)</li>
<li>服务搜索(自动搜索网络服务)</li>
</ol>


<p>Bonjour即是这些需求的一个解决方案。它允许服务提供商、硬件制造商和程序开发者在使用新的技术时只使用单一的网络协议&mdash;IP。网络用户不再需要指定IP地址和主机名，甚至不需要指定网络中访问设备的类型。用户只需要简单的查看有哪些网络服务可用，然后从列表中选择。程序能自动检测到所需要的服务或它们需要进行交互的其它程序，允许自动连接、通信和进行数据传输，而不需要用户的介入。</p>

<p>下面我们来分别看看Bonjour如何解决零配置网络的三个要素</p>

<h4>寻址</h4>

<p>寻址问题通过自分配链路本地寻址方法来解决。链路本地寻址(Link-local addressing)使用为本地网络保留的地址范围，特别是一个小的LAN或单独的LAN片断。IPv6标准将自分配链路本地寻址作为协议的一部分。而IPv4本身不包含链路本地寻址，因此零配置网络寻址的主要挑战是如何在IPv4中改进此功能。</p>

<p>在IPv4中，自分配寻址通过在链路本地范围内挑选一个随机的IP地址并对其进行测试。如果地址没有使用，则作为本地地址。如果已经使用了，计算机或其它设备将选择另一个随机地址并测试。</p>

<p>目前大多数主流操作系统都支持IPv4和IPv6的链路本地寻址。</p>

<h4>命名</h4>

<p>在本地网络中进行name-to-address转换操作建议的方案是使用多播DNS，其中DNS格式查询使用IP多播传送到本地网络中。因为这些DNS查询被发送到多播地址中，因此没有一个全局的DNS服务器来回答这个查询。每个服务或设备都可以提供自己的DNS功能，当前发现一个针对自己名称的查询时，它使用自己的地址来响应这个DNS查询。</p>

<p>Bonjour更进了一步。它在主机或iOS设备上包含一个响应来处理任何网络服务的多播DNS查询。这降低了中断应用来响应多播消息的压力。通过注册服务，Bonjour的mDNSResponder守护进程自动广告我们的服务是否可用，以便把我们名字的查询自动被引导到正确的IP地址和端口号上。</p>

<p>为了让name-to-address转换能正确的工作，需要一个本地网络的唯一的名字。与转换DNS主机名不同的是，这个本地名称只在本地网络或LAN段上有效。我们可以像自分配一个本地地址一样自分配一个本地名称，选中其中一个；如果这个名称没有使用，则：</p>

<ol>
<li>硬件制造商通过设备发送一个多播DNS查询并查看响应来确定其选中的名字是否已使用。如果有响应，则设备应该选择另外一个名字。没有用户界面的设备可以在默认名字后面添加一下大数直到这个名字是唯一的。例如，如果在网络中的默认名字是XYZ-LaserPrinter.local，则可以使用XYZ-LaserPrinter.local，XYZ-LaserPrinter-2.local，XYZ-LaserPrinter-3.local进行测试，直到名字唯一。</li>
<li>软件服务在注册Bonjour时提供一个名字，如果提供的名字已使用，则Bonjour会自动重命名我们的服务。</li>
</ol>


<p>在OS X中，用户可以在系统偏好设置的共享面板中设置本地主机名来为计算机设置一个主机名，在iOS中，主机名是自动产生的且不能配置。这个主机名可用于任何DNS主机名常规使用的地方，如Web浏览器、命令行工具等等。为了向系统表明名字是一个本地主机名，可在主机名后添加.local.，如Setve.local.即为一个本地主机名。</p>

<p>如果用户在浏览器中输入steve.local.，这将告诉系统多播一个请求以在本地网络中查询steve，而不是将其发送到常规DNS服务器。如果在本地网络中有一台支持Bonjour的计算机名字为steve，则用户的浏览器将发送正确的IP地址给它。这允许用户访问本地主机和服务崦不需要常规DNS服务。</p>

<h4>服务搜索</h4>

<p>Bonjour最后一个要素是服务搜索。服务搜索允许程序查找所有可用的特定类型的服务并维护一个命名服务及端口的列表。应用可以将服务主机名解析为IPv4和IPv6地址列表。</p>

<p>命名服务的列表在服务与其当前DNS名和端口中提供了一个indirection层。indirection允许程序保存一个可用服务的持久化列表并在使用服务前解析一个实际的网络地址。该列表允许服务被动态迁移，而不会产生大量的网络流量来宣告这个改变。</p>

<p>在Bonjour中服务搜索是通过&#8221;browsing&#8221;来实现的。一个多播DNS查询发送一个指定的服务类型和域，任何匹配的服务都会回复他们的名字。其结果就是一个可用服务的列表。这与传统的网络服务以设备为中心的思考很不一样。对于处理服务、网络设备和网络编程的的个人来讲，很容易习惯性认为服务基于物理硬件(services in terms of physical hardware)。
从设备为中心的角度来看，网络由许多设备或主机组成，每个包含一组服务。例如，网络可能由服务器和客户机组成。在一个设备为中心的浏览架构中，一个客户端向服务器查询哪些服务正在运行，获取一个列表(FTP, HTTP等)，并决定使用哪个服务。这个接口反映了物理系统组织的方式。但这不一定是用户在逻辑上希望的或想要的。</p>

<p>用户通常想要完成特定的任务，而不是查找设备列表来找出什么服务正在运行。让客户端只询问一次“什么打印服务可用？”比查询每个可用的设备来问“你正在运行什么服务”然后筛选结果查找打印服务来得更有意义。以设备为中心的方法不但耗时，而且需要大量的网络流量，且其中大部分是无用的。而以服务为中心的方法发送单个查询，只生成相关的回复。</p>

<p>此外，服务不与指定的IP或主机名绑定。例如，一个站点可能被多个有不同地址的服务器托管。在一个组织中，网络管理员可能需要将一个服务从一个服务器移到另一个服务器来做负载均衡。如果客户端存储了主机名，如果服务移到另一个不同的主机，则无法再连接。</p>

<p>Bonjour从面向服务的角度来看问题。它通过所需要的服务类型来查找，而不是主机名。应用存储的是服务实例名，而不是地址，所以如果IP地址、端口号，甚至主机名改变了，应用仍然可以连接。通过专注于服务而不是设备，用户的浏览体验将更有用且无故障。</p>

<h2>降低消耗</h2>

<p>服务器的寻址、命名和服务搜索可能会产生大量的网络流量，但Bonjour采取了一些措施来将流量降低到最少。这允许Bonjour达到AppleTalk的易用性，同时又避免了不必要的“繁琐”。Bonjour采用了多种机制来降低零配置的开销，包括缓存、禁止重复响应，指数回退和服务公告。下面我们将简单介绍下这几种机制。</p>

<h4>缓存</h4>

<p>Bonjour采用了多播DNS记录缓存来防止主机请求那些已请求过的信息。例如，当一个主机请求一个LPR打印后台的处理程序列表时，列表通过多播传回来，所有本地主机都将看到这个列表。下次本地网络中的一个主机需要一个打印后台处理程序的列表时，因为它已经缓存了这个列表，所以不需要再次发起请求。多播DNS响应者负责维护这个缓存；程序开发者不需要做任何事情来维护它</p>

<h4>禁止重复响应</h4>

<p>为了阻止重复响应相同的请求，Bonjour服务查询包含一个已知答案的列表。例如，如果主机正在浏览打印机，第一个查询不包含打印服务，但从可用打印服务器得到12个回复。下一次该主机查询打印服务时，查询包含已知服务器的列表。已经在列表中的打倒服务器将不做响应。</p>

<p>Bonjour以另一种方式来抑制重复响应。如果一个主机将要响应，但发现另一个主机已经响应了相同的信息，则主机会抑制它的响应。</p>

<p>程序开发者不需要采取任何措施来抑制重复发送，Bonjour会处理。</p>

<h4>指数回退和服务公告</h4>

<p>当主机浏览服务时，它不会不间断地发送查询来查看是否有新的服务。相反，主机会初始一个查询，后续会不断增加查询时间的间隔，如1s, 3s, 9s, 27s这样一个时长间隔，最后可能会长达1小时的间隔。</p>

<p>但这不意味着花费一个小时的时间间隔再来查看新的服务。当在网络中启动一个服务时，它会使用几次回退算法来通知它的存在。这样就将服务公告和搜索的网络流量保持在最小，而新的服务也会很快就知晓。</p>

<p>在一个Bonjour配置主机上运行的服务在注册到mDNSResponder守护程序时会自动发出公告。在其它硬件上的服务，如打印机，将使用指数回退算法来公告其存在，这样充分利用了Bonjour的优势。</p>

<p>参考</p>

<p><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/NetServices/Introduction.html">Bonjour Overview</a></p>
]]></content>
  </entry>
  
</feed>
