<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[南峰子的技术博客]]></title>
  <link href="http://southpeak.github.io/atom.xml" rel="self"/>
  <link href="http://southpeak.github.io/"/>
  <updated>2014-07-29T21:54:18+08:00</updated>
  <id>http://southpeak.github.io/</id>
  <author>
    <name><![CDATA[南峰子]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Core Bluetooth框架之一：Central与Peripheral]]></title>
    <link href="http://southpeak.github.io/blog/2014/07/29/core-bluetoothkuang-jia-zhi-%5B%3F%5D-:centralyu-peripheral/"/>
    <updated>2014-07-29T21:52:48+08:00</updated>
    <id>http://southpeak.github.io/blog/2014/07/29/core-bluetoothkuang-jia-zhi-[?]-:centralyu-peripheral</id>
    <content type="html"><![CDATA[<p>iOS和Mac应用使用Core Bluetooth framework来与BLE(低功耗蓝牙)设备通信。我们的程序可以发现、搜索并与低功耗外围(Peripheral)蓝牙设备通信，如心跳监听器、数字温控器、甚至是其它iOS设备。这个框架抽象了支持蓝牙4.0标准低功耗设备的基本操作，隐藏了4.0标准的底层实现细节，让我们可以方便的使用BLE设备。</p>

<h2>蓝牙通信中的角色</h2>

<p>在BLE通信中，主要有两个角色：Central和Peripheral。类似于传统的客户端-服务端架构，一个Peripheral端是提供数据的一方(相当于服务端)；而Central是使用Peripheral端提供的数据完成特定任务的一方(相当于客户端)。下图以心跳监听器为例展示了这样一个架构：</p>

<p><img src="https://developer.apple.com/library/ios/documentation/NetworkingInternetWeb/Conceptual/CoreBluetooth_concepts/Art/CBDevices1_2x.png" alt="image" /></p>

<p>Peripheral端以广告包的形式来广播一些数据。一个广告包(advertising packet)是一小束相关数据，可能包含Peripheral提供的有用的信息，如Peripheral名或主要功能。在BLE下，广告是Peripheral设备表现的主要形式。</p>

<p>Central端可以扫描并监听其感兴趣的任何广播信息的Peripheral设备。</p>

<p>数据的广播及接收需要以一定的数据结构来表示。而服务就是这样一种数据结构。Peripheral端可能包含一个或多个服务或提供关于连接信号强度的有用信息。一个服务是一个设备的数据的集合及数据相关的操作。</p>

<p>而服务本身又是由特性或所包含的服务组成的。一个特性提供了关于服务的更详细的信息。下图展示了心率监听器中的各种数据结构</p>

<p><img src="https://developer.apple.com/library/ios/documentation/NetworkingInternetWeb/Conceptual/CoreBluetooth_concepts/Art/CBPeripheralData_Example_2x.png" alt="image" /></p>

<p>在一个Central端与Peripheral端成功建立连接后，Central可以发现Peripheral端提供的完整的服务及特性的集合。一个Central也可以读写Peripheral端的服务特性的值。我们将会在下面详细介绍。</p>

<h2>Central、Peripherals及Peripheral数据的表示</h2>

<p>当我们使用本地Central与Peripheral端交互时，我们会在BLE通信的Central端执行操作。除非我们设置了一个本地Peripheral设备，否则大部分蓝牙交互都是在Central端进行的。(下文也会讲Peripheral端的基本操作)</p>

<p>在Central端，本地Central设备由CBCentralManager对象表示。这个对象用于管理发现与连接Peripheral设备(CBPeripheral对象)的操作，包括扫描、查找和连接。下图本地Central端与peripheral对象</p>

<p><img src="https://developer.apple.com/library/ios/documentation/NetworkingInternetWeb/Conceptual/CoreBluetooth_concepts/Art/CBObjects_CentralSide_2x.png" alt="image" /></p>

<p>当与peripheral设备交互时，我们主要是在处理它的服务及特性。在Core Bluetooth框架中，服务是一个CBService对象，特性是一个CBCharacteristic对象，下图演示了Central端的服务与特性的基本结构：</p>

<p><img src="https://developer.apple.com/library/ios/documentation/NetworkingInternetWeb/Conceptual/CoreBluetooth_concepts/Art/TreeOfServicesAndCharacteristics_Remote_2x.png" alt="image" /></p>

<p>苹果在OS X 10.9和iOS 6版本后，提供了BLE外设(Peripheral)功能，可以将设备作为Peripheral来处理。在Peripheral端，本地Peripheral设备表示为一个CBPeripheralManager对象。这些对象用于管理将服务及特性发布到本地Peripheral设备数据库，并广告这些服务给Central设备。Peripheral管理器也用于响应来自Central端的读写请求。如下图展示了一个Peripheral端角色：</p>

<p><img src="https://developer.apple.com/library/ios/documentation/NetworkingInternetWeb/Conceptual/CoreBluetooth_concepts/Art/CBObjects_PeripheralSide_2x.png" alt="image" /></p>

<p>当在本地Peripheral设备上设置数据时，我们实际上处理的是服务与特性的可变版本。在Core Bluetooth框架中，本地Peripheral服务由CBMutableService对象表示，而特性由CBMutableCharacteristic对象表示，下图展示了本地Peripheral端服务与特性的基本结构：</p>

<p><img src="https://developer.apple.com/library/ios/documentation/NetworkingInternetWeb/Conceptual/CoreBluetooth_concepts/Art/TreeOfServicesAndCharacteristics_Local_2x.png" alt="image" /></p>

<h2>Peripheral(Server)端操作</h2>

<p>一个Peripheral端操作主要有以下步骤：</p>

<ol>
<li>启动一个Peripheral管理对象</li>
<li>在本地Peripheral中设置服务及特性</li>
<li>将服务及特性发布给设备的本地数据库</li>
<li>广告我们的服务</li>
<li>针对连接的Central端的读写请求作出响应</li>
<li>发送更新的特性值到订阅Central端</li>
</ol>


<p>我们将在下面结合代码对每一步分别进行讲解</p>

<h4>启动一个Peripheral管理器</h4>

<p>要在本地设备上实现一个Peripheral端，我们需要分配并初始化一个Peripheral管理器实例，如下代码所示</p>

<pre><code>// 创建一个Peripheral管理器
// 我们将当前类作为peripheralManager，因此必须实现CBPeripheralManagerDelegate
// 第二个参数如果指定为nil，则默认使用主队列
peripheralManager = [[CBPeripheralManager alloc] initWithDelegate:self queue:nil];
</code></pre>

<p>创建Peripheral管理器后，Peripheral管理器会调用代理对象的peripheralManagerDidUpdateState:方法。我们需要实现这个方法来确保本地设备支持BLE。</p>

<pre><code>- (void)peripheralManagerDidUpdateState:(CBPeripheralManager *)peripheral
{
    NSLog(@"Peripheral Manager Did Update State");
    switch (peripheral.state) {
        case CBPeripheralManagerStatePoweredOn:
            NSLog(@"CBPeripheralManagerStatePoweredOn");
            break;

        case CBPeripheralManagerStatePoweredOff:
            NSLog(@"CBPeripheralManagerStatePoweredOff");
            break;

        case CBPeripheralManagerStateUnsupported:
            NSLog(@"CBPeripheralManagerStateUnsupported");
            break;

        default:
            break;
    }
}
</code></pre>

<h4>设置服务及特性</h4>

<p>一个本地Peripheral数据库以类似树的结构来组织服务及特性。所以，在设置服务及特性时，我们将其组织成树结构。</p>

<p>一个Peripheral的服务和特性通过128位的蓝牙指定的UUID来标识，该标识是一个CBUUID对象。虽然SIG组织没的预先定义所有的服务与特性的UUID，但是SIG已经定义并发布了一些通过的UUID，这些UUID被简化成16位以方便使用。例如，SIG定义了一个16位的UUID作为心跳服务的标识(180D)。</p>

<p>CBUUID类提供了方法，以从字符串中生成一个CBUUID对象。当字条串使用的是预定义的16位UUID时，Core Bluetooth使用它时会预先自动补全成128位的标识。</p>

<pre><code>CBUUID *heartRateServiceUUID = [CBUUID UUIDWithString:@"180D"];
</code></pre>

<p>当然我们也可以自己生成一个128位的UUID来标识我们的服务与特性。在命令行中使用uuidgen命令会生成一个128位的UUID字符串，然后我们可以使用它来生成一个CBUUID对象。</p>

<p>生成UUID对象后，我们就可以用这个对象来创建我们的服务及特性，然后再将它们组织成树状结构。</p>

<p>创建特性的代码如下所示</p>

<pre><code>CBUUID *characteristicUUID1 = [CBUUID UUIDWithString:@"C22D1ECA-0F78-463B-8C21-688A517D7D2B"];
CBUUID *characteristicUUID2 = [CBUUID UUIDWithString:@"632FB3C9-2078-419B-83AA-DBC64B5B685A"];

CBMutableCharacteristic *character1 = [[CBMutableCharacteristic alloc] initWithType:characteristicUUID1 properties:CBCharacteristicPropertyRead value:nil permissions:CBAttributePermissionsReadable];

CBMutableCharacteristic *character2 = [[CBMutableCharacteristic alloc] initWithType:characteristicUUID2 properties:CBCharacteristicPropertyNotify value:nil permissions:CBAttributePermissionsWriteable];
</code></pre>

<p>我们需要设置特性的属性、值及权限。属性及权限值确定了属性值是可读的还是可写的，及连接的Central端是否可以订阅特性的值。另外，如果我们指定了特性的值，则这个值会被缓存且其属性及权限被设置成可读的。如果我们要让特性的值是可写的，或者期望属性所属的服务的生命周期里这个值可以被修改，则必须指定值为nil。</p>

<p>创建的特性之后，我们便可以创建一个与特性相关的服务，然后将特性关联到服务上，如下代码所示:</p>

<pre><code>CBUUID *serviceUUID = [CBUUID UUIDWithString:@"3655296F-96CE-44D4-912D-CD83F06E7E7E"];
CBMutableService *service = [[CBMutableService alloc] initWithType:serviceUUID primary:YES];
service.characteristics = @[character1, character2];    // 组织成树状结构
</code></pre>

<p>上例中primary参数传递的是YES，表示这是一个主服务，即描述了一个设备的主要功能且能被其它服务引用。与之相对的是次要服务(secondary service)，其只在引用它的另一个服务的上下文中描述一个服务。</p>

<h4>发布服务及特性</h4>

<p>创建服务及特性后交将其组织成树状结构后，我们需要将这些服务发布到设备的本地数据库上。我们可以使用CBPeripheralManager的addService:方法来完成此工作。如下代码所示：</p>

<pre><code>[peripheralManager addService:service];
</code></pre>

<p>在调用些方法发布服务时，CBPeripheralManager对象会调用它的代理的peripheralManager:didAddService:error:方法。如果发布过程中出现错误导致无法以布，则可以实现该代理方法来处理错误，如下代码所示：</p>

<pre><code>- (void)peripheralManager:(CBPeripheralManager *)peripheral didAddService:(CBService *)service error:(NSError *)error
{
    NSLog(@"Add Service");

    if (error)
    {
        NSLog(@"Error publishing service: %@", [error localizedDescription]);
    }
}
</code></pre>

<p>在将服务与特性发布到设备数据库后，服务将会被缓存，且我们不能再修改这个服务。</p>

<h4>广告服务</h4>

<p>处理完以上步骤，我们便可以将这些服务广告给对服务感兴趣的Central端。我们可以通过调用CBPeripheralManager实例的startAdvertising:方法来完成这一操作，如下代码所示：</p>

<pre><code>[peripheralManager startAdvertising:@{CBAdvertisementDataServiceUUIDsKey: @[service.UUID]}];
</code></pre>

<p>startAdvertising:的参数是一个字典，Peripheral管理器支持且仅支持两个key值：CBAdvertisementDataLocalNameKey与CBAdvertisementDataServiceUUIDsKey。这两个值描述了数据的详情。key值所对应的value期望是一个表示多个服务的数组。</p>

<p>当广告服务时，CBPeripheralManager对象会调用代码对象的peripheralManagerDidStartAdvertising:error:方法，我们可以在此做相应的处理，如下代码所示：</p>

<pre><code>- (void)peripheralManagerDidStartAdvertising:(CBPeripheralManager *)peripheral error:(NSError *)error
{
    NSLog(@"Start Advertising");

    if (error)
    {
        NSLog(@"Error advertising: %@", [error localizedDescription]);
    }
}
</code></pre>

<p>广告服务之后，Central端便可以发现设备并初始化一个连接。</p>

<h4>对Central端的读写请求作出响应</h4>

<p>在与Central端进行连接后，可能需要从其接收读写请求，我们需要以适当的方式作出响应。</p>

<p>当连接的Central端请求读取特性的值时，CBPeripheralManager对象会调用代理对象的peripheralManager:didReceiveReadRequest:方法，代理方法提供一个CBATTRequest对象以表示Central端的请求，我们可以使用它的属性来填充请求。下面代码简单展示了这样一个过程：</p>

<pre><code>- (void)peripheralManager:(CBPeripheralManager *)peripheral didReceiveReadRequest:(CBATTRequest *)request
{
    // 查看请求的特性是否是指定的特性
    if ([request.characteristic.UUID isEqual:cha1.UUID])
    {
        NSLog(@"Request character 1");

        // 确保读请求所请求的偏移量没有超出我们的特性的值的长度范围
        // offset属性指定的请求所要读取值的偏移位置
        if (request.offset &gt; cha1.value.length)
        {
            [peripheralManager respondToRequest:request withResult:CBATTErrorInvalidOffset];
            return;
        }

        // 如果读取位置未越界，则将特性中的值的指定范围赋给请求的value属性。
        request.value = [cha1.value subdataWithRange:(NSRange){request.offset, cha1.value.length - request.offset}];

        // 对请求作出成功响应
        [peripheralManager respondToRequest:request withResult:CBATTErrorSuccess];
    }
}
</code></pre>

<p>在每次调用代理对象的peripheralManager:didReceiveReadRequest:时调用respondToRequest:withResult:方法以对请求做出响应。</p>

<p>处理写请求类似于上述过程，此时会调用代理对象的peripheralManager:didReceiveWriteRequests:方法。不同的是代理方法会给我们一个包含一个或多个CBATTRequest对象的数组，每一个都表示一个写请求。我们可以使用请求对象的value属性来给我们的特性属性赋值，如下代码所示：</p>

<pre><code>- (void)peripheralManager:(CBPeripheralManager *)peripheral didReceiveWriteRequests:(NSArray *)requests
{
    CBATTRequest *request = requests[0];

    cha1.value = request.value;

    [peripheralManager respondToRequest:request withResult:CBATTErrorSuccess];
}
</code></pre>

<p>响应处理与请求类似。</p>

<h4>发送更新的特性值给订阅的Central端</h4>

<p>如果有一个或多个Central端订阅了我们的服务的特性时，当特性发生变化时，我们需要通知这些Central端。为此，代理对象需要实现peripheralManager:central:didSubscribeToCharacteristic:方法。如下所示：</p>

<pre><code>- (void)peripheralManager:(CBPeripheralManager *)peripheral central:(CBCentral *)central didUnsubscribeFromCharacteristic:(CBCharacteristic *)characteristic
{
    NSLog(@"Central subscribed to characteristic %@", characteristic);

    NSData *updatedData = characteristic.value;

    // 获取属性更新的值并调用以下方法将其发送到Central端
    // 最后一个参数指定我们想将修改发送给哪个Central端，如果传nil，则会发送给所有连接的Central
    // 将方法返回一个BOOL值，表示修改是否被成功发送，如果用于传送更新值的队列被填充满，则方法返回NO
    BOOL didSendValue = [peripheralManager updateValue:updatedData forCharacteristic:(CBMutableCharacteristic *)characteristic onSubscribedCentrals:nil];

    NSLog(@"Send Success ? %@", (didSendValue ? @"YES" : @"NO"));
}
</code></pre>

<p>在上述代码中，当传输队列有可用的空间时，CBPeripheralManager对象会调用代码对象的peripheralManagerIsReadyToUpdateSubscribers:方法。我们可以在这个方法中调用updateValue:forCharacteristic:onSubscribedCentrals:来重新发送值。</p>

<p>我们使用通知来将单个数据包发送给订阅的Central。当我们更新订阅的Central时，我们应该通过调用一次updateValue:forCharacteristic:onSubscribedCentrals:方法将整个更新的值放在一个通知中。</p>

<p>由于特性的值大小不一，所以不是所有值都会被通知传输。如果发生这种情况，需要在Central端调用CBPeripheral实例的readValueForCharacteristic:方法来处理，该方法可以获取整个值。</p>

<h2>Central(Client)端操作</h2>

<p>一个Central端主要包含以下操作：</p>

<ol>
<li>启动一个Central端管理器对象</li>
<li>搜索并连接正在广告的Peripheral设备</li>
<li>在连接到Peripheral端后查询数据</li>
<li>发送一个对特性值的读写请求到Peripheral端</li>
<li>当Peripheral端特性值改变时接收通知</li>
</ol>


<p>我们将在下面结合代码对每一步分别进行讲解</p>

<h4>启动一个Central管理器</h4>

<p>CBCentralManager对象在Core Bluetooth中表示一个本地Central设备，我们在执行任何BLE交互时必须分配并初始化一个Central管理器对象。创建代码如下所示：</p>

<pre><code>// 指定当前类为代理对象，所以其需要实现CBCentralManagerDelegate协议
// 如果queue为nil，则Central管理器使用主队列来发送事件
centralManager = [[CBCentralManager alloc] initWithDelegate:self queue:nil options:nil];
</code></pre>

<p>创建Central管理器时，管理器对象会调用代理对象的centralManagerDidUpdateState:方法。我们需要实现这个方法来确保本地设备支持BLE。</p>

<pre><code>- (void)centralManagerDidUpdateState:(CBCentralManager *)central
{
    NSLog(@"Central Update State");

    switch (central.state) {
        case CBCentralManagerStatePoweredOn:
            NSLog(@"CBCentralManagerStatePoweredOn");
            break;

        case CBCentralManagerStatePoweredOff:
            NSLog(@"CBCentralManagerStatePoweredOff");
            break;

        case CBCentralManagerStateUnsupported:
            NSLog(@"CBCentralManagerStateUnsupported");
            break;

        default:
            break;
    }
}
</code></pre>

<h4>发现正在广告的Peripheral设备</h4>

<p>Central端的首要任务是发现正在广告的Peripheral设备，以备后续连接。我们可以调用CBCentralManager实例的scanForPeripheralsWithServices:options:方法来发现正在广告的Peripheral设备。如下代码所示：</p>

<pre><code>// 查找Peripheral设备
// 如果第一个参数传递nil，则管理器会返回所有发现的Peripheral设备。
// 通常我们会指定一个UUID对象的数组，来查找特定的设备
[centralManager scanForPeripheralsWithServices:nil options:nil];
</code></pre>

<p>在调用上述方法后，CBCentralManager对象在每次发现设备时会调用代理对象的centralManager:didDiscoverPeripheral:advertisementData:RSSI:方法。</p>

<pre><code>- (void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary *)advertisementData RSSI:(NSNumber *)RSSI
{
    NSLog(@"Discover name : %@", peripheral.name);

    // 当我们查找到Peripheral端时，我们可以停止查找其它设备，以节省电量
    [centralManager stopScan];

    NSLog(@"Scanning stop");
}
</code></pre>

<h4>连接Peripheral设备</h4>

<p>在查找到Peripheral设备后，我们可以调用CBCentralManager实例的connectPeripheral:options:方法来连接Peripheral设备。如下代码所示</p>

<pre><code>[centralManager connectPeripheral:peripheral options:nil];
</code></pre>

<p>如果连接成功，则会调用代码对象的centralManager:didConnectPeripheral:方法，我们可以实现该方法以做相应处理。另外，在开始与Peripheral设备交互之前，我们需要设置peripheral对象的代理，以确保接收到合适的回调。</p>

<pre><code>- (void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral
{
    NSLog(@"Peripheral Connected");

    peripheral.delegate = self;
}
</code></pre>

<h4>查找所连接Peripheral设备的服务</h4>

<p>建立到Peripheral设备的连接后，我们就可以开始查询数据了。首先我们需要查找Peripheral设备中可用的服务。由于Peripheral设备可以广告的数据有限，所以Peripheral设备实际的服务可能比它广告的服务要多。我们可以调用peripheral对象的discoverServices:方法来查找所有的服务。如下代码所示：</p>

<pre><code>[peripheral discoverServices:nil];
</code></pre>

<p>参数传递nil可以查找所有的服务，但一般情况下我们会指定感兴趣的服务。</p>

<p>当调用上述方法时，peripheral会调用代理对象的peripheral:didDiscoverServices:方法。Core Bluetooth创建一个CBService对象的数组，数组中的元素是peripheral中找到的服务。</p>

<pre><code>- (void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(NSError *)error
{
    NSLog(@"Discover Service");

    for (CBService *service in peripheral.services)
    {
        NSLog(@"Discovered service %@", service);
    }
}
</code></pre>

<h4>查找服务中的特性</h4>

<p>假设我们已经找到感兴趣的服务，接下来就是查询服务中的特性了。为了查找服务中的特性，我们只需要调用CBPeripheral类的discoverCharacteristics:forService:方法，如下所示：</p>

<pre><code>NSLog(@"Discovering characteristics for service %@", service);
[peripheral discoverCharacteristics:nil forService:service];
</code></pre>

<p>当发现特定服务的特性时，peripheral对象会调用代理对象的peripheral:didDiscoverCharacteristicsForService:error:方法。在这个方法中，Core Bluetooth会创建一个CBCharacteristic对象的数组，每个元素表示一个查找到的特性对象。如下代码所示：</p>

<pre><code>- (void)peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(NSError *)error
{
    NSLog(@"Discover Characteristics");
    for (CBCharacteristic *characteristic in service.characteristics)
    {
        NSLog(@"Discovered characteristic %@", characteristic);
    }
}
</code></pre>

<h4>获取特性的值</h4>

<p>一个特性包含一个单一的值，这个值包含了Peripheral服务的信息。在获取到特性之后，我们就可以从特性中获取这个值。只需要调用CBPeripheral实例的readValueForCharacteristic:方法即可。如下所示：</p>

<pre><code>NSLog(@"Reading value for characteristic %@", characteristic);
[peripheral readValueForCharacteristic:characteristic];
</code></pre>

<p>当我们读取特性中的值时，peripheral对象会调用代理对象的peripheral:didUpdateValueForCharacteristic:error:方法来获取该值。如果获取成功，我们可以通过特性的value属性来访问它，如下所示：</p>

<pre><code>- (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error
{
    NSData *data = characteristic.value;

    NSLog(@"Data = %@", data);
}
</code></pre>

<h4>订阅特性的值</h4>

<p>虽然使用readValueForCharacteristic:方法读取特性值对于一些使用场景非常有效，但对于获取改变的值不太有效。对于大多数变动的值来讲，我们需要通过订阅来获取它们。当我们订阅特性的值时，在值改变时，我们会从peripheral对象收到通知。</p>

<p>我们可以调用CBPeripheral类的setNotifyValue:forCharacteristic:方法来订阅感兴趣的特性的值。如下所示：</p>

<pre><code>[peripheral setNotifyValue:YES forCharacteristic:characteristic];
</code></pre>

<p>当我们尝试订阅特性的值时，会调用peripheral对象的代理对象的peripheral:didUpdateNotificationStateForCharacteristic:error: 方法。如果订阅失败，我们可以实现该代理方法来访问错误，如下所示：</p>

<pre><code>- (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error
{
    ...

    if (error)
    {
        NSLog(@"Error changing notification state: %@", [error localizedDescription]);
    }
}
</code></pre>

<p>在成功订阅特性的值后，当特性值改变时，peripheral设备会通知我们的应用。</p>

<h4>写入特性的值</h4>

<p>一些场景下，我们需要写入特性的值。例如我们需要与BLE数字恒温器交互时，可能需要给恒温器提供一个值来设定房间的温度。如果特性的值是可写的，我们可以通过调用CBPeripheral实例的writeValue:forCharacteristic:type:方法来写入值。</p>

<pre><code>NSData *data = [NSData dataWithBytes:[@"test" UTF8String] length:@"test".length];
[peripheral writeValue:data forCharacteristic:characteristic type:CBCharacteristicWriteWithResponse];
</code></pre>

<p>当尝试写入特性值时，我们需要指定想要执行的写入类型。上例指定了写入类型是CBCharacteristicWriteWithResponse，表示peripheral让我们的应用知道是否写入成功。</p>

<p>指定写入类型为CBCharacteristicWriteWithResponse的peripheral对象，在响应请求时会调用代理对象的peripheral:didWriteValueForCharacteristic:error:方法。如果写入失败，我们可以在这个方法中处理错误信息。</p>

<h2>小结</h2>

<p>Core Bluetooth框架已经为我们封装了蓝牙通信的底层实现，我们只需要做简单的处理就可以在程序中实现基于蓝牙的通信。不过在游戏中，一般使用Game Kit中自带的蓝牙处理功能，以实现大数据量的通信。Core Bluetooth框架还是比较适合小数据量的通信。</p>

<h2>参考</h2>

<p><a href="https://developer.apple.com/library/ios/documentation/NetworkingInternetWeb/Conceptual/CoreBluetooth_concepts/AboutCoreBluetooth/Introduction.html">Core Bluetooth Programming Guide</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iBeacon技术初探]]></title>
    <link href="http://southpeak.github.io/blog/2014/07/27/ibeaconji-zhu-chu-tan/"/>
    <updated>2014-07-27T15:22:43+08:00</updated>
    <id>http://southpeak.github.io/blog/2014/07/27/ibeaconji-zhu-chu-tan</id>
    <content type="html"><![CDATA[<p>苹果在WWDC 2013上正式推出了iBeacon，并在iOS7设备上配备了该功能。苹果期望将其做为一种技术标准，这个标准允许移动App(包括iOS或Android设备)监听来自于iBeacon设备上的信号并做出响应。这种iBeacon设备配备有低功耗蓝牙(Bluetooth Low Energy, BLE)通信功能，并使用BLE向周围发送自己特有的ID，移动设备上的App在接收到该ID后可以做出相应的反应。比如，我们在店铺里设置iBeacon发射器，便可让应用接收到信息并将这一信息通知给服务器，服务器向我们的App返回与该店铺相关的产品或折扣信息。本质上讲，iBeacon技术允许移动应用了解它们在某个局部范围内的位置，并向用户分发基于位置的超文本上下文内容。本文将对iBeacon技术做个简要的介绍。</p>

<h2>低功耗蓝牙技术(Bluetooth Low Energy)</h2>

<p>iBeacon的底层通信技术是采用低功耗蓝牙技术，这种技术是在短距离范围内数据传输的无线区域网络技术。顾名思义，它即要求低功耗，又需要保证传统蓝牙技术的通信范围。</p>

<p>BLE与传统蓝牙有几点不同：</p>

<ol>
<li>耗电量：BLE是低耗电量的，iBeacon设备使用一个纽扣电池即可持续运作长达3年时间。</li>
<li>低成本：BLE的成本只相当于传统蓝牙设备的60%-80%</li>
<li>应用：BLE适用于只要求少量定期传输数据的简单应用。传统的蓝牙适用于需要持续通信和大量数据传输的复杂应用。</li>
</ol>


<p>BLE通信数据包主要由称为&#8221;Advertisements&#8221;的数据或小的数据包组成，并通过无线电波由Beacons或其它BLE设备以有规律的时间间隔来广播。BLE广告是一种单向通信(one-way communication)方法。希望被发现的Beacon设备可以以设定的时间间隔广播或&#8221;广告&#8221;自包含的数据包。这些数据包由智能手机等设备收集，并在设备上触发一些事件，如推送消息、提示等。</p>

<p>苹果iBeacon标准要求广播时间的间隔是100ms。频率超高越耗电，但可以让智能手机或其它监听设备越快地发现iBeacon。标准的BLE广播距离是100m，这使Beacon在室内位置跟踪场景下的效果更理想。</p>

<h2>监听Beacon区域</h2>

<p>Beacon区域监听使用iOS设备的内置无线电来检测用户何时在广告iBeacon信息的BLE设备附近。由于是地理位置的监听，当用户进入或在一个Beacon区域时，我们可以使用这些功能来生成提示或提供其它相关的信息。一个Beacon区域通过以下值的组合来进行标识：</p>

<ol>
<li>proximity UUID(全局唯一标识)：一个128位值，唯一标识一类或一个组织中的一个或多个Beacon。</li>
<li>major值，一个16位无符号整数，用于分组有相同proximity UUID值的相关的Beacon。</li>
<li>minor值，一个16位无符号整数，用于区分具有相同proximity UUID值和major的值。</li>
</ol>


<p>因为一个Beacon区域可以包含多个iBeacon设备，Beacon区域监听支持同时监听多个感兴趣的设备。例如，一个App为了在特定商场提高用户体验，可用使用相同的proximity UUID来监听商场的所有商铺。当用户进入一个商店时，App检测商铺的iBeacon设备并使用major和minor值来获取额外的信息，如用户进入哪家商店或用户在商店的哪个区域(注意：虽然每个iBeacon都必须有一个proximity UUID，但major和minor的值是可选的)。</p>

<h4>定义一个Beacon区域</h4>

<p>我们使用<strong>CLBeaconRegion</strong>类的初始化方法来定义一个beacon区域，并在系统中注册，以开启一个监听。当创建一个CLBeaconRegion对象时，我们指定需要监听的Beacon区域的proximityUUID, major和minor属性。我们必须提供一个唯一标识区域的字符串以便我们在代码中能引用它。注意一个区域的标识与Beacon标识信息无关。</p>

<p>为了注册一个beacon区域，调用CLLocationManager对象的startMonitoringForRegion方法。代码清单1是创建并注册的beacon区域的简单方法。</p>

<h6>代码清单1：创建和注册一个beacon区域</h6>

<pre><code>- (void)registerBeaconRegionWithUUID:(NSUUID *)proximityUUID andIdentifier:(NSString *)identifier
{
    CLBeaconRegion *beaconRegion = [[CLBeaconRegion alloc] initWithProximityUUID:proximityUUID identifier:identifier];

    [manager startMonitoringForRegion:beaconRegion];
}
</code></pre>

<p>App在注册并监听某个Beacon区域后，会立即开始监听此区域。当App监听到注册的Beacon区域时，系统会为App生成一个合适的区域事件。</p>

<h4>处理边界穿越事件</h4>

<p>当用户进入一个注册的Beacon区域时，CLLocationManager对象将调用其代理对象的locationManager:didEnterRegion:方法。类似的，当用户离开这个区域时，将调用代理对象的locationManager:didExitRegion:方法。注意，用户必须穿过区域边界来触发这些调用，如果用户已经在区域中，CLLocationManager对象将不会调用locationManager:didEnterRegion:。我们可以实现这些代理方法来提示用户或展示一个指定位置的UI。</p>

<p>我们可以设置Beacon区域的notifyOnEntry和notifyOnExit属性来指定哪个边界穿越事件应该通知给我们的App。例如，如果在用户离开区域时不需要通知App，则可以设置区域的notifyOnEntry属性为NO。</p>

<p>我们也可以在用户打开设备的屏幕时再通知用户已进入一个Beacon区域。我们只需要在注册Beacon区域时，简单的设置Beacon区域的notifyEntryStateOnDisplay属性为YES，以及设置notifyOnEntry属性为NO。为了防止多余的通知被发送给用户，只在进入一个区域时才发送一个本地通知。</p>

<p>当用户已经在注册的Beacon区域内时，App可以调用CLLocationManager类的startRangingBeaconsInRegion:方法来确定我们的设备与区域中的一个或多个iBeacon设备的相对距离，并在距离改变时被通知。(注意：我们总是在尝试查找区域内的iBeacon设备时调用CLLocationManager的类方法isRangingAvailable)。对于大多数程序来说，知道这个相对距离是很有用的。例如，想像一个在每个展品上安装了iBeacon设备的博物馆。如果我们使用这个博物馆相应的App，当我们走近某个展品时，就可以通过iBeacon来向我们的App发送关于展品的信息。</p>

<p>当指定Beacon区域的iBeacon设备进入范围、离开范围或相对距离改变时，CLLocationManager对象调用代理对象的locationManager:didRangeBeacons:inRegion:方法。这个代理方法提供一个CLBeacon对象的数组来表示当前设备范围内的iBeacon。iBeacon的数组根据离设备的相对距离来排序，最近的在最前面。我们可以使用这些对象中的信息来确定用户离每个iBeacon设备的距离。CLBeacon对象的proximity属性给出了到一个beacon的相对距离。</p>

<p><em>注：iBeacon的排列依赖于检测到的BLE无线信号的强度，以及这些信号受墙壁、门或其它物理实体的影响。当我们使用iBeacon时需要考虑这些影响因素。</em></p>

<p>代码清单2显示了如何使用一个Beacon的proximity属性来确定到用户设备的相对距离。</p>

<h6>代码清单2：确定用户设备与beacon的相对距离</h6>

<pre><code>- (void)locationManager:(CLLocationManager *)manager didRangeBeacons:(NSArray *)beacons inRegion:(CLBeaconRegion *)region
{
    if ([beacons count] &gt; 0)
    {
        CLBeacon *nearestExhibit = [beacons firstObject];

        if (CLProximityNear == nearestExhibit.proximity)
        {
            NSLog(@"%d", nearestExhibit.major.integerValue);
        }
        else
        {
            NSLog(@"test");
        }
    }
}
</code></pre>

<p>注意：当多个iBeacon设备广告了相同的proximityUUID, major和minor属性组合时，在locationManager:didRangeBeacons:inRegion:方法中它们可能会有不同的距离与精度。建议每一个beacon设备都是唯一标识的。</p>

<h2>在iOS设备中开启iBeacon功能</h2>

<p>支持使用BLE分享数据的iOS设备可以当作iBeacon设备来使用。由于应用必须运行于前台，因此iOS设备上的iBeacon支持主要用于测试目的和任何情况下都运行于前台的App。对于其它类型的iBeacon实现，我们必须从第三方的制造商那获取专用的iBeacon设备。</p>

<p>因为将iOS设备作为一个iBeacon设备需要使用Core Bluetooth framework，所以我们需要在XCode工程中链接CoreBluetooth.framework。同时在相关的资源文件中导入&lt;CoreBluetooth/CoreBluetooth.h>头文件。</p>

<p>要在一个iOS设备上创建和广告一个Beacon区域，首先我们需要生成一个128位的UUID作为我们的proximity UUID。我们可以在终端使用uuidgen命令来生成一个UUID。然后，我们使用这个UUID来创建一个Beacon区域，同时定义所需的major和minor值。代码清单3显示了如何创建一个新Beacon区域</p>

<h6>代码清单3</h6>

<pre><code>NSUUID *proximityUUID = [[NSUUID alloc] initWithUUIDString:@"D80415EC-AC22-4046-8497-4BDAC297323C"];

CLBeaconRegion *beaconRegion = [[CLBeaconRegion alloc] initWithProximityUUID:proximityUUID identifier:@"com.mycompany.myregion"];        
</code></pre>

<p>现在我们已经创建了一个Beacon区域，然后我们需要使用Core Bluetooth framework的CBPeripheralManager来广告我们的Beacon的proximity UUID(及major或minor值)。在Core Bluetooth中，一个peripheral是使用BLE来广告和分享数据的设备。广告Beacon的数据是其它设备能检测并排列我们的Beacon设备的唯一方法。</p>

<p>为了在Core Bluetooth中广告peripheral数据，我们调用CBPeripheralManager实例的startAdvertising:方法。这个方法需要广告数据的字典。然后我们创建一个CBPeripheralManager类的实例，并让其广告我们的Beacon来让其它设备监听。代码清单4所示了这一过程。</p>

<h6>代码清单4</h6>

<pre><code>NSDictionary *beaconPeripheralData = [beaconRegion peripheralDataWithMeasuredPower:nil];

manager = [[CBPeripheralManager alloc] initWithDelegate:self queue:nil options:nil];
[manager startAdvertising:beaconPeripheralData];
</code></pre>

<p><strong>重要：当我们创建一个peripheral管理对象时，peripheral管理对象会调用它的代理的peripheralManagerDidUpdateState:方法。我们必须实现这个代理方法以确保BLE在本地peripheral设备上可用。</strong></p>

<p>在广告我们的iBeacon后，我们必须在前台继续运行程序来广播所需要的蓝牙信号。</p>

<h2>小结</h2>

<p>iBeacon是苹果提出的近场定位技术，其目标直指NFC。在App中使用iBeacon并不复杂，苹果已经为我们解决了大部分的底层技术问题。我们只需要简单的创建一个Beacon区域并监听它，在代理对象中处理相应的事件即可。它的实质就是一种定位技术，其在室内导航方面前景光明，相信这一技术会在今后大有作为。</p>

<h2>参考</h2>

<ol>
<li><a href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/LocationAwarenessPG/Introduction/Introduction.html">Location and Maps Programming Guide</a></li>
<li><a href="http://www.cocoachina.com/applenews/devnews/2014/0115/7705.html">如何使用iOS 7的iBeacons来提高你的应用</a></li>
<li><a href="http://www.cocoachina.com/applenews/devnews/2014/0512/8377.html">开发使用 iBeacon 的 iOS 7 应用</a></li>
<li>代码示例：<a href="https://developer.apple.com/library/ios/samplecode/AirLocate/Introduction/Intro.html">AirLocate: Using CoreLocation to monitor, range, and configure your device as an iBeacon</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[URL加载系统之五：缓存、Cookies与协议]]></title>
    <link href="http://southpeak.github.io/blog/2014/07/20/urljia-zai-xi-tong-zhi-wu-:huan-cun-,-cookiesyu-xie-yi/"/>
    <updated>2014-07-20T22:56:30+08:00</updated>
    <id>http://southpeak.github.io/blog/2014/07/20/urljia-zai-xi-tong-zhi-wu-:huan-cun-,-cookiesyu-xie-yi</id>
    <content type="html"><![CDATA[<h2>缓存</h2>

<p>URL加载系统为请求提供了基于磁盘和内存的组合响应缓存。这个缓存让应用减少了对网络连接的依赖，提高了性能。</p>

<p>一个NSURLRequest实例通过设置缓存策略来指定本地缓存。默认的缓存策略是NSURLRequestUseProtocolCachePolicy，其行为是由协议指定的针对该协议最好的实现方式。另外几种缓存策略描述如下：</p>

<ol>
<li>NSURLRequestReloadIgnoringCacheData：URL加载系统将从服务端加载数据，而完全忽略缓存。</li>
<li>NSURLRequestReturnCacheDataElseLoad：URL加载系统使用缓存数据，忽略其过期时间；只有在没有缓存版本的时候才从源端加载数据。</li>
<li>NSURLRequestReturnCacheDataDontLoad：允许应用指定只有在缓存中的数据应该被返回。如果在创建NSURLConnection或NSURLDownload实例时使用这个缓存策略，如果响应没有在本地缓存中，则直接返回nil。这类似于使用离线模式，且从来不进行网络连接。</li>
</ol>


<p>需要注意的是，目前只有HTTP和HTTPS的响应还被缓存。</p>

<p>缓存最常用的场景是使用HTTP协议做网络请求，同时设置缓存策略为NSURLRequestUseProtocolCachePolicy。如果一个请求的NSCachedURLResponse不存在，则加载系统会从源端获取数据。如果请求的缓存响应存在于本地，则URL加载系统检查响应来确定它指定的内容必须被重新验证。如果内容必须验证，则加载系统发出一个HEAD请求到源端以确定资源是否已经改变。如果没有改变，则URL加载系统返回缓存响应对象。如果已经改变了，则URL加载系统从源端获取数据。</p>

<p>如果缓存响应对象没有指定内容必须被重新验证，则加载系统校验缓存响应对象的最大age或有效时间。如果缓存对象未过期，则加载系统返回缓存对象。如果响应过旧，则URL加载系统发起一个HEAD请求到源端查看资源是否已被修改。如果修改了，则URL加载系统从源端获取新的数据。否则，返回缓存响应对象。</p>

<p>默认情况下，连接的数据基于请求的缓存策略来进行缓存，同时由处理请求的NSURLProtocol子类来解析。如果我们需要对缓存做更精确的控制，我们可以实现一些代理方法来允许应用来确定请求是否应该缓存：</p>

<ol>
<li>对于NSURLSession数据和上传任务，实现URLSession:dataTask:willCacheResponse:completionHandler:方法。这个代理方法只用于数据请求和上传任务。而下载任务的缓存由指定的缓存策略来决定。</li>
<li>对于NSURLConnection，实现connection:willCacheResponse:方法</li>
</ol>


<p>对于NSURLSession，我们的代理方法调用一个完成处理器block来告知会话需要缓存什么东西。对于NSURLConnection，代理方法返回连接需要缓存的对象。不管是哪种情况，代理都会提供以下值之一：</p>

<ol>
<li>允许缓存的响应对象</li>
<li>新创建的响应对象，用于缓存被修改的响应</li>
<li>NULL，以阻止缓存</li>
</ol>


<p>代理方法也可以提供与NSCacheURLResponse对象相关的userInfo字典，将这些对象作为响应的一部分存储在缓存中。</p>

<p>需要注意的是，如果我们使用NSURLSession眀实现了代理方法，则代理方法必须总是调用提供的完成处理器，否则会导致内存泄露。</p>

<h2>Cookies</h2>

<p>由于HTTP协议是无状态的，客户端通常使用cookie来提供URL请求间数据的持久化存储。URL加载系统提供接口来创建和管理cookie，将cookie作为HTTP请求的一部分进行发送，并在解析一个服务端的响应时获取cookie。</p>

<p>NSHTTPCookie类封装了一个cookie，并提供了大量访问器来访问cookie的各种属性。该类同样提供了方法用于HTTP cookie头与NSHTTPCookie实例之间的互转。URL加载系统自动发送与NSURLRequest对象匹配的任何存储的cookie，除非该请求指明不需要发送cookie。同样，NSURLResponse对象是返回的cookie将根据当前设定的cookie接收策略来处理。</p>

<p>NSHTTPCookieStorage提供接口来管理NSHTTPCookie对象的集合。与MacOS不同的是，iOS的cookie不能在应用间共享。NSHTTPCookieStorage允许一个应用指定cookie接收策略。</p>

<h2>协议支持</h2>

<p>URL加载系统允许客户端程序扩展协议，以支持自定义的传输数据的方式。URL加载系统默认只支持http, https, file, ftp和data协议。</p>

<p>我们可以继承NSURLProtocol来实现一个自定义的协议，然后使用NSURLProtocol类的的registerClass:方法将其注册到URL加载系统中。当NSURLSession, NSURLConnection和NSURLDownload对象初始化一个NSURLRequest的连接时，URL加载系统以注册顺序的倒序来查询每一个注册类。每个类都将调用canInitWithRequest:方法，第一个返回YES的类将被用于处理请求。</p>

<p>如果自定义协议需要额外的属性业支持请求与响应，则通过创建NSURLRequest, NSMutableRequest和NSResponse类的类别来提供这些属性的访问器。NSURLProtocol类提供方法在这些访问器中设置和获取属性值。</p>

<p>URL加载系统负责在连接开始和完成时创建和释放NSURLProtocol实例。我们的应用不应该直接创建NSURLProtocol的实例。</p>

<p>当NSURLProtocol子类通过URL加载系统初始化时，它提供了一个实现NSURLProtocolClient协议的客户端对象。NSURLProtocol子类将消息从NSURLProtocolClient协议发送到客户端对象，来告诉URL加载系统它创建了响应，接收数据，重定向到新的URL，请求认证，完成加载等操作。如果自定义协议支持认证，还必须实现NSURLAuthenticationChallengeSender协议。</p>

<h4>参考</h4>

<p><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html">URL Loading System Programming Guide</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bonjour理论2：域命名约定、API及其操作]]></title>
    <link href="http://southpeak.github.io/blog/2014/07/20/bonjourde-yu-ming-ming-yue-ding-,-apiji-qi-cao-zuo/"/>
    <updated>2014-07-20T15:52:22+08:00</updated>
    <id>http://southpeak.github.io/blog/2014/07/20/bonjourde-yu-ming-ming-yue-ding-,-apiji-qi-cao-zuo</id>
    <content type="html"><![CDATA[<h2>域命名约定</h2>

<p>服务实例与服务类型的Bonjour名称与DNS域名相关。这里我们将介绍DNS域名，Bonjour本地“域”，和Bonjour服务实例与服务类型的命名规则。</p>

<h4>域名与DNS</h4>

<p>DNS使用specific-to-general命名方案来为域名命名。最能用的域是&#8221;.&ldquo;,称为根域名，这是类似于UNIX文件系统中的根目录&rdquo;/&ldquo;。所有其它域都在根域名的层次结构中。例如，域名www.apple.com.可以解析为根域&rdquo;.&ldquo;，其下包含顶级域名&#8221;com.&rdquo;,再下面是二级域&#8221;apple.com.&ldquo;, 其下就是&#8221;www.apple.com.&#8221;。下图显示了这种层次结构：</p>

<p><img src="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/NetServices/Art/names_01dns_2x.png" alt="image" /></p>

<p>在这棵倒树的顶部是根域。在其下面是一些顶级域：com., edu., org.等。在顶级域下面是一些二级域，如apple, darwin, zeroconf。这棵树可以无限延伸下去。</p>

<h4>Bonjour和本地链路</h4>

<p>Bonjour协议很大程度上都是在处理本地链路(网络的一部分)。一个主机的本地链路或才链路本地网络(link-lock network)包括主机本身及其它可以不修改IP分组数据就是交换包的主机。在实践中，这包含所有没被路由器分开的主机。</p>

<p>在Bonjour系统中，&#8221;local.&ldquo;用于标识在本地IP网络中应该使用IP多播查询来进行查找的名称。</p>

<p>注意：&#8221;local.&ldquo;不是一个真实的域。我们可以将&#8221;local.&#8221;当成一个伪域。它与传统的DNS域有一个根本的区别：其它域的名称是全局唯一的，而链路本地域名不是。www.apple.com在全球只有唯一的一个DNS入口。而以local.结尾的主机名是本地网络中由多播DNS响应者的集合管理的，所以命名范围就是&#8221;local.&rdquo;(本地)。所以只要不在同一个本地网络中，就可以有两台命名相同的主机，即使是在同一栋楼中。而在同一个本地网络中，也需要确保名称的唯一性。如果在本地网络中发生名称冲突，一个Bonjour主机会自动查找一个新的名称或让用户输入一个新的。</p>

<h4>现有服务类型的Bonjour名称</h4>

<p>Bonjour服务根据IP服务的现有网络标准(RFC 2782)来命名。Bonjour服务名结合服务类型和传输协议绑定以形成一个注册类型。注册类型用于注册一个服务并创建DNS资源记录。如果要在DNS资源记录中区分注册类型和域名，可以要注册类型每个组件前使用下划线。其格式如下</p>

<p><strong>_ServiceType._TransportProtocolName</strong></p>

<p>服务类型是该服务的官方IANA注册名称，如ftp,http或打印机。传输协议的名称是tcp或udp，取决于服务使用的传输协议。一个运行在TCP上的FTP服务注册类型应该是<em>ftp.</em>tcp，并将注册一个名称为<em>ftp.</em>tcp.local.的DNS PTR记录，以作为服务所在主机的多播DNS响应者。</p>

<h4>新服务的Bonjour名称</h4>

<p>如果我们正在设计一个新的协议以作为Bonjour网络服务来推广，则应该在IANA中注册它。</p>

<p>IANA目前要求每个每个注册的服务都与一个&#8221;众所周知的端口&#8221;或众所周知的端口范围相关联。例如，http的端口是80，所以我们在浏览器中访问一个站点时，程序都假设HTTP服务运行在80端口上，除非我们另行指定。</p>

<p>但在Bonjour中，我们不需要知道端口号。因为客户端程序通过对服务类型进行简单查询，就能发现我们的服务，因此不需要端口。</p>

<h4>服务实例的Bonjour名称</h4>

<p>服务实例名称是一种可读的字符串，因此，它们的名称具有描述性，并可以让用户重写我们提供的默认名称。由于它们是可浏览的，而不是类型化的，服务实例名可以是编码为UTF8的任何Unicode字符串，最多63个字节长度。</p>

<p>例如，一个在网络中分享音乐的程序可能使用本地用户名来分享服务(如Emille的曲库)。用户可以重写默认服务名，并将服务命名为Zealous Lizard&rsquo;s Tune Studio._music._tcp.local.</p>

<p>下图说明了一个Bonjour服务实例的名称结构。在树的顶部是域，如本地网络的local.。下一级是注册类型，它由前面加下划线的服务类型(_music)和传输协议(同样前面有开线)组成。在树的底部是可读的服务实例名，如Zealous Lizard&rsquo;s Tune Studio。完整的名称由底至顶，每个组件由&#8221;.&ldquo;分割。</p>

<p><img src="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/NetServices/Art/names_02services_2x.png" alt="image" /></p>

<h2>Bonjour的API架构</h2>

<p>Bonjour网络服务的API结构如下图所示：</p>

<p><img src="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/NetServices/Art/rendarch_04apilayers_2x.png" alt="image" /></p>

<p>其主要有这么几部分：
1. NSNetService和NSNetServiceBrowser类：在Foundation框架中
2. CFNetServices：Core Services中CFNetwork框架的一部分；
3. DNS Service Discovery for Java(OS X)
4. 底层DNS Service Discovery API：构建在BSD socket</p>

<p>所有这些API集合提供了发布、搜索和网络服务解析的基础方法。下面我们简单介绍一下这几个部分</p>

<h4>NSNetService和NSNetServiceBrowser</h4>

<p>NSNetService和NSNetServiceBrowser提供了服务搜索和发布的面向对象接口。NSNetService对象表示Bonjour服务的实例，用于客户端发布和服务搜索；NSNetServiceBrowser表示特定类型服务的浏览器。大多数Cocoa程序员应该使用这些类来处理需求。如果需要更多详细的控制，可以使用DNS Service Discovery API。</p>

<p>NSNetService和NSNetServiceBrowser被安排到默认的NSRunLoop对象中来异步执行发布、搜索和解析操作。所以NSNetService和NSNetServiceBrowser返回的结果都由代理对象来处理。这些对象必须与一个run loop相关联，但不必是默认的run loop。</p>

<h4>CFNetServices</h4>

<p>CFNetServices API位于Core Services框架中，提供Core Foundation样式的类型和函数来管理服务和服务搜索。CFNetServices定义了三个Core Foundation对象类型:</p>

<ol>
<li>CFNetService：服务实例的抽象表示，用于发布或其它用途。相关的函数提供了发布和解析服务的支持</li>
<li>CFNetServiceBrowser：表示特定域中特定类型服务的浏览者。通常只在基于Core Foundation编码时使用这个类型</li>
<li>CFNetServiceMonitor</li>
</ol>


<p>CFNetService和CFNetServiceBrowser对象通常在CFRunLoop中使用。为了获取结果，程序需要实现处理事件的回调函数，如新的服务产生和消失等。与NSNetService和NSNetServiceBrowser不同的是，CFNetServices类型可以不需要一个run loop，可以在需要的时候同步运行。但通常不建议同步使用。</p>

<h4>DNS Service Discovery</h4>

<p>DNS Service Discovery API声明在/usr/include/dns_sd.h中，它为Bonjour服务提供了低级别BSD socket通信。DNS Service Discovery作为软件与多播DNS响应者或DNS服务器之间的中介层。它为我们管理DNS响应者，让我们编写程序时专注于服务和服务浏览者而不是DNS资源记录。</p>

<p>由于DNS Service Discovery API是Darwin开源工程的一部分，我们应该在写跨平台代码使用它，或者在诸如在NSNetService这样的高级别API无法获取低级特性时使用它。</p>

<h2>Bonjour操作</h2>

<p>Bonjour的网络服务结构包含一个简单易用的机制来发布、搜索和使用基于IP的服务。Bonjour支持三种基础操作，每一种都是零配置网络服务所必须的：</p>

<ol>
<li>发布(Publication): 广告一个服务</li>
<li>搜索(Discovery): 浏览可用的服务</li>
<li>解析(Resolution): 将服务实例名转化为地址和端口</li>
</ol>


<p>下面将分别介绍这三个部分。</p>

<h4>Publication</h4>

<p>为了发布一个服务，程序或设备必须使用一个多播DNS响应者来注册服务，或者通过高级API，或者直接与响应者(mDNSResponser)通信。Bonjour同样支持在传统的DNS服务中存储记录。当注册服务后，会创建三个相关的DNS记录：服务记录(SRV), 指针记录(PTR)和文本记录(TXT)。其中TXT记录会包含额外的数据用于解析或使用服务，虽然这些数据通常是空的。</p>

<h5>服务记录</h5>

<p>服务记录将服务实例名称映射到实际使用服务所需要的信息。客户端通过持久化方式存储服务实例名以访问这些服务，并在连接的时候执行针对主机名和端口号的DNS查询。这个额外的indirection级提供了两个重要的特性</p>

<ol>
<li>服务由一个可读的名称标识，而不是域名和端口号</li>
<li>客户端可以在服务的端口号和IP地址变化时访问服务，只要服务名不变即可。</li>
</ol>


<p>SRV记录包含两部分信息来标识一个服务</p>

<ol>
<li>主机名</li>
<li>端口号</li>
</ol>


<p>主机名是服务可被发现的域名。用主机名代替IP地址的原因是一个主机可能对应多个IP地址，或者可以同时有IPv4地址和IPv6地址。使用主机名可以让所有这些情况被正确的处理。</p>

<p>端口号标识的服务的TCP或UDP端口号。</p>

<p>SRV记录以下面的规则来命名：</p>

<p><strong>&lt;Instance Name>.&lt;Service Type>.&lt;Domain></strong></p>

<p>&lt;Instance Name>是服务实例名称，可以是任何UTF-8编码的字符串，通常是可读的有意义的字符串</p>

<p>&lt;Service Type>是标准的IP协议名称，前面带有下划线，后面跟着传输协议(TCP/UDP，前缀也是下划线)。</p>

<p>&lt;Domain>是标准的DNS域名。这可能是一个特定的域名，如apple.com.，也可以是通用的以local.为后缀的域名(用于本地链路的服务)</p>

<p>下面是SRV记录的例子，它是一个运行在TCP上端口号为515上，名称为PrintsAlot的打印后台处理程序：</p>

<p><strong>PrintsAlot._printer._tcp.local. 120 IN src 0 0 515 blackhawk.local.</strong></p>

<p>这条记录将在本地链路的叫做blackhawk.local.的打印机的多播DNS响应者设备上被创建。初始的120是用于缓存的TTL值。两个0是分别表示权重和优先级，在传统DNS上选择多个与给定名匹配的记录时需要使用这两个值，而对于多播DNS，将忽略这两个值。</p>

<h5>指针记录</h5>

<p>PTR记录可以通过将实例的类型映射到服务的特定类型的实例的名字来开启服务搜索。这个记录添加了另一个indirection层，以便服务可以只通过查询使用服务类型标定的PTR记录就被找到。</p>

<p>这个记录只包含信息的一小块&mdash;服务实例的名称。PTR记录的命名与SRV记录类似，不过没有实例名，如下所示：</p>

<p><strong>&lt;Service Type>.&lt;Domain></strong></p>

<h5>文本记录</h5>

<p>TXT记录与相应的SRV记录有相同的名称，并且可以包含少量的关于服务实例的额外的信息，一般不超过100-200个字节。记录也可以是空的。例如，一个网络游戏可以在多人游戏中广告所使用的地图名称。如果需要传输大量的数据，主机需要与客户端建立一个连接并直接发送数据。</p>

<p>通常，这个记录用于运行在同一地址同一端口的多个服务上，例如在同一个打印服务器上运行的多个打印队列，在这种情况下，TXT记录中额外的信息可用于标识预期的打印队列。如下表所示：</p>

<p><img src="http://b140.photo.store.qq.com/psb?/V130i6W71atwfr/AFtWnv5ko6gDjydKCfEChHIKr1la*sMWMqfKcG8VTXg!/b/dCtmdVP4JAAA&amp;bo=TATAAAAAAAADAK0!&amp;rf=viewer_4" alt="image" /></p>

<p>这么做是必要的，因为服务类型曾经与众所周知的端口相关联。建议新的Bonjour协议的设计者在不同的动态分配的端口上来运行每一个服务的实例，而不是在相同的众所周知的端口号上运行它们(这种情况下还需要额外的信息来指定客户端试图通信的服务实例)。</p>

<p>TXT记录中的数据的特性和格式特定于每种服务的类型，所有每个新的服务类型需要为自己相关的TXT记录定义数据的格式，并将其作为协议规范的一部分发布。</p>

<h4>搜索</h4>

<p>服务搜索使用服务发布期间注册的DNS记录来查找特定类型的服务的所有实例。为了做到这一点，所有的应用执行一个匹配服务类型的PTR记录的查询。如_http._tcp，通常使用高级接口。运行于每个设备上的多播DNS响应者将使用服务实例名来返回PTR记录。以音乐共享服务为例，下图显示了搜索的过程</p>

<p><img src="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/NetServices/Art/rendarch_02discover_2x.png" alt="image" /></p>

<p>在搜索音乐共享服务的过程，主要有两步：</p>

<ol>
<li>客户端程序向标准多播地址224.0.0.251发出一个在local.域中服务类型为_music._tcp的查询。</li>
<li>网络中的每一个多播DNS响应者都将接收到这个请求，但只有音乐共享设备会使用一个PTR记录来作出响应。在这种情况下，PTR记录保存一个服务实例名Ed&rsquo;s Party Mix.<em>music.</em>tcp.local.，客户端程序可以从PTR记录中提取服务实例名然后将其添加到一个音乐服务器的离线列表中。</li>
</ol>


<h4>解析</h4>

<p>服务搜索通常只会发生一次，例如，当用户第一次选择打印机时。这个操作保存了服务实例名，和一个服务的任何给定实例的稳定的标识符。端口号，IP地址，主机名可能经常改变，但用户在每次连接服务时不需要再次选择一个打印机。因此，将一个服务名解析为socket信息只有在服务真正使用时才发生。</p>

<p>为了解析一个服务，程序使用服务名来执行SRV记录的DNS查询。多播DNS响应者使用包含当前信息的SRV记录来作出响应。下图演示了音乐共享实例中服务解析的这样一个过程：</p>

<p><img src="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/NetServices/Art/rendarch_03resolve_2x.png" alt="image" /></p>

<p>这个过程主要分为几步：</p>

<ol>
<li>解析进程发送一个DNS查询到多播地址224.0.0.251，查询Ed’s Party Mix._music._tcp.local.的SRV记录。</li>
<li>查询返回服务的主机名和端口号(eds-musicbox.local., 1010)</li>
<li>客户端发送一个IP地址的多播请求</li>
<li>请求解析为IP地址169.254.150.84.然后客户端使用这个IP地址和端口号来连接服务器。这个过程发生在服务被使用时，从而总是查找服务的最新地址和端口号。</li>
</ol>


<p>参考</p>

<p><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/NetServices/Introduction.html">Bonjour Overview</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bonjour理论1：基本概念]]></title>
    <link href="http://southpeak.github.io/blog/2014/07/19/bonjourji-ben-li-lun/"/>
    <updated>2014-07-19T11:38:39+08:00</updated>
    <id>http://southpeak.github.io/blog/2014/07/19/bonjourji-ben-li-lun</id>
    <content type="html"><![CDATA[<p>在过去的二十年里，IP协议已经成为计算机等硬件设备之间通信的基本协议。大部分计算机和其它网络设备都是基于TCP/IP进行通信的。在这种网络中，每个设备都需要一个唯一的IP地址，不管是手动设定的还是由DHCP服务器动态分配的。动态指定的地址是可以改变的，但是像打印机等设备是必须手动设定一个静态地址的，这样网络中的计算机才能连接到它们。然后网络管理员需要配置一个DNS服务器，这样计算机用户就不需要通过IP地址来连接打印机了。这样，一个看起来很小的工作需要比较复杂的配置。但是如果我们需要在自己家中搭建一个局域网，而我们对此一无所知的话，这就是个大问题了。即使对于专业的网络管理员，也需要去手动配置打印机。但我们很多时候并不希望去做这些配置，就可以直接连入局域网内去获取打印机、或在文件服务器、甚至游戏服务器去获取我们想要的东西。</p>

<p>我们希望找到可用的设备并从一个列表中选择它们，而不是必须知道每个服务名或IP地址。这便是Bonjour所需要解决的问题。它是基于IP的一组零配置网络的协议。零配置网络有很大的潜力。</p>

<p>假设我们带着笔记本电脑去客户的公司，这时我们需要打印一些东西。如果这家公司有一台支持Bonjour协议的打印机，那么只要两台设备在同一个局域网内，就可以直接打印。此时，我们的每户本会搜索到任何可用的设备。我们只需要打开文档，选择设备列表中的打印机，点击打印就可完成打印操作。图1演示了这样一个过程：</p>

<p><img src="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/NetServices/Art/about_01example_2x.png" alt="image" /></p>

<p>这种零配置网络能够满足手机游戏、家庭网络、分布式计算和其它很多网络应用的需求。</p>

<p>那么Bonjour到底是什么呢？</p>

<h2>Bonjour三要素</h2>

<p>Bonjour是由苹果提出的基于IP的无配置网络建议。它产生于ZEROCONF工作组的工作，是IETF的一部分。ZEROCONF工作组对于基于IP的零配置网络的需要主要有三个要求</p>

<ol>
<li>寻址(分配IP地址给主机)</li>
<li>命名(使用名字而非IP地址来表示主机)</li>
<li>服务搜索(自动搜索网络服务)</li>
</ol>


<p>Bonjour即是这些需求的一个解决方案。它允许服务提供商、硬件制造商和程序开发者在使用新的技术时只使用单一的网络协议&mdash;IP。网络用户不再需要指定IP地址和主机名，甚至不需要指定网络中访问设备的类型。用户只需要简单的查看有哪些网络服务可用，然后从列表中选择。程序能自动检测到所需要的服务或它们需要进行交互的其它程序，允许自动连接、通信和进行数据传输，而不需要用户的介入。</p>

<p>下面我们来分别看看Bonjour如何解决零配置网络的三个要素</p>

<h4>寻址</h4>

<p>寻址问题通过自分配链路本地寻址方法来解决。链路本地寻址(Link-local addressing)使用为本地网络保留的地址范围，特别是一个小的LAN或单独的LAN片断。IPv6标准将自分配链路本地寻址作为协议的一部分。而IPv4本身不包含链路本地寻址，因此零配置网络寻址的主要挑战是如何在IPv4中改进此功能。</p>

<p>在IPv4中，自分配寻址通过在链路本地范围内挑选一个随机的IP地址并对其进行测试。如果地址没有使用，则作为本地地址。如果已经使用了，计算机或其它设备将选择另一个随机地址并测试。</p>

<p>目前大多数主流操作系统都支持IPv4和IPv6的链路本地寻址。</p>

<h4>命名</h4>

<p>在本地网络中进行name-to-address转换操作建议的方案是使用多播DNS，其中DNS格式查询使用IP多播传送到本地网络中。因为这些DNS查询被发送到多播地址中，因此没有一个全局的DNS服务器来回答这个查询。每个服务或设备都可以提供自己的DNS功能，当前发现一个针对自己名称的查询时，它使用自己的地址来响应这个DNS查询。</p>

<p>Bonjour更进了一步。它在主机或iOS设备上包含一个响应来处理任何网络服务的多播DNS查询。这降低了中断应用来响应多播消息的压力。通过注册服务，Bonjour的mDNSResponder守护进程自动广告我们的服务是否可用，以便把我们名字的查询自动被引导到正确的IP地址和端口号上。</p>

<p>为了让name-to-address转换能正确的工作，需要一个本地网络的唯一的名字。与转换DNS主机名不同的是，这个本地名称只在本地网络或LAN段上有效。我们可以像自分配一个本地地址一样自分配一个本地名称，选中其中一个；如果这个名称没有使用，则：</p>

<ol>
<li>硬件制造商通过设备发送一个多播DNS查询并查看响应来确定其选中的名字是否已使用。如果有响应，则设备应该选择另外一个名字。没有用户界面的设备可以在默认名字后面添加一下大数直到这个名字是唯一的。例如，如果在网络中的默认名字是XYZ-LaserPrinter.local，则可以使用XYZ-LaserPrinter.local，XYZ-LaserPrinter-2.local，XYZ-LaserPrinter-3.local进行测试，直到名字唯一。</li>
<li>软件服务在注册Bonjour时提供一个名字，如果提供的名字已使用，则Bonjour会自动重命名我们的服务。</li>
</ol>


<p>在OS X中，用户可以在系统偏好设置的共享面板中设置本地主机名来为计算机设置一个主机名，在iOS中，主机名是自动产生的且不能配置。这个主机名可用于任何DNS主机名常规使用的地方，如Web浏览器、命令行工具等等。为了向系统表明名字是一个本地主机名，可在主机名后添加.local.，如Setve.local.即为一个本地主机名。</p>

<p>如果用户在浏览器中输入steve.local.，这将告诉系统多播一个请求以在本地网络中查询steve，而不是将其发送到常规DNS服务器。如果在本地网络中有一台支持Bonjour的计算机名字为steve，则用户的浏览器将发送正确的IP地址给它。这允许用户访问本地主机和服务崦不需要常规DNS服务。</p>

<h4>服务搜索</h4>

<p>Bonjour最后一个要素是服务搜索。服务搜索允许程序查找所有可用的特定类型的服务并维护一个命名服务及端口的列表。应用可以将服务主机名解析为IPv4和IPv6地址列表。</p>

<p>命名服务的列表在服务与其当前DNS名和端口中提供了一个indirection层。indirection允许程序保存一个可用服务的持久化列表并在使用服务前解析一个实际的网络地址。该列表允许服务被动态迁移，而不会产生大量的网络流量来宣告这个改变。</p>

<p>在Bonjour中服务搜索是通过&#8221;browsing&#8221;来实现的。一个多播DNS查询发送一个指定的服务类型和域，任何匹配的服务都会回复他们的名字。其结果就是一个可用服务的列表。这与传统的网络服务以设备为中心的思考很不一样。对于处理服务、网络设备和网络编程的的个人来讲，很容易习惯性认为服务基于物理硬件(services in terms of physical hardware)。
从设备为中心的角度来看，网络由许多设备或主机组成，每个包含一组服务。例如，网络可能由服务器和客户机组成。在一个设备为中心的浏览架构中，一个客户端向服务器查询哪些服务正在运行，获取一个列表(FTP, HTTP等)，并决定使用哪个服务。这个接口反映了物理系统组织的方式。但这不一定是用户在逻辑上希望的或想要的。</p>

<p>用户通常想要完成特定的任务，而不是查找设备列表来找出什么服务正在运行。让客户端只询问一次“什么打印服务可用？”比查询每个可用的设备来问“你正在运行什么服务”然后筛选结果查找打印服务来得更有意义。以设备为中心的方法不但耗时，而且需要大量的网络流量，且其中大部分是无用的。而以服务为中心的方法发送单个查询，只生成相关的回复。</p>

<p>此外，服务不与指定的IP或主机名绑定。例如，一个站点可能被多个有不同地址的服务器托管。在一个组织中，网络管理员可能需要将一个服务从一个服务器移到另一个服务器来做负载均衡。如果客户端存储了主机名，如果服务移到另一个不同的主机，则无法再连接。</p>

<p>Bonjour从面向服务的角度来看问题。它通过所需要的服务类型来查找，而不是主机名。应用存储的是服务实例名，而不是地址，所以如果IP地址、端口号，甚至主机名改变了，应用仍然可以连接。通过专注于服务而不是设备，用户的浏览体验将更有用且无故障。</p>

<h2>降低消耗</h2>

<p>服务器的寻址、命名和服务搜索可能会产生大量的网络流量，但Bonjour采取了一些措施来将流量降低到最少。这允许Bonjour达到AppleTalk的易用性，同时又避免了不必要的“繁琐”。Bonjour采用了多种机制来降低零配置的开销，包括缓存、禁止重复响应，指数回退和服务公告。下面我们将简单介绍下这几种机制。</p>

<h4>缓存</h4>

<p>Bonjour采用了多播DNS记录缓存来防止主机请求那些已请求过的信息。例如，当一个主机请求一个LPR打印后台的处理程序列表时，列表通过多播传回来，所有本地主机都将看到这个列表。下次本地网络中的一个主机需要一个打印后台处理程序的列表时，因为它已经缓存了这个列表，所以不需要再次发起请求。多播DNS响应者负责维护这个缓存；程序开发者不需要做任何事情来维护它</p>

<h4>禁止重复响应</h4>

<p>为了阻止重复响应相同的请求，Bonjour服务查询包含一个已知答案的列表。例如，如果主机正在浏览打印机，第一个查询不包含打印服务，但从可用打印服务器得到12个回复。下一次该主机查询打印服务时，查询包含已知服务器的列表。已经在列表中的打倒服务器将不做响应。</p>

<p>Bonjour以另一种方式来抑制重复响应。如果一个主机将要响应，但发现另一个主机已经响应了相同的信息，则主机会抑制它的响应。</p>

<p>程序开发者不需要采取任何措施来抑制重复发送，Bonjour会处理。</p>

<h4>指数回退和服务公告</h4>

<p>当主机浏览服务时，它不会不间断地发送查询来查看是否有新的服务。相反，主机会初始一个查询，后续会不断增加查询时间的间隔，如1s, 3s, 9s, 27s这样一个时长间隔，最后可能会长达1小时的间隔。</p>

<p>但这不意味着花费一个小时的时间间隔再来查看新的服务。当在网络中启动一个服务时，它会使用几次回退算法来通知它的存在。这样就将服务公告和搜索的网络流量保持在最小，而新的服务也会很快就知晓。</p>

<p>在一个Bonjour配置主机上运行的服务在注册到mDNSResponder守护程序时会自动发出公告。在其它硬件上的服务，如打印机，将使用指数回退算法来公告其存在，这样充分利用了Bonjour的优势。</p>

<p>参考</p>

<p><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/NetServices/Introduction.html">Bonjour Overview</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cover Flow特效实现]]></title>
    <link href="http://southpeak.github.io/blog/2014/07/18/cover-flowte-xiao-shi-xian/"/>
    <updated>2014-07-18T22:12:57+08:00</updated>
    <id>http://southpeak.github.io/blog/2014/07/18/cover-flowte-xiao-shi-xian</id>
    <content type="html"><![CDATA[<p><a href="http://www.cocoachina.com/bbs/read.php?tid=74500">原文</a>发表在cocoachina上，现在把它整理过来。</p>

<h2>Cover Flow介绍</h2>

<p>Cover flow是苹果首创的将多首歌曲的封面以3D界面的形式显示出来的方式。</p>

<p><img src="http://www.cocoachina.com/bbs/attachment/Fid_6/6_38018_be3432a30663e7e.png" alt="image" /></p>

<h4>随处可见的Cover Flow特效</h4>

<p>iTunes:在iTunes音乐中点击搜索框左边“查看”项第三个，即以cover flow形式显示专辑封面（前提是你得添加插图或音乐自带插图），也可以在全屏模式使用</p>

<p>iPhone/iPod Touch:在竖屏模式播放音乐，iPhone只会显示一张专辑的封面；但当用户将机身旋转为横屏模式后，则能看到多首歌曲的封面以3D界面的形式显示出来，用手指左右的滑动能够进行歌曲的选择，点击相应的专辑封面则会显示该张唱片的曲目，点击相应歌曲即可开始播放。</p>

<p>苹果官网:官网上有以Flash展示的cover flow界面iPod NANO3/4/5:基本类似于在iphone中的操作，利用触摸轮滑动使封面转换Safari</p>

<p>使用 Cover Flow，您可以像在 iTunes 中翻看专辑插图一样轻松地翻看网站。Cover Flow 可以将您的书签和历史记录显示为大图预览，这样您就能立即找到网站。要查看 Cover Flow 如何工作，请单击 Safari“书签”栏左端的打开书本图标来打开书签列表。在“精选”列表中选择“历史记录”或您要查看其标签的精选。使用水平滚动条来翻看网页预览。您还可以使用鼠标上的滚动按钮来翻看预览。如果您的触控板已配置为支持触控板手势，则您可以左右扫动。</p>

<h2>特效制作</h2>

<h4>方法一：UICoverFlowLayer</h4>

<p>正式的SDK并未包含UICoverFlowLayer，但是它仍然是标准的uikit。通过steve nygard的类转储(class-dump), 能从uikit框架中提取 UICoverFlowLayer头文件。</p>

<p>由于UICoverFlowLayer是私有的，无法应用于应用程序(无法通过苹果的审查)，所以在此简单介绍使用方法：</p>

<ol>
<li>将UICoverFlowLayer.h文件拷贝到工程中创建cover flow视图，并将UICoverFlowLayer图层分配到视图图层中</li>
<li>视图发送dragFlow:atPoint消息，以处理与Cover Flow图层的触摸和拖动的交互过程构建cover flow视图控制器，分配和初始化视图，并提供委托和数据源方法</li>
</ol>


<p>使用UICoverFlowLayer的方法如下代码所示</p>

<pre><code>UICoverFlowLayer *cfLayer = [[UICoverFlowLayer alloc] initWithFrame:frame numberOfCovers:count];

[[self layer] addSublayer:cfLayer];
</code></pre>

<h4>方法二：OpenFlow</h4>

<p>OpenFlow是一个用于实现Cover Flow特效的开源库，它是基于Quartz实现的，能很好的实现Cover Flow特效，同时又易于使用。</p>

<p>下载地址：<a href="https://github.com/thefaj/OpenFlow">https://github.com/thefaj/OpenFlow</a></p>

<p>使用OpenFlow的基本步骤如下：</p>

<ol>
<li>创建工程</li>
<li>添加OpenFlow源代码到工程中</li>
<li>添加QuartzCore和CoreGraphics框架到工程中</li>
<li>定义CoverFlowViewController(自定义)类</li>
<li>在CoverFlowViewController.h中导入”AFOpenFlowView.h”</li>
<li>实现AFOpenFlowViewDelegate类和AFOpenFlowDataSource协议</li>
</ol>


<p>定义CoverFlowViewController类的代码如下所示</p>

<pre><code>//  CoverFlowViewController.h
//  CoverFlow
//
//  Created by Avinash on 4/7/10.
//  Copyright Apple Inc 2010. All rights reserved.
//

#import "AFOpenFlowView.h"
@interface CoverFlowViewController : UIViewController  {
    // Queue to hold the cover flow p_w_picpath
    NSOperationQueue *loadImagesOperationQueue;
}
@end
</code></pre>

<p>实现CoverFlowViewController类</p>

<p>加载图片</p>

<pre><code>- (void)viewDidLoad {
    [super viewDidLoad];
     // loading p_w_picpath into the queue
    loadImagesOperationQueue = [[NSOperationQueue alloc] init];
    NSString *imageName;
    for (int i=0; i &lt; 10; i++) {
        imageName = [[NSString alloc] initWithFormat:@"cover_%d.jpg", i];
        [(AFOpenFlowView *)self.view setImage:[UIImage imageNamed:imageName] forIndex:i];
        [imageName release];
        NSLog(@"%d is the index",i); 
   }
    [(AFOpenFlowView *)self.view setNumberOfImages:10];
}
</code></pre>

<p>实现委托方法，以设置Cover Flow默认图片及通知哪幅图片被选中</p>

<pre><code>//delegate protocols
// delegate protocol to tell which image is selected
- (void)openFlowView:(AFOpenFlowView *)openFlowView selectionDidChange:(int)index{
    NSLog(@"%d is selected",index);
}
// setting the image 1 as the default pic
- (UIImage *)defaultImage{
    return [UIImage imageNamed:@"cover_1.jpg"];
}
</code></pre>

<p>修改xib文件中视图的类UIView为AFOpenFlowView(重要)</p>

<p>完成上述步骤之后，就可以运行一下程序看一下效果了。虽然与苹果的Cover Flow效果还是有点差距，但还是不错哦。</p>

<h4>方法三：FlowCover</h4>

<p>FlowCover也是一个开源库，它是基于OpenGL ES。FlowCover的源代码非常简单，只有FlowCoverView和DataCache两个类。这两个类的功能如下：</p>

<ol>
<li>FlowCoverView：定义主视图。这是一个OpenGL ES视点，可以被嵌套在其它视图中。</li>
<li>DataCache：提供一个简单的数据缓存方案，保存一定量的对象，当对象超过最大值时，旧的对象会被舍弃。</li>
</ol>


<p>使用FlowCover的基本步骤如下：</p>

<ol>
<li>创建工程</li>
<li>添加FlowCover源代码到工程中</li>
<li>然后就可以像用其它UIView一样使用FlowCoverView了</li>
</ol>


<p>FlowCover中需要实现FlowCoverViewDelegate协议，该协议中主要有三个方法：</p>

<pre><code>-(int)flowCoverNumberImages:(FlowCoverView *)view;
</code></pre>

<p>返回FlowCoverView视图中显示的图片数量</p>

<pre><code>-(UIImage *)flowCover:(FlowCoverView *)view cover:(int)cover;
</code></pre>

<p>返回FlowCoverView视图中用cover指定的图片</p>

<pre><code>-(void)flowCover:(FlowCoverView *)view didSelect:(int)cover;
</code></pre>

<p>当用户触击FlowCoverView中的cover时调用。</p>

<h4>方法四：Tapku框架</h4>

<p>Tapku库是一个开源的iOS框架，它包含CoverFlow, Calendar Grid, Char View等等API，总之还是一个比较强大的库。把Tapku加下工程中还是比较复杂的，有兴趣的童鞋可以去网上搜一下。</p>

<p>Tapku下载地址：<a href="https://github.com/devinross/tapkulibrary">https://github.com/devinross/tapkulibrary</a></p>

<p>Tapku中与Cover Flow相关的类主要有如下两个：</p>

<ol>
<li>TKCoverflowCoverView: 该类表示的是单个cover。相当于UITableViewCell</li>
<li>TKCoverflowView:该类相当于UITableView类，用来管理和显示cover flow中图片及实现cover flow效果。</li>
</ol>


<p>同时还有两个相关的协议：TKCoverflowViewDelegate， TKCoverflowViewDataSource，分别是 TKCoverflowView的代理及数据源。这两个协议分别有一个必须实现的方法，分别是
TKCoverflowViewDelegate协议的</p>

<pre><code>- (void) coverflowView:(TKCoverflowView*)coverflowView coverAtIndexWasBroughtToFront:(int)index;
</code></pre>

<p>TKCoverflowViewDataSource协议的</p>

<pre><code>- (void) coverflowView:(TKCoverflowView*)coverflowView coverAtIndexWasDoubleTapped:(int)index
</code></pre>

<p>在工程中使用Tapku的CoverFlow步骤如下</p>

<ol>
<li>创建工程</li>
<li>添加Tapku库到工程中(该步骤有点麻烦，而且Tapku库比较大，个人认为可以只把CoverFlow相关的类抽取出来直接用)。</li>
<li>新建一个视图控制器CoverflowViewController，在该控制器中添加如下代码</li>
</ol>


<p>在头文件CoverflowViewController.h中</p>

<pre><code>@interface CoverflowViewController : UIViewController &lt;TKCoverflowViewDelegate,TKCoverflowViewDataSource,UIScrollViewDelegate&gt; {
    TKCoverflowView *coverflow; 
    NSMutableArray *covers; // album covers p_w_picpath
    ......
}
</code></pre>

<p>在CoverflowViewController.m文件中主要有如下处理</p>

<pre><code>//创建视图
- (void) loadView{
   [super loadView];
    ......
    coverflow = [[TKCoverflowView alloc] initWithFrame:self.view.bounds];
    coverflow.autoresizingMask = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight;
    coverflow.coverflowDelegate = self;
    coverflow.dataSource = self;
    if([UIDevice currentDevice].userInterfaceIdiom == UIUserInterfaceIdiomPad){
       coverflow.coverSpacing = 100;
      coverflow.coverSize = CGSizeMake(300, 300);
    }
    [self.view addSubview:coverflow];
   ......
}
</code></pre>

<p>实现代理方法</p>

<pre><code>- (void) coverflowView:(TKCoverflowView*)coverflowView coverAtIndexWasBroughtToFront:(int)index{
}
//生成单个cover flow
- (TKCoverflowCoverView*) coverflowView:(TKCoverflowView*)coverflowView coverAtIndex:(int)index{
    TKCoverflowCoverView *cover = [coverflowView dequeueReusableCoverView];
    if(cover == nil){
       BOOL phone = [UIDevice currentDevice].userInterfaceIdiom == UIUserInterfaceIdiomPhone;
       CGRect rect = phone ? CGRectMake(0, 0, 224, 300) : CGRectMake(0, 0, 300, 600);

      cover = [[[TKCoverflowCoverView alloc] initWithFrame:rect] autorelease]; // 224
       cover.baseline = 224;  
    }
    cover.image = [covers objectAtIndex:index%[covers count]];
   return cover;
}
- (void) coverflowView:(TKCoverflowView*)coverflowView coverAtIndexWasDoubleTapped:(int)index{
   TKCoverflowCoverView *cover = [coverflowView coverAtIndex:index];
    if(cover == nil) return;
    [UIView beginAnimations:nil context:nil];
    [UIView setAnimationDuration:1];
    [UIView setAnimationTransition:UIViewAnimationTransitionFlipFromLeft forView:cover cache:YES];
    [UIView commitAnimations];
   NSLog(@"Index: %d",index);
}
</code></pre>

<h2>效果比较</h2>

<p>在效果上个人感觉Tapku会好些，渲染流畅，美中不足的是在快速拖动时，停止下来的时候会有抖动的感觉（当然快速拖动这一功能是否需要可视情况而定，如果将此功能禁掉，跟苹果自身的效果还是差不多的）。</p>

<p>OpenFlow的问题在于当改变图像时，新选中的图像会先放大并置于表层，然后才缓动到中间。这是其一个瑕疵。</p>

<p>总体感觉上来讲，苹果自身的CoverFlow的缓动效果还是最好的，有那种渐进渐出的效果，而如上几个开源的库其动画显得有点生硬，有兴趣的童鞋可以试着改进一下。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS中流(Stream)的使用]]></title>
    <link href="http://southpeak.github.io/blog/2014/07/17/ioszhong-liu-stream-de-shi-yong/"/>
    <updated>2014-07-17T23:30:26+08:00</updated>
    <id>http://southpeak.github.io/blog/2014/07/17/ioszhong-liu-stream-de-shi-yong</id>
    <content type="html"><![CDATA[<p>流提供了一种简单的方式在不同和介质中交换数据，这种交换方式是与设备无关的。流是在通信路径中串行传输的连续的比特位序列。从编码的角度来看，流是单向的，因此流可以是输入流或输出流。除了基于文件的流外，其它形式的流都是不可查找的，这些流的数据一旦消耗完后，就无法从流对象中再次获取。</p>

<p>在Cocoa中包含三个与流相关的类：NSStream、NSInputStream和NSOutputStream。NSStream是一个抽象基类，定义了所有流对象的基础接口和属性。NSInputStream和NSOutputStream继承自NSStream，实现了输入流和输出流的默认行为。下图描述了流的应用场景：</p>

<p><img src="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Streams/Articles/Art/stream_src_dest.gif" alt="image" /></p>

<p>从图中看，NSInputStream可以从文件、socket和NSData对象中获取数据；NSOutputStream可以将数据写入文件、socket、内存缓存和NSData对象中。这三处类主要处理一些比较底层的任务。</p>

<p>流对象有一些相关的属性。大部分属性是用于处理网络安全和配置的，这些属性统称为SSL和SOCKS代理信息。两个比较重要的属性是：</p>

<ol>
<li>NSStreamDataWrittenToMemoryStreamKey：允许输出流查询写入到内存的数据</li>
<li>NSStreamFileCurrentOffsetKey：允许操作基于文件的流的读写位置</li>
</ol>


<p>可以给流对象指定一个代理对象。如果没有指定，则流对象作为自己的代理。流对象调用唯一的代理方法stream:handleEvent:来处理流相关的事件：</p>

<ol>
<li>对于输入流来说，是有可用的数据可读取事件。我们可以使用read:maxLength:方法从流中获取数据</li>
<li>对于输出流来说，是准备好写入的数据事件。我们可以使用write:maxLength:方法将数据写入流</li>
</ol>


<p>Cocoa中的流对象与Core Foundation中的流对象是对应的。我们可以通过toll-free桥接方法来进行相互转换。NSStream、NSInputStream和NSOutputStream分别对应CFStream、CFReadStream和CFWriteStream。但这两者间不是完全一样的。Core Foundation一般使用回调函数来处理数据。另外我们可以子类化NSStream、NSInputStream和NSOutputStream，来自定义一些属性和行为，而Core Foundation中的流对象则无法进行扩展。</p>

<p>上面主要介绍了iOS中流的一些基本概念，我们下面将介绍流的具体使用，首先看看如何从流中读取数据。</p>

<h2>从输入流中读取数据</h2>

<p>从一个NSInputStream流中读取数据主要包括以下几个步骤：</p>

<ol>
<li>从数据源中创建和初始化一个NSInputStream实例</li>
<li>将流对象放入一个run loop中并打开流</li>
<li>处理流对象发送到其代理的事件</li>
<li>当没有更多数据可读取时，关闭并销毁流对象。</li>
</ol>


<h4>准备流对象</h4>

<p>要使用一个NSInputStream，必须要有数据源。数据源可以是文件、NSData对象和网络socket。创建好后，我们设置其代理对象，并将其放入到run loop中，然后打开流。代码清单1展示了这个准备过程.</p>

<h6>代理清单1</h6>

<pre><code>- (void)setUpStreamForFile:(NSString *)path
{
    NSInputStream *inputStream = [[NSInputStream alloc] initWithFileAtPath:path];
    inputStream.delegate = self;
    [inputStream scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];

    [inputStream open];
}
</code></pre>

<p>在流对象放入run loop且有流事件(有可读数据)发生时，流对象会向代理对象发送stream:handleEvent:消息。在打开流之前，我们需要调用流对象的scheduleInRunLoop:forMode:方法，这样做可以避免在没有数据可读时阻塞代理对象的操作。我们需要确保的是流对象被放入正确的run loop中，即放入流事件发生的那个线程的run loop中。</p>

<h4>处理流事件</h4>

<p>打开流后，我们可以使用streamStatus属性查看流的状态，用hasBytesAvailable属性检测是否有可读的数据，用streamError来查看流处理过程中产生的错误。</p>

<p>流一旦打开后，将会持续发送stream:handleEvent:消息给代理对象，直到流结束为止。这个消息接收一个NSStreamEvent常量作为参数，以标识事件的类型。对于NSInputStream对象，主要的事件类型包括NSStreamEventOpenCompleted、NSStreamEventHasBytesAvailable和NSStreamEventEndEncountered。通常我们会对NSStreamEventHasBytesAvailable更感兴趣。代理清单2演示了从流中获取数据的过程</p>

<h6>代理清单2</h6>

<pre><code>- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode
{
    switch (eventCode) {
        case NSStreamEventHasBytesAvailable:
        {
            if (!data) {
                data = [NSMutableData data];
            }

            uint8_t buf[1024];
            unsigned int len = 0;
            len = [(NSInputStream *)aStream read:buf maxLength:1024];  // 读取数据
            if (len) {
                [data appendBytes:(const void *)buf length:len];
            }
        }
            break;
    }
}
</code></pre>

<p>当NSInputStream在处理流的过程中出现错误时，它将停止流处理并产生一个NSStreamEventErrorOccurred事件给代理。我们同样的上面的代理方法中来处理这个事件。</p>

<h4>清理流对象</h4>

<p>当NSInputStream读取到流的结尾时，会发送一个NSStreamEventEndEncountered事件给代理，代理对象应该销毁流对象，此过程应该与创建时相对应，代码清单3演示了关闭和释放流对象的过程。</p>

<h6>代理清单3</h6>

<pre><code>- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode
{
    switch (eventCode) {
        case NSStreamEventEndEncountered:
        {
            [aStream close];
            [aStream removeFromRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];
            aStream = nil;
        }
            break;
    }
}
</code></pre>

<h2>写入数据到输出流</h2>

<p>类似于从输入流读取数据，写入数据到输出流时，需要下面几个步骤：</p>

<ol>
<li>使用要写入的数据创建和初始化一个NSOutputStream实例，并设置代理对象</li>
<li>将流对象放到run loop中并打开流</li>
<li>处理流对象发送到代理对象中的事件</li>
<li>如果流对象写入数据到内存，则通过请求NSStreamDataWrittenToMemoryStreamKey属性来获取数据</li>
<li>当没有更多数据可供写入时，处理流对象</li>
</ol>


<p>基本流程与输入流的读取差不多，我们主要介绍不同的地方</p>

<ol>
<li>数据可写入的位置包括文件、C缓存、程序内存和网络socket。</li>
<li>hasSpaceAvailable属性表示是否有空间来写入数据</li>
<li>在stream:handleEvent:中主要处理NSStreamEventHasSpaceAvailable事件，并调用流的write:maxLength方法写数据。代码清单4演示了这一过程。</li>
<li>如果NSOutputStream对象的目标是应用的内存时，在NSStreamEventEndEncountered事件中可能需要从内存中获取流中的数据。我们将调用NSOutputStream对象的propertyForKey:的属性，并指定key为NSStreamDataWrittenToMemoryStreamKey来获取这些数据。</li>
</ol>


<h6>代理清单4</h6>

<pre><code>- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode
{
    switch (eventCode) {
        case NSStreamEventHasSpaceAvailable:
        {
            uint8_t *readBytes = (uint8_t *)[data mutableBytes];
            readBytes += byteIndex;
            int data_len = [data length];
            unsigned int len = (data_len - byteIndex &gt;= 1024) ? 1024 : (data_len - byteIndex);
            uint8_t buf[len];

            (void)memcpy(buf, readBytes, len);

            len = [aStream write:(const uint_8 *)buf maxLength:len];
            byteIndex += len;
            break;
        }
    }
}
</code></pre>

<p>这里需要注意的是：当代理接收到NSStreamEventHasSpaceAvailable事件而没有写入任何数据到流时，代理将不再从run loop中接收该事件，直到NSOutputStream对象接收到更多数据，这时run loop会重启NSStreamEventHasSpaceAvailable事件。</p>

<h2>流的轮循处理</h2>

<p>在流的处理过程中，除了将流放入run loop来处理流事件外，还可以对流进行轮循处理。我们将流处理数据的过程放到一个循环中，并在循环中不断地去询问流是否有可用的数据供读取(hasBytesAvailable)或可用的空间供写入(hasSpaceAvailable)。当处理到流的结尾时，我们跳出循环结束流的操作。</p>

<p>具体的过程如代码清单5所示</p>

<p>代码清单5</p>

<pre><code>- (void)createNewFile {
    NSOutputStream *oStream = [[NSOutputStream alloc] initToMemory];
    [oStream open];

    ￼￼￼uint8_t *readBytes = (uint8_t *)[data mutableBytes];
    uint8_t buf[1024];
    int len = 1024;

    while (1) {
        if (len == 0) break;

        if ([oStream hasSpaceAvailable])
        {
            (void)strncpy(buf, readBytes, len);
            readBytes += len;
            if ([oStream write:(const uint8_t *)buf maxLength:len] == -1)
            {
                [self handleError:[oStream streamError]];
                break;
            }
            [bytesWritten setIntValue:[bytesWritten intValue]+len];
            len = (([data length] - [bytesWritten intValue] &gt;= 1024) ? 1024 : [data length] - [bytesWritten intValue]);
        }
    }
    NSData *newData = [oStream propertyForKey:NSStreamDataWrittenToMemoryStreamKey];

    if (!newData) {
        NSLog(@"No data written to memory!");
    } else {
        [self processData:newData];
    }

    [oStream close];
    [oStream release];
    oStream = nil;
}
</code></pre>

<p>这种处理方法的问题在于它会阻塞当前线程，直到流处理结束为止，才继续进行后面的操作。而这种问题在处理网络socket流时尤为严重，我们必须等待服务端数据回来后才能继续操作。因此，通常情况下，建议使用run loop方式来处理流事件。</p>

<h2>错误处理</h2>

<p>当流出现错误时，会停止对流数据的处理。一个流对象在出现错误时，不能再用于读或写操作，虽然在关闭前可以查询它的状态。</p>

<p>NSStream和NSOutputStream类会以几种方式来告知错误的发生：</p>

<ol>
<li>如果流被放到run loop中，对象会发送一个NSStreamEventErrorOccurred事件到代理对象的stream:handleEvent:方法中</li>
<li>任何时候，可以调用streamStatus属性来查看是否发生错误(返回NSStreamStatusError)</li>
<li>如果在通过调用write:maxLength:写入数据到NSOutputStream对象时返回-1，则发生一个写错误。</li>
</ol>


<p>一旦确定产生错误时，我们可以调用流对象的streamError属性来查看错误的详细信息。在此我们不再举例。</p>

<h2>设置Socket流</h2>

<p>在iOS中，NSStream类不支持连接到远程主机，幸运的是CFStream支持。前面已经说过这两者可以通过toll-free桥接来相互转换。使用CFStream时，我们可以调用CFStreamCreatePairWithSocketToHost函数并传递主机名和端口号，来获取一个CFReadStreamRef和一个CFWriteStreamRef来进行通信，然后我们可以将它们转换为NSInputStream和NSOutputStream对象来处理。</p>

<p>具体的处理流程我们会在后期详细讨论。</p>

<p>参考</p>

<p><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Streams/Streams.html">Stream Programming Guide</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[URL加载系统之四：认证与TLS链验证]]></title>
    <link href="http://southpeak.github.io/blog/2014/07/16/urljia-zai-xi-tong-zhi-si-:ren-zheng-yu-tlslian-yan-zheng/"/>
    <updated>2014-07-16T18:51:03+08:00</updated>
    <id>http://southpeak.github.io/blog/2014/07/16/urljia-zai-xi-tong-zhi-si-:ren-zheng-yu-tlslian-yan-zheng</id>
    <content type="html"><![CDATA[<p>一个NSURLRequest对象经常会遇到认证请求，或者需要从其所连接的服务端请求证书。当需要认证请求时，NSURLConnection、NSURLSession和NSURLDownload类会通知它们的代理对象，以便能正确地做处理。不过需要注意的是，URL加载系统只有在服务端响应包含WWW-Authenticate头时才会调用代理来处理认证请求，而类似于代理认证和TLS信任验证这样的认证类型则不需要这个头。</p>

<h2>确定如何响应一个认证请求</h2>

<p>如果一个NSURLRequest对象需要认证时，则认证请求方式取决于使用的对象的类型：</p>

<ol>
<li>如果请求是与NSURLSession对象关联，则所有认证请求都会传递给代理，而不考虑认证的类型。</li>
<li>如果请求是与NSURLConnection或NSURLDownload对象，则对象的代理接收一个connection:canAuthenticateAgainstProtectionSpace: (或者 download:canAuthenticateAgainstProtectionSpace:) 消息。这允许代理对象在尝试再次认证前分析服务端的属性，包括协议和认证方法。如果我们的代理对象不准备认证服务端的受保护空间，则返回NO，且系统尝试使用用户的keychain的信息进行认证。</li>
<li>如果NSURLConnection或NSURLDownload的代理对象没有实现connection:canAuthenticateAgainstProtectionSpace: (或者 download:canAuthenticateAgainstProtectionSpace:)方法，且保护空间使用客户端证书认证或服务端信任认证，则系统假设我们返回NO。而对象其它所有类型，系统都返回YES。</li>
</ol>


<p>下一步，如果我们的代理对象同意处理认证，但是没有有效的证书（不管是作为请求URL的一部分或者在NSURLCredentialStorage中共享），则代理以收到以下消息：</p>

<ol>
<li>URLSession:didReceiveChallenge:completionHandler:2. URLSession:task:didReceiveChallenge:completionHandler:3. connection:didReceiveAuthenticationChallenge:4. download:didReceiveAuthenticationChallenge:</li>
</ol>


<p>为了让连接能够继续，则代理对象有三种选择：</p>

<ol>
<li>提供认证证书</li>
<li>尝试在没有证书的情况下继续</li>
<li>取消认证查询</li>
</ol>


<p>为了确保操作的正确流程，传递给这些方法的NSURLAuthenticationChallenge实例会包含一些信息，包括是什么触发了认证查询、查询的尝试次数、任何先前尝试的证书、请求证书的NSURLProtectionSpace对象，及查询的发送者。</p>

<p>如果认证请求事先尝试认证且失败了(如用户在服务端修改了密码)，我们可以通过在认证请求调用proposedCredential来获取尝试凭据。代理可以使用这些证书来填充一个显示给用户的话框。</p>

<p>调用认证请求的previousFailureCount可以返回身份验证尝试次数，这些尝试包括不同认证协议的尝试请求。代理可以将这些方法提供给用户，以确定先前提供的证书是否失败，或限制最大认证尝试次数。</p>

<h2>响应认证请求</h2>

<p>前面说过三种响应我们响应connection:didReceiveAuthenticationChallenge:代理方法的方式，我们将逐一介绍：</p>

<h4>提供证书</h4>

<p>为了进行认证，程序需要使用服务端期望的认证信息创建一个NSURLCredential对象。我们可以调用authenticationMethod来确定服务端的认证方法，这个认证方法是在提供的认证请求的保护空间中。NSURLCredential支持一些方法：</p>

<ol>
<li>HTTP基本认证(NSURLAuthenticationMethodHTTPBasic)：需要用户名和密码。提示用户输入必要信息并使用credentialWithUser:password:persistence:方法创建一个NSURLCredential对象。</li>
<li>HTTP数字认证(NSURLAuthenticationMethodHTTPDigest):类似于基本认证，需要用户名和密码。提示用户输入必要信息并使用credentialWithUser:password:persistence:方法创建一个NSURLCredential对象。</li>
<li>客户端证书认证(NSURLAuthenticationMethodClientCertificate): 需要系统标识和所有服务端认证所需要的证书。然后使用credentialWithIdentity:certificates:persistence:来创建一个NSURLCredential对象。</li>
<li>服务端信任认证(NSURLAuthenticationMethodServerTrust)需要一个由认证请求的保护空间提供的信任。使用credentialForTrust:来创建一个NSURLCredential对象。</li>
</ol>


<p>在创建NSURLCredential对象后</p>

<ol>
<li>对于NSURLSession，使用提供的完成处理block将该对象传递给认证请求发送者</li>
<li>对于NSURLConnection和NSURLDownload，使用useCredential:forAuthenticationChallenge:方法将对象传递给认证请求发送者。</li>
</ol>


<h4>尝试在没有证书的情况下继续</h4>

<p>如果代理选择不提供证书，可以尝试继续操作：</p>

<ol>
<li>对于NSURLSession，传递下面的值给完成处理block:
 NSURLSessionAuthChallengePerformDefaultHandling:处理请求。尽管代理没有提供代理方法来处理认证请求
 NSURLSessionAuthChallengeRejectProtectionSpace:拒绝请求。依赖于服务端响应允许的认证类型，URL加载类可能多次调用这个代理方法。</li>
<li>对于NSURLConnection和NSURLDownload，在[challenge sender]中调用continueWithoutCredentialsForAuthenticationChallenge:。</li>
</ol>


<p>依赖于协议的实现，这种处理方法可能会导致连接失败而以送connectionDidFailWithError:消息，或者返回可选的不需要认证的URL内容。</p>

<h4>取消连接</h4>

<p>代理可以选择取消认证请求</p>

<ol>
<li>对于NSURLSession，传递NSURLSessionAuthChallengeCancelAuthenticationChallenge给完成处理block</li>
<li>对于NSURLConnection和NSURLDownload，在[challenge sender]中调用cancelAuthenticationChallenge:。代理接收connection:didCancelAuthenticationChallenge:消息，以提供用户反馈的机会。</li>
</ol>


<p>下面的代码演示了使用用户名和密码创建NSURLCredential对象来响应认证请求</p>

<pre><code>-(void)connection:(NSURLConnection *)connection didReceiveAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge
    {
    if ([challenge previousFailureCount] == 0)

    {
                NSURLCredential *newCredential;
        newCredential = [NSURLCredential credentialWithUser:[self preferencesName] password:[self preferencesPassword] persistence:NSURLCredentialPersistenceNone];
        [[challenge sender] useCredential:newCredential forAuthenticationChallenge:challenge];
    }

    else

    {           [[challenge sender] cancelAuthenticationChallenge:challenge];           // inform the user that the user name and password          // in the preferences are incorrect         [self showPreferencesCredentialsAreIncorrectPanel:self];        }

}
</code></pre>

<p>如果代理没有实现connection:didReceiveAuthenticationChallenge:，而请求需要认证，则有效的证书必须位于URL证书存储中或作为请求URL的一部分。如果证书无效或者认证失败，则底层实现会发送一个continueWithoutCredentialForAuthenticationChallenge:消息。</p>

<h2>执行自定义TLS链验证</h2>

<p>在NSURL系统的AIP中，TLS链验证由应用的认证代理方法来处理，但它不是提供证书给服务端以验证用户，而是在TLS握手的过程中校验服务端提供的证书，然后再告诉URL加载系统是否应该接受还是拒绝这些证书。</p>

<p>如果需要以非标准的方法(如接收一个指定的自标识的证书用于测试)来执行链验证，则应用必须如下处理：</p>

<ol>
<li>对于NSURLSession，实现URLSession:didReceiveChallenge:completionHandler:和URLSession:task:didReceiveChallenge:completionHandler:代理方法。如果实现了两者，由会话级别的方法负责处理认证。</li>
<li>对于NSURLConnection和NSURLDownload，实现connection:canAuthenticateAgainstProtectionSpace:和download:canAuthenticateAgainstProtectionSpace:方法，如果保护空间有一个NSURLAuthenticationMethodServerTrust类型的认证，则返回YES。然后，实现connection:didReceiveAuthenticationChallenge:或download:didReceiveAuthenticationChallenge:方法来处理认证。</li>
</ol>


<p>在认证处理代理方法中，我们需要确认认证保护空间是否有NSURLAuthenticationMethodServerTrust类型的认证，如果有，则从保护空间获取serverTrust信息。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[URL加载系统之三：NSURLConnection]]></title>
    <link href="http://southpeak.github.io/blog/2014/07/15/urljia-zai-xi-tong-zhi-san-:nsurlconnection/"/>
    <updated>2014-07-15T18:37:44+08:00</updated>
    <id>http://southpeak.github.io/blog/2014/07/15/urljia-zai-xi-tong-zhi-san-:nsurlconnection</id>
    <content type="html"><![CDATA[<p>NSURLConnection提供了简单的接口来创建和取消一个连接，并支持一个代理方法的集合来提供连接的响应，并对连接进行多方面的控制。这个类的方法可以分为5大类：URL加载、缓存管理、认证与证书、cookie存储、协议支持。</p>

<h2>创建一个连接</h2>

<p>NSURLConnection提供了三种方式来获取URL的内容：同步、异步使用完成处理器block、异步使用自定义的代理对象。</p>

<ol>
<li>使用同步请求时，一般是在后台线程中独占线程运行，我们可以调用sendSynchronousRequest:returningResponse:error: 方法来执行HTTP请求。当请求完成或返回错误时，该方法会返回。</li>
<li>如果我们不需要监听请求的状态，而只是在数据完成返回时执行一些操作，则可以调用sendAsynchronousRequest:queue:completionHandler:方法来执行一个异步操作，其中需要传递一个block来处理结果。</li>
<li>我们也可以创建一个代理对象来处理异步请求，此时我们需要实现以下方法：connection:didReceiveResponse:、connection:didReceiveData:、connection:didFailWithError:和connectionDidFinishLoading: 。这些方法在NSURLConnectionDelegate、NSURLConnectionDownloadDelegate和 NSURLConnectionDataDelegate协议中定义。</li>
</ol>


<p>代码清单1以代理对象异步请求为例，初始化了一个URL连接并实现代理方法来处理连接响应</p>

<pre><code>@interface Conn : NSObject
{
    NSURLConnection *theConnection;
    NSMutableData *receivedData;
}

@end

@implementation Conn

- (void)createConnection
{
    // 创建一个请求
    NSURLRequest *theRequest=[NSURLRequest requestWithURL:[NSURL URLWithString:@"http://www.apple.com/"]
                                              cachePolicy:NSURLRequestUseProtocolCachePolicy
                                          timeoutInterval:60.0];
    
    // 创建NSMutableData来保存接收到的数据
    receivedData = [NSMutableData dataWithCapacity: 0];
    
    // 使用theRequest创建一个连接并开始加载数据
    // 调用initWithRequest:delegate后会立即开始传输
    // 请求可以在connectionDidFinishLoading:或connection:didFailWithError:消息被发送前通过调用cancel来取消
    theConnection = [[NSURLConnection alloc] initWithRequest:theRequest delegate:self];
    
    if (!theConnection) {
        // 释放receivedData对象
        receivedData = nil;
        // 通知用户连接失败
    }
}

// 当服务端提供了有效的数据来创建NSURLResponse对象时，代理会收到connection:didReceiveResponse:消息。
// 这个代理方法会检查NSURLResponse对象并确认数据的content-type，MIME类型，文件 名和其它元数据。
// 需要注意的是，对于单个连接，我们可能会接多次收到connection:didReceiveResponse:消息；这咱情况发生在
// 响应是多重MIME编码的情况下。每次代理接收到connection:didReceiveResponse:时，应该重设进度标识
// 并丢弃之前接收到的数据。
- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response
{
    [receivedData setLength:0];
}

// 代理会定期接收到connection:didReceiveData:消息，该消息用于接收服务端返回的数据实体。该方法负责存储数据。
// 我们也可以用这个方法提供进度信息，这种情况下，我们需要在connection:didReceiveResponse:方法中
// 调用响应对象的expectedContentLength方法来获取数据的总长度。
- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data
{
    [receivedData appendData:data];
}

// 如果数据传输的过程中出现了错误，代理会接收到connection:didFailWithError:消息。其中error参数给出了错误信息。
// 在代理收到connection:didFailWithError:消息后，它不会再接收指定连接的代理消息。
- (void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error
{
    theConnection = nil;
    receivedData = nil;

    NSLog(@"Connection failed! Error - %@ %@", [error localizedDescription], [[error userInfo] objectForKey:NSURLErrorFailingURLStringErrorKey]);
}

// 如果成功获取服务端返回的所有数据，则代理会收到connectionDidFinishLoading:消息。
- (void)connectionDidFinishLoading:(NSURLConnection *)connection
{
    NSLog(@"Succeeded! Receive %lu bytes of data(unsigned long)",[receivedData length]);

    theConnection = nil;
    receivedData = nil;
}

@end
</code></pre>

<h2>发起一个POST请求</h2>

<p>我们可以像发起其它URL请求一样，发起一个HTTP或HTTPS POST请求。主要的区别在于我们必须先配置好NSMutableURLRequest对象，并将其作为参数传递给initWithRequest:delegate:方法。</p>

<p>另外，我们还需要构造请求的body数据。可以以下面三种方式来处理</p>

<ol>
<li>对于上传短小的内存数据，我们需要对已存在的数据块进行URL编码</li>
<li>如果是从磁盘中上传文件，则调用setHTTPBodyStream:方法来告诉NSMutableURLRequest从一个NSInputStream中读取并使用结果数据作为body的内容</li>
<li>对于大块的数据，调用CFStreamCreateBoundPair来创建流对象对，然后调用setHTTPBodyStream:方法来告诉NSMutableURLRequest使用这些流对象中的一个作为body内容的源。通过将数据写入其它流，可以一次发送一小块数据。</li>
</ol>


<p>如果要上传数据到一个兼容的服务器中，URL加载系统同样支持100（继续）状态码，这样允许一个上传操作在发生认证错误或其它失败时仍能继续。为了开启这个操作，可以设置请求对象的expect头为100-continue。</p>

<p>代码清单2展示了如何配置一个POST请求的NSMutableURLRequest对象</p>

<pre><code>- (void)setRequestForPost
{
    // 对于application/x-www-form-urlencoded类型的body数据，form域的参数由&amp;号分开，
    NSString *bodyData = @"name=Jane+Doe&amp;address=123+Main+St";
    NSMutableURLRequest *postRequest = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://www.apple.com"]];
    
    // 设置content-type为application/x-www-form-urlencoded
    [postRequest setValue:@"application/x-www-form-urlencoded" forHTTPHeaderField:@"Content-Type"];
    
    // 指定请求方法为POST
    [postRequest setHTTPMethod:@"POST"];
    [postRequest setHTTPBody:[NSData dataWithBytes:[bodyData UTF8String] length:strlen([bodyData UTF8String])]];
    
    // Initialize the NSURLConnection and proceed as described in
    // Retrieving the Contents of a URL
    
}
</code></pre>

<h2>使用Block来接收数据</h2>

<p>NSURLConnection类提供了类方法sendAsynchronousRequest:queue:completionHandler:，该方法可以以异常的方式向服务端发起请求，并在数据返回或发生错误/超时时调用block来处理。该方法需要一个请求对象，一个完成处理block，及block运行的队列。当请求完成或错误发生时，URL加载系统调用该block来处理结果数据或错误信息。</p>

<p>如果请求成功，则会传递一个NSData对象和一个NSURLResponse对象给block。如果失败，则传递一个NSError对象。</p>

<p>这个方法有两个限制</p>

<ol>
<li>对于需要认证的请求，只提供最小的支持。</li>
<li>没有办法来修改响应缓存和服务端重定向的默认行为。</li>
</ol>


<p>参考：
<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html">URL Loading System Programming Guide</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[URL加载系统之二：NSURLSession]]></title>
    <link href="http://southpeak.github.io/blog/2014/07/11/urljia-zai-xi-tong-zhi-er-:nsurlsession/"/>
    <updated>2014-07-11T22:48:27+08:00</updated>
    <id>http://southpeak.github.io/blog/2014/07/11/urljia-zai-xi-tong-zhi-er-:nsurlsession</id>
    <content type="html"><![CDATA[<p>NSURLSession及相关的类提供通过HTTP协议下载数据的API。该类提供了大量代理方法来支持认证和后台下载(程序未运行或挂起时)功能。</p>

<p>为了使用NSURLSession，我们的应用会创建一系列的会话，每个会话负责协调一组相关数据的传输任务。在每个会话中，我们的应用添加一系列的任务，每个任务都表示一个对指定URL的请求。与大多数网络API一样，NSURLSession  API是异步的。如果我们使用系统提供的代理，我们必须提供一个请求完成处理block，以便在请求成功或失败时返回数据给我们的应用。如果我们提供自定义的代理对象，则任务对象调用这些代理方法，并回传从服务端获取的数据（如果是文件下载，则当传输完成时调用）。</p>

<p>NSURLSession提供了status和progress属性，并作为额外的信息传递给代理。同时它支持取消、恢复、挂起操作，并支持断点续传功能。</p>

<p>要掌握NSURLSession的使用，我们需要了解下URL会话的一些内容</p>

<h2>URL会话</h2>

<p>在一个会话中的任务的行为取决于三个方面：</p>

<ol>
<li>session的类型（由创建会话时的配置对象确定）</li>
<li>任务的类型</li>
<li>当任务创建时应用是否在前台</li>
</ol>


<p>NSURLSession支持以下三种会话类型：</p>

<ol>
<li>默认会话：行为与其它下载URL的Foundation方法类似。使用基于磁盘的缓存策略，并在用户keychain中存储证书。</li>
<li>短暂会话(Ephemeral sessions)：不存储任何数据在磁盘中；所有的缓存，证书存储等都保存在RAM中并与会话绑定。这样，当应用结束会话时，它们被自动释放。</li>
<li>后台会话(Background sessions)：类似于默认会话，除了有一个独立的进程来处理所有的数据传输。</li>
</ol>


<p>在一个会话中，NSURLSession支持三种任务类型</p>

<ol>
<li>数据任务：使用NSData对象来发送和接收数据。数据任务可以分片返回数据，也可以通过完成处理器一次性返回数据。由于数据任务不存储数据到文件，所以不支持后台会话.</li>
<li>下载任务：以文件的形式接收数据，当程序不运行时支持后台下载</li>
<li>上传任务：通常以文件的形式发送数据，支持后台上传。</li>
</ol>


<p>NSURLSession支持在程序挂起时在后台传输数据。后台传输只由使用后台会话配置对象创建的会话提供。使用后台会话时，由于实际传输是在一个独立的进程中传输，且重启应用进程相当损耗资源，只有少量特性可以使用，所以有以下限制：</p>

<ol>
<li>会话必须提供事件分发的代理。</li>
<li>只支持HTTP和HTTPS协议</li>
<li>只支持上传和下载任务</li>
<li>总是伴随着重定义操作</li>
<li>如果当应用在后台时初始化的后台传输，则配置对象的discretionary属性为true</li>
</ol>


<p>在iOS中，当我们的应用不再运行时，如果后台下载任务完成或者需要证书，则系统会在后台自动重启我们的应用，同时调用UIApplicationDelegate对象的application:handlerEventsForBackgroundURLSession:completionHandler:方法。这个调用会提供启动的应用的session的标识。我们的应用应该存储完成处理器，使用相同的标识来创建后台配置对象，然后使用配置对象来创建会话。新的会话会与运行的后台activity关联。当会话完成后台下载任务时，会给会话代理发送一个URLSessioinDidFinishEventsForBackgroundURLSession:消息。我们的代理对象然后调用存储的完成处理器。</p>

<p>如果在程序挂起时有任何任务完成，则会调用URLSession:downloadTask:didFinishDownloadingToURL:方法。同样的，如果任务需要证书，则NSURLSession对象会在适当的时候调用URLSession:task:didReceiveChallenge:completionHandler: 和URLSession:didReceiveChallenge:completionHandler:方法。</p>

<p>这里需要注意的是必须为每个标识创建一个会话，共享相同标识的多个会话的行为是未定义的。</p>

<p>会话和任务对象实现了NSCopying协议：</p>

<ol>
<li>当应用拷贝一个会话或任务对象时，会获取相同对象的指针</li>
<li>当应用拷贝一个配置对象时，会获取一个可单独修改的新的对象</li>
</ol>


<h2>创建并配置NSURLSession</h2>

<p>我们下面举个简单的实例来说明一个NSURLSession与服务端的数据交互。</p>

<h6>代码清单1：声明三种类型会话对象</h6>

<pre><code>@interface URLSession : NSObject &lt;NSURLSessionDelegate, NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate&gt;

@property (nonatomic, strong) NSURLSession *backgroundSession;
@property (nonatomic, strong) NSURLSession *defaultSession;
@property (nonatomic, strong) NSURLSession *ephemeralSession;
@property (nonatomic, strong) NSMutableDictionary *completionHandlerDictionary;

- (void)addCompletionHandler:(CompletionHandlerType)handler forSession:(NSString *)identifier;

- (void)callCompletionHandlerForSession:(NSString *)identifier;

@end
</code></pre>

<p>NSURLSession提供了大量的配置选项，包括：</p>

<ol>
<li>支持缓存、cookie，认证及协议的私有存储</li>
<li>认证</li>
<li>上传下载文件</li>
<li>每个主机的配置最大数</li>
<li>超时时间</li>
<li>支持的TLS最小最小版本</li>
<li>自定义代理字典</li>
<li>控制cookie策略</li>
<li>控制HTTP管道行为</li>
</ol>


<p>由于大部分设置都包含在一个独立的配置对象中，所以我们可以重用这些配置。当我们初始一个会话对象时，我们指定了如下内容</p>

<ol>
<li>一个配置对象，用于管理其中的会话和任务的行为</li>
<li>一个代理对象，用于在收到数据时处理输入数据，及会话和任务中的其它事件，如服务端认证、确定一个资源加载请求是否应该转换成下载等。这个对象是可选的。但如果我们需要执行后台传输，则必须提供自定义代理。</li>
</ol>


<p>在实例一个会话对象后，我们不能改变改变配置或代理。</p>

<h6>代码清单2演示了如何创建一个会话</h6>

<pre><code>NSURLSessionConfiguration *defaultConfigObject = [NSURLSessionConfiguration defaultSessionConfiguration];
        
// 配置会话的缓存
NSString *cachePath = @"/MyCacheDirectory";
        
NSArray *pathList = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES);
NSString *path = [pathList objectAtIndex:0];
        
NSString *bundleIdentifier = [[NSBundle mainBundle] bundleIdentifier];
        
NSString *fullCachePath = [[path stringByAppendingPathComponent:bundleIdentifier] stringByAppendingPathComponent:cachePath];
        
NSLog(@"Cache path: %@", fullCachePath);
        
NSURLCache *cache = [[NSURLCache alloc] initWithMemoryCapacity:16384 diskCapacity:268435456 diskPath:cachePath];
defaultConfigObject.URLCache = cache;
defaultConfigObject.requestCachePolicy = NSURLRequestUseProtocolCachePolicy;
        
self.defaultSession = [NSURLSession sessionWithConfiguration:defaultConfigObject delegate:self delegateQueue:[NSOperationQueue mainQueue]];
</code></pre>

<p>除了后台配置对象外，我们可以重用会话的配置对象来创建新的会话，正如上面所讲的，拷贝一个配置对象会生成一个新的独立的配置对象。我们可以在任何时候安全的修改配置对象。当创建一个会话时，会话会对配置对象进行深拷贝，所以修改只会影响到新的会话。代理清单3演示了创建一个新的会话，这个会话使用重用的配置对象。</p>

<h6>代码清单3：重用会话对象</h6>

<pre><code>self.ephemeralSession = [NSURLSession sessionWithConfiguration:ephemeralConfigObject delegate:self delegateQueue:[NSOperationQueue mainQueue]];
        
ephemeralConfigObject.allowsCellularAccess = YES;
        
// ...
NSURLSession *ephemeralSessionWifiOnly = [NSURLSession sessionWithConfiguration:ephemeralConfigObject delegate:self delegateQueue:[NSOperationQueue mainQueue]];
</code></pre>

<p>使用NSURLSession获取数据基本就是两步：</p>

<ol>
<li>创建一个配置对象及基于这个对象的会话</li>
<li>定义一个请求完成处理器来处理获取到的数据。</li>
</ol>


<p>如果使用系统提供的代理，只需要代码清单4这几行代码即可搞定</p>

<h6>代码清单4：使用系统提供代理</h6>

<pre><code>NSURLSession *delegateFreeSession = [NSURLSession sessionWithConfiguration:defaultConfigObject delegate:self delegateQueue:[NSOperationQueue mainQueue]];
[delegateFreeSession dataTaskWithRequest:@"http://www.sina.com"
                               completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {    
                                   NSLog(@"Got response %@", response);
                               }];
</code></pre>

<p>只是系统提供的代理只提供有限的网络行为。如果应用需要更多的处理，如自定义认证或后台下载等，则需要使用自定义的代理。使用自定义代理来获取数据时，代理必须实现以下方法：</p>

<ol>
<li>URLSession:dataTask:didReceiveData: 从请求提供数据给我们的任务，一次一个数据块</li>
<li>URLSession:task:didCompleteWithError: 表示任务已经接受了所有的数据。</li>
</ol>


<p>如果我们在URLSession:dataTask:didReceiveData:方法返回后使用数据，则需要将数据存储在某个地方。</p>

<h6>代码清单5：演示了一个数据访问实例：</h6>

<pre><code>NSURL *url = [NSURL URLWithString:@"http://www.sina.com"];
NSURLSessionDataTask *dataTask = [self.defaultSession dataTaskWithURL:url];
[dataTask resume];
</code></pre>

<p>如果远程服务器返回的状态表示需要一个认证，且认证需要连接级别的处理时，NSURLSession将调用认证相关代理方法。这个具体我们后面文章将详细讨论。</p>

<h2>处理iOS后台Activity</h2>

<p>在iOS中使用NSURLSession时，当一个下载完成时，会自动启动我们的应用。应用的代理方法application:handleEventsForBackgroundURLSession:completionHandler: 负责创建一个合适的会话，存储请求完成处理器，并在会话调用会话代理的URLSessionDidFinishEventsForBackgroundURLSession: 方法时调用这个处理器。代码清单6与代码清单7演示了这个处理流程</p>

<h6>代码清单6：iOS后台下载的会话代理方法</h6>

<pre><code>- (void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession *)session
{
    NSLog(@"background url session %@", session);
    
    if (session.configuration.identifier)
    {
        [self callCompletionHandlerForSession:session.configuration.identifier];
    }
}

- (void)callCompletionHandlerForSession:(NSString *)identifier
{
    CompletionHandlerType handler = [self.completionHandlerDictionary objectForKey:identifier];
    
    if (handler) {
        [self.completionHandlerDictionary removeObjectForKey:identifier];
        
        handler();
    }
}
</code></pre>

<h6>代码清单7：iOS后台下载的App 代理方法</h6>

<pre><code>- (void)application:(UIApplication *)application handleEventsForBackgroundURLSession:(NSString *)identifier completionHandler:(void (^)())completionHandler
{
    NSURLSessionConfiguration *backgroundConfigObject = [NSURLSessionConfiguration backgroundSessionConfiguration:identifier];
    
    URLSession *sessionDelegate = [[URLSession alloc] init];
    
    NSURLSession *backgroundSession = [NSURLSession sessionWithConfiguration:backgroundConfigObject
                                                                    delegate:sessionDelegate
                                                               delegateQueue:[NSOperationQueue mainQueue]];
    
    [sessionDelegate addCompletionHandler:completionHandler forSession:identifier];
}
</code></pre>

<p>参考：</p>

<ol>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html">URL Loading System Programming Guide</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[URL加载系统之一：基本结构]]></title>
    <link href="http://southpeak.github.io/blog/2014/07/11/urljia-zai-xi-tong-zhi-%5B%3F%5D-:ji-ben-jie-gou/"/>
    <updated>2014-07-11T19:10:29+08:00</updated>
    <id>http://southpeak.github.io/blog/2014/07/11/urljia-zai-xi-tong-zhi-[?]-:ji-ben-jie-gou</id>
    <content type="html"><![CDATA[<p>URL加载系统是一组类和协议的集合，它允许我们的App访问URL指定的内容的。</p>

<p>URL加载系统的核心类是NSURL，该类提供了大量方法让我们操作URLs和它指向的资源。另外它还提供了一系列的类来加载URL的内容，上传数据到服务器，管理Cookie存储，控制响应缓存，处理认证存储和授权信息，及自定义协议扩展。</p>

<p>URL Loading System可支持以下协议</p>

<ol>
<li><a href="ftp://">ftp://</a></li>
<li><a href="http://">http://</a></li>
<li><a href="https://">https://</a></li>
<li>file://</li>
<li>data://</li>
</ol>


<p>另外它还支持代理服务和网关处理。</p>

<p>URL加载系统定义了用于加载URL的类，另外还定义了一些辅助类来修改加载类的行为。这些辅助类可以分为五大类：</p>

<ol>
<li>协议支持</li>
<li>授权与认证</li>
<li>Cookie存储</li>
<li>配置管理</li>
<li>缓存管理</li>
</ol>


<p>整个URL加载系统的结构如下图所示：</p>

<p><img src="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/URLLoadingSystem/Art/nsobject_hierarchy_2x.png" alt="image" /></p>

<p>下面对这张图做个简单的介绍</p>

<h2>URL Loading</h2>

<p>在这张图中，我们用得最多的就是URL Loading中的这几个类。这些类允许我们从URL指定的源获取内容。根据不同的需求，我们可以使用不同的类，这主要依赖于我们应用所支持的系统版本，以及我们希望内容是以文件的形式获取还是以数据块的方式获取。对于系统的版本，主要有以下几点作为参考：</p>

<ol>
<li>在iOS7及后续版本中，推荐使用NSURLSession。</li>
<li>对于iOS7以前的版本，可以使用NSURLConnection来获取数据并加载到本地内存中。如果要保存数据，可以再将数据写入磁盘。</li>
</ol>


<p>而对于获取数据，主要看我们是获取数据到内存中还是下载文件并保存。如果只是获取数据到内存中，则有两种方法：</p>

<ol>
<li>对于简单的请求，可以使用NSURLSession</li>
<li>对于复杂的请求（如上传数据请求），提供了NSURLRequest对象来与NSURLSession和NSURLConnection一起使用。</li>
</ol>


<p>不管使用哪种方法，我们都可以获取到响应数据，为此，我们可以如下处理响应</p>

<ol>
<li>提供一个响应处理block。当URL Loading类完成从服务端接收数据时调用该block.</li>
<li>提供自定义有delegate。URL Loading类间断性地调用我们的代理方法来获取数据。在需要的情况下，我们的程序负责收集这些数据。</li>
</ol>


<p>另外，URL Loading提供了一个返回对象来封装与请求相关的元数据，如MIME类型等。</p>

<p>而如果我们需要下载文件，则有两个基本方法来处理：</p>

<ol>
<li>对于简单请求，可以使用NSURLSession</li>
<li>对于复杂请求，提供了NSURLRequest对象来与NSURLSession和NSURLDownload一起使用。</li>
</ol>


<p>相较于NSURLDownload，NSURLSession有两个明显的优势：NSURLSession可用于iOS系统，而NSURLDownload在iOS中不被支持；当应用挂起、终止或异常退出时，下载可以在后台继续进行。</p>

<p>URL Loading中还提供了两个类用于处理元数据，一个用于表示客户端请求(NSURLRequest)，一个用于表示服务端响应(NSURLResponse)。我们分别介绍一下这两个类。</p>

<h4>NSURLRequest</h4>

<p>NSURLRequest对象封装了URL和协议指定的属性，及依赖于协议的行为。同时也指定了本地缓存策略及连接超时时间。一些协议支持协议指定的属性，如HTTP协议可以添加返回HTTP请求体，请求报头和传输方法到NSURLRequest中。</p>

<p>这里需要注意的是，当我们使用NSURLRequest的子类NSMutableURLRequest初始化一个连接或下载时，将会对NSMutableURLRequest实例进行深拷贝。因此在初始的请求上做修改时不会影响到连接和下载对象。</p>

<h4>NSURLResponse</h4>

<p>一个响应可以分为两个部分：描述内容的元数据和内容数据本身。而NSURLResponse类封装了大部分协议的响应元数据，这些元数据包括MIME类型，期望的Content-Length，编码格式，及提供响应的URL。NSURLResponse的一些子类提供了与协议相关的额外元数据。如NSHTTPURLResponse存储了web服务器返回的响应头和状态码。</p>

<p>需要注意的是NSURLResponse对象只存储响应的元数据，而不存储响应数据本身。响应数据由URL Loading通过响应处理block和对象的代理来接收并处理。</p>

<h2>认证和证书</h2>

<p>针对认证和证书，URL加载系统提供了以下几个类：</p>

<ol>
<li>NSURLCredential：封装了由认证信息和持久化行为组成的证书。</li>
<li>NSURLProtectionSpace：表示需要特定证书的区域。一个保护区域可以限制到单独的URL，拥有web服务器的区域，或引用一个代理。</li>
<li>NSURLCredientialStorage：一般是一个共享实例，用于管理证书存储和提供NSURLCredential对象到NSURLProductionSpace对象的映射。</li>
<li>NSURLAuthenticationChallenge：封装了认证一个请求的的NSURLProtocol实现所需要的信息：一个建议的证书、保护空间、错误信息或者协议用于确定所需要认证的响应、以及认证尝试次数等。初始对象（即请求发送者）必须实现NSURLAuthenticationChallengeSender协议。NSURLAuthenticationChallenge实例被用于NSURLProtocol的子类来告诉URL加载系统需要认证。他们同样为NSURLConnection和NSURLDownload的代理方法提供了便利的自定义认证处理。</li>
</ol>


<h2>缓存管理</h2>

<p>URL加载系统提供基于磁盘和内存的缓存，允许程序减少对网络连接的依赖，并提供对缓存响应的快速访问。缓存存储在每个app的缓存文件夹下。NSURLConnection会根据缓存策略（初始化NSURLRequest对象中指定的）来查询缓存。</p>

<p>NSURLCache提供了配置缓存大小和磁盘存储位置的方法。同时提供了包含缓存响应的NSCacheURLResponse对象集合的方法。NSCacheURLResponse对象封装了NSURLResponse对象和URL数据，同时提供用户信息字典，这些信息可以用于缓存任何用户数据。</p>

<p>不是所有的协议实现都支持响应缓存。当前只有http和https请求可被缓存。</p>

<p>一个NSURLConnection对象可以通过connection:willCacheResponse:代理访求来控制是否缓存响应，响应是否只应该存储在内存中。</p>

<h2>Cookie存储</h2>

<p>由于HTTP协议是无状态的，所以客户端通常使用cookie来保存URL请求的数据。URL加载系统提供了接口来创建和管理cookie，将cookie作为HTTP请求的一部分来发送，及解析web服务端响应数据时接收cookie.</p>

<p>iOS提供了NSHTTPCookieStorage类来管理一个NSHTTPCookie对象的集合。</p>

<h2>协议支持</h2>

<p>URL加载系统默认支持http, https, file, ftp, data协议。另外，URL加载系统也允许我们注册自己的类来支持额外的系统层级的网络协议。我们也可以添加指定协议的属性到URL请求和URL响应对象</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[混合使用Swift和Objective-C]]></title>
    <link href="http://southpeak.github.io/blog/2014/07/08/mix-swift-and-objective-c/"/>
    <updated>2014-07-08T16:58:06+08:00</updated>
    <id>http://southpeak.github.io/blog/2014/07/08/mix-swift-and-objective-c</id>
    <content type="html"><![CDATA[<p>Swift和Objective-C可以在同一个工程中共存。不管创建工程时选择的是Swift还是Objective-C作为初始语言，我们都可以在工程中添加另一种语言的文件。</p>

<p>混合编程的处理过程在App工程和库工程中稍微有点不同。具体的工作模型如下图所示</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/Art/DAG_2x.png" alt="image" /></p>

<p>下面我们讨论下具体的操作</p>

<h2>同一App工程中导入代码</h2>

<h4>在Swift工程中导入Objective-C</h4>

<p>如果我们需要在一个Swift工程中导入Objective-C代码，需要依托于Objective-C Bridging header(桥接头文件)。在Swift工程中，当我们添加一个Objective-C文件时，如果工程中没有现存的Bridging header文件，则XCode会提示我们是否创建该文件。如果我们点击Yes，则XCode会自动创建头文件，并命名为&#8221;工程名-Bridging-Header.h&#8221;。</p>

<p>我们需要编辑这个文件，以导入我们的Objective-C代码。</p>

<p>如果是从同一个target中导入Objective-C代码，则我们需要做如下操作</p>

<ol>
<li><p>在Bridging header文件中，import所有需要在Swift中使用的头文件</p>

<p> #import &ldquo;XYZCustomCell.h&rdquo;</p>

<p> #import &ldquo;XYZCustomView.h&rdquo;</p>

<p> #import &ldquo;XYZCustomViewController.h&rdquo;</p></li>
<li><p>在Build Settings中，确保Swift Compiler Code Generation->Objective-C Bridging Header下的头文件的路径是对的。路径必须直接指向文件本身，而不是文件所在的文件夹。</p></li>
</ol>


<p>所有在Bridging header中的公有Objective-C头文件在Swift都是可见的，并且其中的所有功能在所有Swift中都是可用的，而不需要任何导入处理。可以像使用Swift代码一样使用Objective-C代码。如下所示</p>

<pre><code>let myCell = XYZCustomCell()
myCell.subtitle = "A custom cell"
</code></pre>

<h4>在Objective-C中导入Swift</h4>

<p>如果我们要在一个Objective-C工程中导入Swift，则需要依托于XCode-generated header文件。这个自动生成的文件是一个Objective-C头文件，其声明了在我们的target中使用的所有Swift接口。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift对C指针实现浅析]]></title>
    <link href="http://southpeak.github.io/blog/2014/07/06/ios-swift-cpointer-2/"/>
    <updated>2014-07-06T13:23:29+08:00</updated>
    <id>http://southpeak.github.io/blog/2014/07/06/ios-swift-cpointer-2</id>
    <content type="html"><![CDATA[<p>个人认为，Swift对指针的处理略显复杂。</p>

<p>我们通过调试可以看到存在这样一个类型Builtin.RawPointer，我们可以假设其为C指针在Swife中的内部表示，但不可以直接使用。相反，在Swift中，定义了7种指针类型，可以通过这7种类型来操作C指针。</p>

<h2>COpaquePointer</h2>

<p>在C语言中，常使用typedef来定义一些指针类型的别名，如</p>

<pre><code>typedef struct stack *stack_t
</code></pre>

<p>该定义表示一个指向栈结构的指针，但并没有给出结构的任何信息，我们不知道该结构都有哪些成员。类似于stack_t这样的指针就是一个不透明的指针。在程序中，我们可以自由的操纵这种指针，但无法反引用以获取指针的内部信息，只有接口的实现才有这种特权。这所以使用不透明指针，在于其隐藏了具体的实现细节，有助于捕获错误。即只能传相同的参数给函数，否则将产一变异错误。(参看《C语言接口与实现：创建可重用软件的技术》)</p>

<p>在Swift中，针对这种不透明指针，定义了一个包装器：COpaquePointer。该类型（实际为结构体）是一个不透明指针的包装器，主要用于Bridge Header中表示C中的复杂结构指针，当我们的指针指向的类型无法在Swift中有效地表示出来时，就可以使用该类型，而如果在Swift能找到对应的类型表示指针指向的类型，则可以使用UnsafePointer。</p>

<p>该类的实现及其扩展实现了四个协议，我们看看其具体代码</p>

<pre><code>struct COpaquePointer : Equatable, Hashable, LogicValue {
    init()
    static func null() -&gt; COpaquePointer
    func getLogicValue() -&gt; Bool
    var hashValue: Int { get }
}

extension COpaquePointer {

    /// 将UnsafePointer类型转换为不透明C指针
    init&lt;T&gt;(_ from: UnsafePointer&lt;T&gt;)
}

extension COpaquePointer : CVarArg {
    func encode() -&gt; Word[]
}
</code></pre>

<p>可以看到该结构体并没有做太多的事情，仅仅实现了四个协议的接口，同时做了个UnsafePointer类型的转换操作。该类型在Swift使用得比较多，例如在NSData中，bytes属性的类型就是COpaquePointer，而该属性在Objective-C中的类型是const void*。</p>

<h2>UnsafePointer</h2>

<p>UnsafePointer一个泛型结构体，可以说是处理C指针最主要的结构体了。它包装并存储了类型为T的C指针，主要用于与C标准库交互。该类没有提供自动管理内存功能，所以我们在使用的时候需要注意内存的分配与释放。当在Swift能找到与T类型相对应的类型时，可以使用该类型，否则就考虑使用COpaquePointer。</p>

<p>在该类型的声明中，我们可以看到它定义了大量的方法来处理指针，具体如下</p>

<pre><code>struct UnsafePointer&lt;T&gt; : BidirectionalIndex, Comparable, Hashable, LogicValue {    
    /// 构造一个空指针
    init()

    /// 将一个不透明指针转换为类型指定的C指针，注意这种转换是不安全的
    init(_ other: COpaquePointer)

    /// 从给定的内存地址中构造一个UnsafePointer。注意这种转换是不安全的
    init(_ value: Int)

    /// 从一个不同类型的指针中转换。注意这种转换是不安全的
    init&lt;U&gt;(_ from: UnsafePointer&lt;U&gt;)
    static func null() -&gt; UnsafePointer&lt;T&gt;
    static func alloc(num: Int) -&gt; UnsafePointer&lt;T&gt;
    func dealloc(num: Int)

    /// 访问底层原始内存，获取并设置其值
    var memory: T

    /// 初始化指针指向的值，用于构造一个事先未存储对象的对象
    func initialize(newvalue: T)

    /// 获取指针指向的值，并将其从内存引用的位置移除。
    /// 后置条件：值被销毁，且内存在再次使用前必须被初始化
    func move() -&gt; T

    /// 将起始于source处的count个值赋值给未初始化的内存，将原始值转换到原始内存中，并且
    /// 是从最后开始处理，一直到第一个。使用该方法将值拷贝到可能与原范围重叠的内存区域
    /// 这要求source的位置先于self或者在self+count之后
    func moveInitializeBackwardFrom(source: UnsafePointer&lt;T&gt;, count: Int)

    /// Assign from count values beginning at source into initialized
    /// memory, transforming the source values into raw memory.
    /// 将起始于source处的count个值赋值给已初始化的内存，将原始值转换到原始内存中
    func moveAssignFrom(source: UnsafePointer&lt;T&gt;, count: Int)

    /// 拷贝起始于source的count个值到内存中，将源值转换到内存中
    func moveInitializeFrom(source: UnsafePointer&lt;T&gt;, count: Int)

    /// 拷贝起始于source的count个值到内存中
    func initializeFrom(source: UnsafePointer&lt;T&gt;, count: Int)

    /// 拷贝C元素到内存中
    func initializeFrom&lt;C : Collection where T == T&gt;(source: C)

    /// 销毁指针指向的对象
    func destroy()

    /// 销毁指针指向的count个对象
    func destroy(count: Int)
    func getLogicValue() -&gt; Bool
    subscript (i: Int) -&gt; T
    var hashValue: Int { get }
    func succ() -&gt; UnsafePointer&lt;T&gt;
    func pred() -&gt; UnsafePointer&lt;T&gt;

    /// 以下是将其它类型的指针转换化UnsafePoint的构造器
    init(_ cp: CConstPointer&lt;T&gt;)
    init(_ cm: CMutablePointer&lt;T&gt;)
    init(_ op: AutoreleasingUnsafePointer&lt;T&gt;)
    init(_ cp: CConstVoidPointer)
    init(_ cp: CMutableVoidPointer)
}

extension UnsafePointer&lt;T&gt; : Printable {
    var description: String { get }
}
</code></pre>

<p>UnsafePointer提供了多个构造器，以从其它指针类型创建一个UnsafePointer。另外，CMutablePointer、CMutableVoidPointer、CConstPointer、CConstVoidPointer都提供了一个withUnsafePointer方法，该方法是让这些指针类型在一个闭包中可以像UnsafePointer类型一样使用。我们来看一个例子：</p>

<pre><code>func StringFromCptr(inChars:CMutablePointer&lt;CChar&gt;) -&gt; String {

    var ptr:UnsafePointer&lt;UInt8&gt; = UnsafePointer&lt;UInt8&gt;(0)
    inChars.withUnsafePointer({ p in ptr = UnsafePointer&lt;UInt8&gt;(p) })

    var str = CString(ptr)

    return NSString(CString:str)
}

var Len = 10
var Str = CChar[](count:Len, repeatedValue:CChar(0))

for var i = 0; i &lt; Len; i++ {
    Str[i] = CChar(i + 65)
}

var Result = StringFromCptr(&amp;Str)

println("\(Result)")

// 输出：ABCDEFGHIJ
</code></pre>

<p>目前感觉在通常情况下，UnsafePointer使用得不多，平时接触到的更多的是CMutablePointer、CMutableVoidPointer、CConstPointer、CConstVoidPointer、AutoreleasingUnsafePointer这五种指针类型，这五种指针的基本使用方法我们在<a href="http://southpeak.github.io/blog/2014/07/02/ios-swift-cpointer/">Swift中C指针的基本使用方法</a>有简单介绍过，下面我们也讲讲它们的基本实现。</p>

<h2>AutoreleasingUnsafePointer</h2>

<p>该类型的基本定义是一个指向Objective-C指针的可变指针。这个类型有几种隐式转换来允许传递下面几种参数类型给一个一个C或ObjC API：</p>

<ol>
<li>nil, 作为null指针传入</li>
<li>被引用类型的in-out参数，作为一个带有自动释放所有权语义的可回写变量的指针传递</li>
<li>UnsafePointer<T></li>
</ol>


<p>与CMutablePointer不同的是，Swift不直接支持传递一个指向元素是Objc类指针数组的指针。与UnsafePointer<T>不同的是，AutoreleasingUnsafePointer必须引用一个存储，该存储没有其引用值的引用计数。相反，UnsafePointer的操作假设引用的存储拥有其加载的值且可以对其进行修改。</p>

<p>该类型不像其它的C*Pointer类型一样携带一个所有者指针，因为它只需要引用in-out参数转换的结果，而这个参数已经有一个回写域的生命周期了。</p>

<p>我们来看看其声明：</p>

<pre><code>struct AutoreleasingUnsafePointer&lt;T&gt; : Equatable, LogicValue {
    func getLogicValue() -&gt; Bool

    /// Access the underlying raw memory, getting and
    /// setting values.
    var memory: T
}
</code></pre>

<h2>CConstPointer与CConstVoidPointer</h2>

<p>这两个类型都是C常量指针，分别对应于C中的const T<em>和const </em>void。它们没有自己的操作。它的值由owner-value对组成，也正因此，它不能直接传递给C函数。在桥接的过程中，它会维护一个owner的强引用，且指针值被传递到C或者Objective-C的入口点。这允许拥有堆存储的类型(如数组)将自己转换为一个指针，同时仍保证在调用的过程中仍然维护它们的存储。我们可以看下它们的具体实现</p>

<pre><code>struct CConstPointer&lt;T&gt; : Equatable {
    let owner: AnyObject?

    /// True if this is a scoped pointer, meaning it has a owner reference
    /// that guarantees the lifetime of the referenced memory.
    var scoped: Bool { get }

    /// Make the pointer available as an UnsafePointer within a closure.
    func withUnsafePointer&lt;U&gt;(f: UnsafePointer&lt;T&gt; -&gt; U) -&gt; U
}

struct CConstVoidPointer : Equatable {
    let owner: AnyObject?

    /// True if this is a scoped pointer, meaning it has a owner reference
    /// that guarantees the lifetime of the referenced memory.
    var scoped: Bool { get }

    /// Make the pointer available as an UnsafePointer within a closure.
    func withUnsafePointer&lt;T, U&gt;(f: UnsafePointer&lt;T&gt; -&gt; U) -&gt; U
}
</code></pre>

<h2>CMutablePointer与CMutableVoidPointer</h2>

<p>这两个类型都是C可变指针，分别对应于C中的T <em>和void </em>，其基本内容同上。</p>

<h2>总结</h2>

<p>由上面的分析，依据类型是否可以直接用于C函数声明，可以将这7种指针类型分为两类：</p>

<ol>
<li>可直接用于C函数声明：COpaquePointer,UnsafePointer<T>,AutoreleasingUnsafePointer<T>，它们是对Builtin.RawPointer的封装，直接对应于C指针，其sizeof是单位字长</li>
<li>不可直接用于C函数声明：CMutablePointer<T>, CConstPointer<T>, CMutableVoidPointer, CConstVoidPointer。这几个类型都有一个owner属性用于管理实例的生命周期，可以直接从Swift对象的引用获得，另外还可以使用withUnsafePointer方法，该方法是让这些指针类型在一个闭包中可以像UnsafePointer类型一样使用。</li>
</ol>


<p>另外有两点需要注意</p>

<ol>
<li>非常量指针都实现了LogicValue协议，因此可以直接使用if a_pointer来判断其是否为NULL。</li>
<li>nil类型实现了到所有指针类型的隐式类型转换，等价于C中的NULL，可以直接判断。</li>
</ol>


<p>至于这些指针的使用，需要在根据实现情况来具体处理。</p>

<p>参考：</p>

<ol>
<li>《C语言接口与实现：创建可重用软件的技术》</li>
<li><a href="http://stackoverflow.com/questions/24089052/swift-string-to-cmutablepointercchar">Swift.String to CMutablePointer<CChar></a></li>
<li><a href="http://andelf.github.io/blog/2014/06/18/swift-and-c-interop-cont/">Swift and C Interop Cont. (简析 Swift 和 C 的交互，Part 二)</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cover flow基本原理及Tapku实现方法]]></title>
    <link href="http://southpeak.github.io/blog/2014/07/05/cover-flow/"/>
    <updated>2014-07-05T17:51:43+08:00</updated>
    <id>http://southpeak.github.io/blog/2014/07/05/cover-flow</id>
    <content type="html"><![CDATA[<p>这篇是两年前在CocoaChina上写的(德鲁伊)，现在把它归集到这边来。大家也可以查看<a href="http://www.cocoachina.com/bbs/read.php?tid=75699">原文</a>。</p>

<p>Cover flow是苹果首创的将多首歌曲的封面以3D界面的形式显示出来的方式。如下图所示：</p>

<p><img src="http://cc.cocimg.com/bbs/attachment/Fid_6/6_38018_be3432a30663e7e.png" alt="image" /></p>

<p>从图中可以看到，显示在中间的图片为目标图片，两侧的图片在y轴都旋转了一定的角度，并且每两张图片之间都保持了一定的距离。在交互（如点击两侧的图片）的时候，滑动到中间的图片会逐渐放大，旋转的角度由原来的旋转角度a变为0，且位置上移动中间，变成新的目标图片；同时原处于中间位置的图片则缩小、旋转一定的角度、位置偏移到一侧。所以在整个过程中，主要有两个属性发生了变化：角度与位置(缩放只是视觉上的，并没有进行缩放操作)。</p>

<p>在每次点击一张图片时，如果这张图片在目标图片的左边，则所有的图片都会向右移动，同时做相应的旋转；相反，点击目标图片右侧的图片时，所有图片都会向左移动并做相应的旋转。</p>

<p>从如上描述的效果，可以看出在Cover Flow中最主要的的操作有两个：3D仿射变换与动画。仿射变换实质上是一种线性变换，通常主要用到的仿射变换有平移(Translation)、旋转(Rotation)、缩放(Scale)。
对于这两种操作，iOS都提供了非常简便的接口来实现。接下来我们便以tapku的实现方法为例，来说明实现Cover Flow的基本过程。</p>

<h2>一、图片的布局</h2>

<p>从效果图可以看出，图片是按一条直接排列，图片与图片之间有一定的间距，目标图片是正向显示，两侧的图片则按一定的角度进行了旋转，与目标图片形成一定的角度。同时我们还能看到每个图片都有一个倒影，并且这个倒影是渐变的，由上而下逐渐透明度逐渐减小。</p>

<h4>1、 Cover Flow单元的定义</h4>

<p>在tapku中，每一个图片附属于一个视图(TKCoverflowCoverView)，这个视图相当于UITableViewCell，它包含了三个要素：图片(imageView)，倒影图片(reflected)，渐变层(gradientLayer)。渐变层覆盖于倒影图片上，且大小位置一致。</p>

<p>TKCoverflowCoverView的声明及布局代码如下所示：</p>

<pre><code>@interface TKCoverflowCoverView : UIView {
    float baseline;
    UIImageView *imageView;
    UIImageView *reflected;
    CAGradientLayer *gradientLayer;
}
@end

- (id)initWithFrame:(CGRect)frame {
    self = [super initWithFrame:frame];
    if (self) {
        self.opaque = NO;
        self.backgroundColor = [UIColor clearColor];
        self.layer.anchorPoint = CGPointMake(0.5, 0.5);

        imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, self.frame.size.width, self.frame.size.width)];
        [self addSubview:imageView];
        reflected = [[UIImageView alloc] initWithFrame:CGRectMake(0, self.frame.size.width, self.frame.size.width, self.frame.size.width)];
        reflected.transform = CGAffineTransformScale(reflected.transform, 1, -1);
        [self addSubview:reflected];

        gradientLayer = [CAGradientLayer layer];
        gradientLayer.colors = [NSArray arrayWithObjects:(id)[UIColor colorWithWhite:0 alpha:0.5].CGColor,(id)[UIColor colorWithWhite:0 alpha:1].CGColor,nil];
        gradientLayer.startPoint = CGPointMake(0, 0);
        gradientLayer.endPoint = CGPointMake(0, 0.4);
        gradientLayer.frame = CGRectMake(0, self.frame.size.width, self.frame.size.width, self.frame.size.width);
        [self.layer addSublayer:gradientLayer];
    }

    return self;
}
</code></pre>

<p>注意：此次将视图的锚点(anchorPoint属性)设置为(0.5, 0.5)，即视图的中心点，目的是让视图以中心点为基点进行旋转。</p>

<p>在进行仿射变换时，视图作为一个整体进行变换。</p>

<h4>2、图片的布局</h4>

<p>tapku中，图片的布局与交互是在TKCoverflowView类中完成的。类TKCoverflowView继承自UIScrollView，相当于是TableView。</p>

<p>该类中定义是两个仿射变量：</p>

<pre><code>CATransform3D leftTransform, rightTransform
</code></pre>

<p>这两个变量分别设置了两侧图片的仿射变换，具体的设置方法为</p>

<pre><code>- (void) setupTransforms{
    leftTransform = CATransform3DMakeRotation(coverAngle, 0, 1, 0);
    leftTransform = CATransform3DConcat(leftTransform,CATransform3DMakeTranslation(-spaceFromCurrent, 0, -300));
    rightTransform = CATransform3DMakeRotation(-coverAngle, 0, 1, 0);
    rightTransform = CATransform3DConcat(rightTransform,CATransform3DMakeTranslation(spaceFromCurrent, 0, -300));
}
</code></pre>

<p>其中coverAngle为旋转的角度。对每个仿射变量同时设置了旋转也平移变换。</p>

<p>Cover Flow单元是存储在一个数组中：
复制代码
NSMutableArray *coverViews;</p>

<p>初始化时设置数组的大小，并存入空对象。在后期获取某个索引位置的单元时，如果该单元为空，则生成一个新的TKCoverflowCoverView并放入相应位置。</p>

<pre><code>if([coverViews objectAtIndex:cnt] == [NSNull null]){
    TKCoverflowCoverView *cover = [dataSource coverflowView:self coverAtIndex:cnt];
    [coverViews replaceObjectAtIndex:cnt withObject:cover];
    ......
}
</code></pre>

<p>每个Cover Flow单元的位置计算如下</p>

<pre><code>CGRect r = cover.frame;
r.origin.y = currentSize.height / 2 - (coverSize.height/2) - (coverSize.height/16);
r.origin.x = (currentSize.width/2 - (coverSize.width/ 2)) + (coverSpacing) * cnt;
cover.frame = r;
</code></pre>

<p>其中currentSize,coverSize,coverSpacing都是固定值。从中可以看出所有单元的y值都是一样的，而x值则与其在数组中的索引值相关，索引越大，x值也越大。而这就涉及我们之后的一个问题。一会再讲。
假定目标图片的索引为currentIndex，则目标图片两侧的仿射属性设置如下：</p>

<pre><code>if(cnt &gt; currentIndex){
    cover.layer.transform = rightTransform;
}
else
    cover.layer.transform = leftTransform;
</code></pre>

<p>如上即为Cover Flow的基本布局，可以与UITableView比较一下。</p>

<h2>二、交互</h2>

<p>Cover Flow的基本交互是点击两侧的图片，则被点击的图片成为新的目标图片并移动中屏幕中间，而其它图片一起移动，在这个过程中所需要做的就两件事：旋转与平移。</p>

<p>方法很简单：在动画块中重新设置Cover Flow单元的transform属性，这样就可以缓动实现这个动画的过程。实际上只有新旧目标图片及中间的图片需要做这种变换，其余图片的transform属性都是不变的。</p>

<pre><code>float speed = 0.3;
[UIView beginAnimations:string context:nil];
[UIView setAnimationDuration:speed];
[UIView setAnimationCurve:UIViewAnimationCurveEaseOut];
[UIView setAnimationBeginsFromCurrentState:YES];
[UIView setAnimationDelegate:self];
[UIView setAnimationDidStopSelector:@selector(animationDidStop:finished:context:)]; 
for(UIView *v in views){
int i = [coverViews indexOfObject:v];
    if(i &lt; index) v.layer.transform = leftTransform;
    else if(i &gt; index) v.layer.transform = rightTransform;
    else v.layer.transform = CATransform3DIdentity;
}
[UIView commitAnimations];
</code></pre>

<p>但这在做的只是旋转了Cover Flow的内容，并没有对Cover Flow进行水平平移，Cover Flow水平位置已由其origin.x值固定。那么水平上的平移是如何实现的呢，我们看下面的代码：</p>

<pre><code>- (void) snapToAlbum:(BOOL)animated{
    UIView *v = [coverViews objectAtIndex:currentIndex];
    if((NSObject*)v!=[NSNull null]){
        [self setContentOffset:CGPointMake(v.center.x - (currentSize.width/2), 0) animated:animated];
    }
    else
    {  
        [self setContentOffset:CGPointMake(coverSpacing*currentIndex, 0) animated:animated];
    }
}
</code></pre>

<p>其所做的就是以目标图片为中心，整体平移TKCoverflowView视图。</p>

<h2>三、总结</h2>

<p>由上可以看出，Cover Flow特效的原理很简单：对新旧目标图片及中间的图片以动画的形式做仿射变换。至于仿射变换如何处理，有不同的方法。tapku所实现的方法可以说相对简单灵活。</p>

<p>Android, Flash都有类似的Cover Flow特效实现方法，有兴趣的童鞋可以参考一下。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift中C指针的基本使用方法]]></title>
    <link href="http://southpeak.github.io/blog/2014/07/02/ios-swift-cpointer/"/>
    <updated>2014-07-02T20:51:30+08:00</updated>
    <id>http://southpeak.github.io/blog/2014/07/02/ios-swift-cpointer</id>
    <content type="html"><![CDATA[<p>Swift尽可能避免让我们直接去访问指针。但当我们需要直接访问内存时，我们可以使用Swift提供的几种指针类型。在下面几个表中列出了各种情况下C类型指针语法与Swift语法对应关系，其中Type作为实际类型的占位符</p>

<p>对于函数参数，有以下对应关系</p>

<table>
<thead>
<tr>
<th></th>
<th>    C语法    </th>
<th>   Swift语法   </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> const void * </td>
<td>  CConstVoidPointer |</td>
</tr>
<tr>
<td></td>
<td>  void *  </td>
<td>  CMutableVoidPointer |</td>
</tr>
<tr>
<td></td>
<td>const Type * </td>
<td> CConstPointer<Type> |</td>
</tr>
<tr>
<td></td>
<td>Type *</td>
<td>CMutablePointer<Type>|</td>
</tr>
</tbody>
</table>


<p>对于返回值，变量，二级以上的指针参数，有以下对应关系</p>

<table>
<thead>
<tr>
<th></th>
<th>    C语法    </th>
<th>   Swift语法   </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>void * </td>
<td> COpaquePointer|</td>
</tr>
<tr>
<td></td>
<td>Type * </td>
<td> UnsafePointer<Type>|</td>
</tr>
</tbody>
</table>


<p>对于类类型，有以下对应关系</p>

<table>
<thead>
<tr>
<th></th>
<th>    C语法    </th>
<th>   Swift语法   </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>Type * const * </td>
<td> CConstPointer<Type> |</td>
</tr>
<tr>
<td></td>
<td>Type * __strong * </td>
<td> CMutablePointer<Type> |</td>
</tr>
<tr>
<td></td>
<td>Type ** </td>
<td> AutoreleasingUnsafePointer<Type>|</td>
</tr>
</tbody>
</table>


<p>下面简单介绍一下这几种类型的指针</p>

<h2>C可变指针</h2>

<p>当我们声明一个包含CMutablePointer<Type>参数的指针时，可以接收以下类型的值</p>

<ol>
<li>nil, 作为空指针传入</li>
<li>一个CMutablePointer<Type>值</li>
<li>一个in-out表达式，它的操作数是Type类型的左值。该表达式作为左值地址传入</li>
<li>一个in-out Type[]值，它作为数组的首地址指针传入，且在调用时扩展了数据的生命周期</li>
</ol>


<p>假如我们声明了如下一个函数：</p>

<pre><code>func takesAMutablePointer(x: CMutablePointer&lt;Float&gt;) { /*...*/ }
</code></pre>

<p>那么我们可以用以下任何一种方式来调用</p>

<pre><code>var x: Float = 0.0
var p: CMutablePointer&lt;Float&gt; = &amp;x
var a: Float[] = [1.0, 2.0, 3.0]

takesAMutablePointer(nil)
takesAMutablePointer(p)
takesAMutablePointer(&amp;x)
takesAMutablePointer(&amp;a)
</code></pre>

<p>当声明一个包含CMutableVoidPointer参数的函数时，它可以接收与CMutablePointer<Type>相同的形参，其中Type为任意类型。需要注意的是如果直接传递CMutablePointer<Type>，目前的编译器会直接报编译错误</p>

<pre><code>func takesAMutableVoidPointer(x: CMutableVoidPointer) { /* ... */ }

var x: Float = 0.0, y: Int = 0
var p: CMutablePointer&lt;Float&gt; = &amp;x, q: CMutablePointer&lt;Int&gt; = &amp;y
var a: Float[] = [1.0, 2.0, 3.0], b: Int[] = [1, 2, 3]

takesAMutableVoidPointer(nil)
//takesAMutableVoidPointer(p)   编辑错误:CMutablePointer&lt;Float&gt; is not convertible to CMutableVoidPointer
//takesAMutableVoidPointer(q)
takesAMutableVoidPointer(&amp;x)
takesAMutableVoidPointer(&amp;y)
takesAMutableVoidPointer(&amp;a)
takesAMutableVoidPointer(&amp;b)
</code></pre>

<h2>C常量指针</h2>

<p>当我们声明一个带有CConstPointer<Type>参数的函数时，可以接收以下类型的值：</p>

<ol>
<li>nil, 作为空指针传入</li>
<li>一个CMutablePointer<Type>, CMutableVoidPointer, CConstPointer<Type>, CConstVoidPointer, 或者AutoreleasingUnsafePointer<Type>类型的值，如果需要则会转换成CConstPointer<Type></li>
<li>一个in-out表达式，它的操作数是Type类型的左值。该表达式作为左值地址传入</li>
<li>一个in-out Type[]值，它作为数组的首地址指针传入，且在调用时扩展了数据的生命周期</li>
</ol>


<p>假如我们声明如下函数:</p>

<pre><code>func takesAConstPointer(x: CConstPointer&lt;Float&gt;) { /*...*/ }
</code></pre>

<p>那么我们可以用以下任何一种方式来调用</p>

<pre><code>var x: Float = 0.0
var p: CConstPointer&lt;Float&gt; = nil

takesAConstPointer(nil)
takesAConstPointer(p)
takesAConstPointer(&amp;x)
takesAConstPointer([1.0, 2.0, 3.0])
</code></pre>

<p>当声明一个包含CConstVoidPointer参数的函数时，它可以接收与CConstPointer<Type>相同的形参，其中Type为任意类型。</p>

<pre><code>func takesAConstVoidPointer(x: CConstVoidPointer) { /* ... */ }

var x: Float = 0.0, y: Int = 0
var p:CConstPointer&lt;Float&gt; = nil, q: CConstPointer&lt;Int&gt; = nil

takesAConstVoidPointer(nil)
//takesAConstVoidPointer(p)
//takesAConstVoidPointer(q)
takesAConstVoidPointer(&amp;x)
takesAConstVoidPointer(&amp;y)
takesAConstVoidPointer([1.0, 2.0, 3.0])
takesAConstVoidPointer([1, 2, 3])
</code></pre>

<h2>AutoreleasingUnsafePointer</h2>

<p>当我们声明一个带有AutoreleasingUnsafePointer参数的函数时，可以接收以下类型的值：</p>

<ol>
<li>nil, 作为空指针传入</li>
<li>一个AutoreleasingUnsafePointer<Type>值</li>
<li>一个in-out表达式，其操作数是临时非所属(nonowning)缓冲区，存储了原始值的拷贝。缓冲区的地址被传递给调用函数，且在返回时，缓冲区的值被加载(loaded)、保留(retained)并重新指派(reassigned)给操作数</li>
</ol>


<p>注意上面清单中不包含数组</p>

<p>如果我们声明了以下函数</p>

<pre><code>func takesAnAutoreleasingUnsafePointer(x: AutoreleasingUnsafePointer&lt;NSDate?&gt;) { /*...*/ }
</code></pre>

<p>则可以用以下方式来调用</p>

<pre><code>var x: NSDate? = nil
var p: AutoreleasingUnsafePointer&lt;NSDate?&gt; = nil

takesAnAutoreleasingUnsafePointer(nil)
takesAnAutoreleasingUnsafePointer(p)
takesAnAutoreleasingUnsafePointer(&amp;x)
</code></pre>

<p>最后需要注意的是在Swift中，没有导入C函数指针</p>

<p>参考文档：<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/index.html">Using Swift with Cocoa and Objective-C</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift协议基础]]></title>
    <link href="http://southpeak.github.io/blog/2014/07/02/ios-swift-protocol/"/>
    <updated>2014-07-02T14:09:11+08:00</updated>
    <id>http://southpeak.github.io/blog/2014/07/02/ios-swift-protocol</id>
    <content type="html"><![CDATA[<p>Swift的Protocol(协议)与Objective-C的协议一样，用于定义一系列的特定任务和功能的集合。Protocol自身并不提供这些任务的实现，只是描述实现看起来应该是什么样的。类、结构体或枚举可以实现一个Protocol，并提供Protocol中任务和功能的具体实现。Protocol可以要求这些实现类型有指定的实例属性、实例方法、类型方法、操作符和下标等。</p>

<p>Protocol的语法如下所示:</p>

<pre><code>protocol SomeProtocol {
    // 协议定义
}
</code></pre>

<p>类、结构体、枚举可以同时实现多个Protocol，如下所示:</p>

<pre><code>struct SomeStructure: SomeProtocol, AnotherProcotol {
    // 协议定义
}
</code></pre>

<p>需要注意的是，子类在实现Protocol时，需要把父类写在前面，后面再跟上Protocol列表。</p>

<p>我们下面介绍Protocol可以定义的一些功能需求</p>

<h2>属性</h2>

<p>Protocol可以要求实现类型提供指定名称和类型的实例属性或类型属性。Protocol不指定属性是存储属性还是计算属性，它只定义属性名和类型。Protocol也可以指定每个属性是只读的还是可读写的。</p>

<p>如果Protocol要求属性是可读写的，那么这个属性不能是常量存储属性或者只读的计算属性；如果Protocol只是要求属性是可读的，则这个属性可以是任何类型的属性，这种情况下我们的实现代码同样可以指定属性为可写的。通常情况下，在Protocol中属性一般定义为变量，具体语法如下所示：</p>

<pre><code>protocol SomeProtocol {
    var mustBeSettable: Int { get set }
    var doesNotNeedToBeSettable: Int { get }
    class var someTypeProperty: Int { get set }
}
</code></pre>

<p>如果是类型属性，我们需要在前面加上class，即便是结构体可枚举来实现这个Protocol，也是一样。如上面代码所示。</p>

<p>代码清单1是一个详细的例子，定义了一个协议FullyNamed，其中声明了fullName属性，而在其两个个体的实现类型中，将fullName实现为不同的属性类型</p>

<h6>代码清单1</h6>

<pre><code>protocol FullyNamed {
    var fullName: String { get }
}

struct Person: FullyNamed {
    var fullName: String        // 可读写存储属性
}

class Sharship: FullyNamed {

    var prefix: String?
    var name: String?

    var fullName: String {      // 只读的计算属性
    return (prefix ? prefix! + " " : "") + name
    }
}
</code></pre>

<h2>方法</h2>

<p>在Protocol中声明方法与在类中定义类似，只是没有实现体。另外声明方法是使用可变参数也是可以的，唯一的不同是在Protocol的方法声明中不能指定默认值。</p>

<p>与属性声明一样，如果是类型方法，需要加上class前缀。方法的声明及实现类型的实现如代码清单2所示：</p>

<pre><code>protocol RandomNumberGenerator {
    func random() -&gt; Double
}


class LinearCongruentialGenerator: RandomNumberGenerator {
    var lastRandom = 42.0
    let m = 139968.0
    let a = 3877.0
    let c = 29573.0
    func random() -&gt; Double {
        lastRandom = ((lastRandom * a + c) % m)
        return lastRandom / m
    }
}
let generator = LinearCongruentialGenerator()

generator.random()      // 0.37464991998171
</code></pre>

<p>另外，如果我们需要在方法中修改实例，则在方法前添加mutating关键字，与结构体中方法的定义是一样的。需要注意的是，只有在结构体和枚举的实现中才需要加mutating，类的实现是不需要的。</p>

<h2>该Protocol做为类型</h2>

<p>Protocol可以作为一种类型在代码中使用。因为它是一种类型，所以在很多情况下都可以使用，包括</p>

<ol>
<li>作为函数、方法、初始化方法的参数或返回值</li>
<li>作为常量、变量或属性的类型</li>
<li>作为数组、字典或其它容器的元素</li>
</ol>


<p>基于此，Protocol也可以放入集合中，如数组、字典等。</p>

<p>下面是将Protocol作为类型的例子</p>

<pre><code>class Dice {
    let sides: Int
    let generator: RandomNumberGenerator
    init (sides: Int, generator: RandomNumberGenerator) {
        self.sides = sides
        self.generator = generator
    }

    func roll() -&gt; Int {
        return Int(generator.random() * Double(sides)) + 1
    }
}

// 具体使用
var dice = Dice(sides: 6, generator: LinearCongruentialGenerator())
</code></pre>

<h2>代理(Delegation)</h2>

<p>Swift与Objective-C的代理一样，允许将一个类或结构体的一些处理放到另外一个类型中(代理类)。Swift中代理模式的实现就是通过定义一个Protocol来封装代理方法，然后具体的实现类来实现这些代理方法。代理可以用于响应特定的行为，或者从外部资源获取数据，而不需要知道这些资源的类型。</p>

<p>如下是一个实现UITableView代理的简单例子</p>

<pre><code>class ViewController: UIViewController, UITableViewDelegate, UITableViewDataSource {

    var tableView: UITableView?

    override func viewDidLoad() {
        super.viewDidLoad()
        // Do any additional setup after loading the view, typically from a nib.

        tableView = UITableView(frame: self.view.bounds, style: UITableViewStyle.Plain)
        tableView!.delegate = self
        tableView!.dataSource = self
    }

    // 实现UITableViewDataSource

    func tableView(tableView: UITableView!, numberOfRowsInSection section: Int) -&gt; Int {
        return 20
    }

    func tableView(tableView: UITableView!, cellForRowAtIndexPath indexPath: NSIndexPath!) -&gt; UITableViewCell! {
        return nil
    }
}
</code></pre>

<h2>在扩展中实现Protocol</h2>

<p>如果我们想让某个已存在的类型(我们没有源码的情况下)实现某个Protocol，则可以借助扩展。当类型的扩展实现了Protocol时，该类会自动实现Protocol(听着有点绕口)。但如果类型已经实现了Protocol的所有必须的方法(类型未采用Protocol)，这种情况下，若想让类型采用Protocol，则可以使用一个空的扩展来声明类型采用Protocol。如下代码所示：</p>

<pre><code>protocol TextRepresentable {
    func asText() -&gt; String
}

struct Hamster {
    var name: String
    func asText() -&gt; String {
        return "A Hamster"
    }
}

extension Hamster : TextRepresentable {}
</code></pre>

<h2>Protocol继承</h2>

<p>一个Protocol可以继承自一个或多个Protocol，并在自己的实现中添加更多的功能需求。Protocol继承的语法与类型继承是一样的，其语法如下所示：</p>

<pre><code>protocol InheritingProtocol : SomeProtocol, AnotherProtocol {

}
</code></pre>

<p>在上面的例子中，所有实现子InheritingProtocol的类型都必须实现InheritingProtocol、SomeProtocol、AnotherProtocol三者中所有的必要功能。</p>

<h2>Protocol组合</h2>

<p>让一个类型同时实现多个Protocol是很有用的。这种情况下，我们可以使用Protocol组合来将多个Protocol组合成一个整体。其语法如下所示：</p>

<pre><code>protocol&lt;SomeProtocol, AnotherProtocol&gt;
</code></pre>

<p>我们可以将多个Protocol放在&lt;>中，在使用时，我们将其当成一个整体来处理，这种组合的实际含义是：任何同时实现&lt;>所有Protocol的类型。让我们看看下面的例子：</p>

<pre><code>protocol P1 {
    var variable1 : String { get }
}

protocol P2 {
    var variable2 : Int { get }
}

struct MyStruct : P1, P2 {
    var variable1: String
    var variable2: Int
}

func funcWithProtocols(protocols: protocol&lt;P1, P2&gt;) {

}

let st = MyStruct(variable1: "v", variable2: 2)

funcWithProtocols(st)
</code></pre>

<p>需要注意的是，Protocol组合并没有定义一个新的永久的Protocol类型，它仅仅是定义了一个临时的本地Protocol，该Protocol包含了组合中所有的功能。</p>

<h2>检查Protocol的一致性</h2>

<p>我们可以使用is操作符来检查Protocol的一致性，用as操作符来作Protocol转换。</p>

<ol>
<li>如果is操作符返回true，则一个实例实现了protocol，否则没有</li>
<li>as?操作符返回protocol类型的可选值，如果实例没有实现protocol，则返回nil</li>
<li>as操作符强制作类型转换，如果实例没有实现protocol，则引发一个错误</li>
</ol>


<p>需要注意的是，只有当protocol使用@objc属性标记时，才可以检查其一致性。@objc属性表明protocol应该暴露给Objective-C代码。但即使我们的代码不与Objective-C交互，如果需要对protocol进行一致性检测，也需要使用这个属性。另外@objc标明的protocol只能被类实现，而不能被结构体或枚举实现。</p>

<p>我们举个具体的例子：</p>

<pre><code>@objc protocol HasArea {
    var area: Double { get }
}

class Circle: HasArea {
    let pi = 3.1415927
    var radius: Double
    var area: Double { return pi * radius * radius }
    init(radius: Double) { self.radius = radius }
}

class Country: HasArea {
    var area: Double
    init(area: Double) { self.area = area }
}

class Animal {
    var legs: Int
    init(legs: Int) { self.legs = legs }
}

let objects: AnyObject[] = [
    Circle(radius: 2.0),
    Country(area: 243_610),
    Animal(legs: 4)
]

for object : AnyObject in objects {
    if let objectWithArea = object as? HasArea {
        println("Area is \(objectWithArea.area)")
    } else {
        println("Something that doesn't have an area")
    }
}

// Area is 12.5663708
// Area is 243610.0
// Something that doesn't have an area
</code></pre>

<h2>可选需求</h2>

<p>与Objective-C类似，Swift的Protocol可以定义一些可选的需求，这些需求在实现类型中可以选择性的实现。我们使用@optional修饰符来定义这些需求。</p>

<p>一个可选的需求可以通过可选链来实现，这个可选链可以满足当某个类型没有实现所采用的Protocol的可选需求。这种调用的基本语法如下：</p>

<pre><code>someOptionalMethod?(someArgument)
</code></pre>

<p>另外，可选的方法如果有返回值，总是返回一个可选值，以满足可能未被实现的需求。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift扩展(Extension)基础]]></title>
    <link href="http://southpeak.github.io/blog/2014/06/27/ios-swift-extension/"/>
    <updated>2014-06-27T20:54:59+08:00</updated>
    <id>http://southpeak.github.io/blog/2014/06/27/ios-swift-extension</id>
    <content type="html"><![CDATA[<p>扩展(Extension)用于为已存在的类、结构体或枚举添加新的功能。它类似于Objecitve-C中的分类，不同的是Swift的扩展没有名字</p>

<p>Swift的扩展可以做以下事情：</p>

<ul>
<li><p> 添加计算属性和静态计算属性</p></li>
<li><p> 定义实例方法和类型方法</p></li>
<li><p> 提供新的初始化方法</p></li>
<li><p> 定义下标操作符</p></li>
<li><p> 定义并使用新的嵌套类型</p></li>
<li><p> 让已存在类型实现一个协议</p></li>
</ul>


<p>在定义类型的扩展后，访扩展中的功能可以用于类型所有已存在的实例中，即使这些实例在扩展之前定义。</p>

<p>我们使用关键字extension来声明一个扩展，一个扩展可以让类型实现一个或多个协议，如代码清单1所示：</p>

<h6>代码清单1：</h6>

<pre><code>extension SomeType: SomeProtocol, AnotherProtocol {
    // implementation of protocol requirement goes here
}
</code></pre>

<p>下面我们分别介绍如何去扩展一个已有类型的各种功能</p>

<h2>计算属性</h2>

<p>扩展可以添加实例计算属性和类型计算属性。如代码清单2所示：</p>

<h6>代码清单2：</h6>

<pre><code>extension Double {
    var km: Double {return self * 1_000.0}
    var m: Double { return self }
    var cm: Double { return self / 100.0 }
    var mm: Double { return self / 1_000.0 }
    var ft: Double { return self / 3.28084 }
}

let onInch = 25.4.mm        // 0.0254
let threeFeet = 3.ft        // 0.914399970739201
</code></pre>

<p>上例扩展了Double，并定义了一些实例计算属性。我们可以将其用于Double的实例，也可以用于Double类型的字面值。</p>

<p>需要注意的是，扩展可以添加新的计算属性，但不能添加存储属性，也不能给已存在的属性添加观察者</p>

<h2>初始化方法</h2>

<p>扩展可以为已存在类型添加新的初始化方法。这可以让我们扩展某一类型以接受我们自定义的类型作为它的初始化方法，或者为现有类型提供额外的初始化方法。</p>

<p>扩展可以为类添加新的便捷初始化方法，但不能添加命名初始化方法(designated initializers)和析构方法，这两者必须由类型的原始实现来提供。</p>

<p>代码清单3定义了Rect类型，并通过扩展为其定义了一个新的初始化方法</p>

<h6>代码清单3</h6>

<pre><code>struct Size {
    var width = 0.0, height = 0.0
}

struct Point {
    var x = 0.0, y = 0.0
}

struct Rect {
    var origin = Point()
    var size = Size()
}

let defaultRect = Rect()
let memeberwiseRect = Rect(origin: Point(x: 1.0, y: 2.0), size: Size(width: 5.0, height: 10.0))

extension Rect {
    init (center: Point, size: Size) {
        let originX = center.x - (size.width / 2)
        let originY = center.y - size.height / 2
        self.init(origin: Point(x: originX, y: originY), size:size)
    }
}

let centerRect = Rect(center: Point(x: 20.0, y: 3.0), size: Size(width: 10.0, height: 40.0))
</code></pre>

<p>需要注意的是，如果我们提供新的初始化方法，仍然需要确保在初始化方法结束前初始化实例的所有常量和变量。</p>

<p>另外，如果我们扩展的类型的所有存储属性都有默认值，而没有定义初始化方法时，我们可以在扩展的初始化方法中调用默认的初始化方法和</p>

<h2>方法</h2>

<p>扩展可以为已存在类型添加新的实例方法和类型方法。对于结构体和枚举类型而言，如果扩展的方法需要修改self或者它的属性的话，需要将实例方法标记为mutating(与结构体和枚举的原始实现相同)。</p>

<h6>代码清单4：演示了扩展方法的定义</h6>

<pre><code>extension Int {
    func repetitions(task: () -&gt; ()) {
        for i in  0..self {
            task()
        }
    }

    mutating func square() {        // mutating
        self = self * self
    }
}

var someInt = 3
someInt.square()
</code></pre>

<h2>下标</h2>

<p>扩展可以为已存在类型添加新的下标。例如我们想为Int类型添加一个下标操作，指定下标为n时，返回数字从右侧起第n个数字，即</p>

<ul>
<li><p> 123456789[0] = 9</p></li>
<li><p> 123456789[1] = 8</p></li>
<li><p> …</p></li>
</ul>


<p>代码清单5给出了相应的实现</p>

<h6>代码清单5</h6>

<pre><code>extension Int {
    subscript(digitIndex: Int) -&gt; Int {
        var decimalBase = 1
            for _ in 1...digitIndex {
                decimalBase * 10
            }
            return (self / decimalBase) % 10
    }
}

8738793219[0]   // 9
8738793219[1]   // 1
8738793219[2]   // 2
8738793219[8]   // 7
</code></pre>

<h2>嵌套类型</h2>

<p>扩展可以为已存在类型添加新的嵌套类型，如代码清单6所示</p>

<h6>代码清单6：</h6>

<pre><code>extension Character {
    enum Kind {
        case Vowel, Consonant, Other
    }

    var kind:Kind {
    switch String(self).lowercaseString {
        case "a", "e", "i", "o", "u":
            return .Vowel
        case "b", "c", "d", "f", "g", "h", "j", "k", "l", "m", "n",
             "p", "q", "r", "s", "t", "v", "w", "x", "y", "z":
            return .Consonant
        default:
            return .Other
    }
    }
}
</code></pre>

<p>上面为Character类型添加了一个嵌套枚举，以表示字符的类型。定义之后，嵌套类型就可以用于Character的值了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift属性Property]]></title>
    <link href="http://southpeak.github.io/blog/2014/06/27/ios-swift-property/"/>
    <updated>2014-06-27T20:34:38+08:00</updated>
    <id>http://southpeak.github.io/blog/2014/06/27/ios-swift-property</id>
    <content type="html"><![CDATA[<p>Swift的属性与Objective-C中的属性是一样的，不同的是Swift细化了属性的类型，另外除了类之外，结构体和枚举也可以有属性。</p>

<p>Swift中有这么几种属性：</p>

<ol>
<li>存储属性(Stored properties)：存储实例的常量和变量，与类、结构体、枚举的实例相关</li>
<li>计算属性(Computed properties)：通过某种方式计算出来的属性，只与类、结构体的实例相关，枚举没有计算属性</li>
<li>类型属性(type properties)：与类型自身相关。</li>
</ol>


<p>另外，我们可以定义属性观察者来监听属性值的改变，以执行一些额外的操作。属性观察者可以添加到自定义的存储属性上，也可以添加到父类继承而来的属性上。</p>

<p>下面我们将详细介绍这些属性</p>

<h2>存储属性</h2>

<p>存储属性是最简单的属性，它作为类或结构体实例的一部分，用于存储常量和变量。</p>

<p>关于存储属性，有以下几点：</p>

<ol>
<li>我们可以给存储属性提供一个默认值，也可以在初始化方法中对其进行初始化，即使是常量型属性，也可以这样做。</li>
<li>如果创建一个常量结构体实例，我们不能修改该实例的变量型存储属性。这是因为结构体是值类型，当一个值类型的实例标记为常量时，它的所有属性也是常量。由于类是引用类型，所以该条不适用于类类型。</li>
<li>如果我们希望属性在使用到的时候再初始化，则可以使用懒惰存储属性(lazy stored property，使用修饰符@lazy)。懒惰存储属性总是应该定义为变量，因为常量型属性总需要在初始化方法完成之前初始化。</li>
<li>与Objective-C不同的是，Swift中的属性不需要一个与之对应的成员变量，我们不能直接访问属性的后备存储(backing store)。这种方式避免了混淆不同上下文环境下对值的访问，并将属性简化为单一、明确的声明。</li>
</ol>


<h6>代码清单1：</h6>

<pre><code>struct FixedLengthRange {
    var firstValue:Int      // 变量存储属性
    let length:Int          // 常量存储属性
}

var item1 = FixedLengthRange(firstValue: 10, length: 10)

let item2 = FixedLengthRange(firstValue: 10, length: 10)
//item2.firstValue = 6        // 错误：不能修改常量结构体实例的存储属性
</code></pre>

<h2>计算属性</h2>

<p>计算属性并不存储实际的值，而是提供一个getter和一个可选的setter来间接获取和设置其它属性。</p>

<p>关于计算属性，有以下几点：</p>

<ol>
<li>如果计算属性的setter没有定义一个新值的变量名，则默认为newValue</li>
<li>如果只提供getter，而不提供setter，则该计算属性为只读属性</li>
<li>我们只能声明变量型只读属性，因为它们的值不是固定的</li>
<li>如果计算属性是只读的，则可以不使用get{}</li>
</ol>


<p>计算属性的实例如代码清单2：</p>

<h6>代码清单2：</h6>

<pre><code>struct Point {
    var x = 0.0, y = 0.0
}

struct Size {
    var width = 0.0, height = 0.0
}

struct Rect {
    var origin = Point()
    var size = Size()

    var center:Point {          // 计算属性
    get {
        let centerX = origin.x + (size.width / 2)
        let centerY = origin.y + (size.height / 2)
        return Point(x: centerX, y: centerY)
    }
    set(newCenter) {            // 若不提供新值变量名，则默认为newValue
        origin.x = newCenter.x - size.width / 2
        origin.y = newCenter.y - size.height / 2
    }
    }

    var maxX:Float {        // 只读属性，省略get{}
        return Float(origin.x) + Float(size.width)
    }
}

var square = Rect(origin:Point(x: 0.0, y: 0.0), size:Size(width:100, height:100))

let initialSquareCenter = square.center
square.center = Point(x: 15.0, y:15.0)
square.maxX
</code></pre>

<h2>类型属性</h2>

<p>类型属性是与类型相关联的，而不是与类型的实例相关联。对于某一类型的所有实例，类型属性都只有一份拷贝。对于值类型，我们可以定义存储类型属性和计算类型属性。对于类，我们只能定义计算类型属性。和实例属性不同的是，我们总是需要给存储类型属性一个默认值。这是因为类型没有初始化方法来初始化类型属性。</p>

<p>类型属性的访问和设置与实例属性一样，不一样的是，类型属性通过类型来获取和设置，而不是类型的实例</p>

<h6>代码清单3</h6>

<pre><code>struct AudioChannel {
    static let threaholdLevel = 10
    static var maxInputLevelForAllChannels = 0

    var currentLevel:Int = 0 {
    didSet{
        if currentLevel &gt; AudioChannel.threaholdLevel {
            currentLevel = AudioChannel.threaholdLevel
        }

        if currentLevel &gt; AudioChannel.maxInputLevelForAllChannels {
            AudioChannel.maxInputLevelForAllChannels = currentLevel
        }
    }
    }
}

var leftChannel = AudioChannel()
var rightChannel = AudioChannel()

leftChannel.currentLevel = 7

println(leftChannel.currentLevel)       // 7
println(AudioChannel.maxInputLevelForAllChannels)   // 7

rightChannel.currentLevel = 11
println(rightChannel.currentLevel)      // 10
println(AudioChannel.maxInputLevelForAllChannels)   // 10
</code></pre>

<h2>属性观察者</h2>

<p>属性观察者用于监听和响应属性值的变化。在每次设置属性值的时候都会调用属性观察者方法，即使新旧值是一样的。我们可以为任何存储属性定义属性观察者，除了懒惰存储属性。我们同样可以在子类中给继承而来的属性添加观察者。</p>

<p>对于计算属性，我们不需要定义属性观察者，因为我们可以在计算属性的setter中直接观察并响应这种值的变化。</p>

<p>我们通过设置以下观察方法来定义观察者</p>

<ol>
<li>willSet：在属性值被存储之前设置。此时新属性值作为一个常量参数被传入。该参数名默认为newValue，我们可以自己定义该参数名</li>
<li>didSet：在新属性值被存储后立即调用。与willSet相同，此时传入的是属性的旧值，默认参数名为oldValue。</li>
</ol>


<p>willSet与didSet只有在属性第一次被设置时才会调用，在初始化时，不会去调用这些监听方法。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift闭包二：循环引用]]></title>
    <link href="http://southpeak.github.io/blog/2014/06/27/ios-swift-closures-2/"/>
    <updated>2014-06-27T19:10:38+08:00</updated>
    <id>http://southpeak.github.io/blog/2014/06/27/ios-swift-closures-2</id>
    <content type="html"><![CDATA[<p>我们在<a href="http://southpeak.github.io/blog/2014/06/27/ios-swift-closures/">闭包的基础概念</a>中讲到闭包是引用类型的，因此，与Objective-C的block一样，可能导致循环引用的问题。</p>

<h2>问题的产生</h2>

<p>当我们给一个类指定一个闭包属性时，这个类的实例便包含了闭包的一个引用。如果在这个闭包中，又引用了类实例本身，这是闭包便创建了一个指向类实例的强引用，这种情况下，又产生了循环引用。</p>

<p>如代码清单1所示：HTMLElement类定义了一个闭包属性asHTML。在这个闭包中引用了self，即闭包捕获了self，这就意味着闭包维护了一个指向HTMLElement实例的强引用。这样就在两者间创建了一个强引用循环。</p>

<h6>代码清单1：闭包循环引用</h6>

<pre><code>class HTMLElement {

    let name:String
    let text:String?

    @lazy var asHTML:() -&gt; String = {
        if let text = self.text {
            return "&lt;\(self.name)]]&gt;\(self.text)&lt;/\(self.name)&gt;"
        } else {
            return "&lt;\(self.name) /&gt;"
        }
    }

    init(name:String, text:String? = nil) {
        self.name = name
        self.text = text
    }

    deinit {
        println("\(name) is being deinitialized")
    }
}
</code></pre>

<h2>解决方案</h2>

<p>我们可以通过“捕获列表”来解决这种循环引用问题。“捕获列表”定义了在闭包内部捕获的引用类型的使用规则。与两个类之间的强引用循环一样，我们声明每一个捕获引用为weak或者unowned引用。选择weak或者unowned依赖于两者之间的关系。</p>

<p>一个“捕获列表项”是一个weak(unowned)—类实例引用对。它们放在[]中，项与项之间使用“,”号隔开。</p>

<p>当闭包和捕获实例总是相互引用，且两者同时释放时，我们将“捕获引用”设置为unowned。如果“捕获引用”可能在某个点被设置成nil，则将其设置为weak。weak引用通常都是optional类型，当引用的实例被释放时，被设置成nil。</p>

<p>在代码清单1中，我们可以用unowned来处理这种循环引用问题。如代码清单2所示：</p>

<h6>代码清单2：unowned引用</h6>

<pre><code>class HTMLElement {

    let name:String
    let text:String?

    @lazy var asHTML:() -&gt; String = {
        [unowned self] in
        if let text = self.text {
            return "&lt;\(self.name)]]&gt;\(self.text)&lt;/\(self.name)&gt;"
        } else {
            return "&lt;\(self.name) /&gt;"
        }
    }

    init(name:String, text:String? = nil) {
        self.name = name
        self.text = text
    }

    deinit {
        println("\(name) is being deinitialized")
    }
}
</code></pre>

<p>在这种情况下，闭包维护了HTMLElement实例的一个unowned引用，而不再是一个强引用。</p>

<p>注：虽然在闭包中多次引用了self，但闭包只会维护HTMLElement实例的一个引用</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift闭包一：闭包基础概念]]></title>
    <link href="http://southpeak.github.io/blog/2014/06/27/ios-swift-closures/"/>
    <updated>2014-06-27T16:25:56+08:00</updated>
    <id>http://southpeak.github.io/blog/2014/06/27/ios-swift-closures</id>
    <content type="html"><![CDATA[<p>熟悉Objective-C的朋友一定知道Objective-C中的block，iOS在6.0后开始大量使用block。而在swift中，也提供了类似的功能：Closures(在Java等语言中翻译为“闭包”)。</p>

<p>Closures是自包含的功能块。它可以捕获和存储其所在上下文的常量和变量的引用。全局函数和嵌套函数其实都是闭包。闭包有以下三种形式：</p>

<ol>
<li>全局函数：有函数名，但不能获取任何外部值</li>
<li>嵌套函数：有函数名，同时可以从其上下文中捕获值</li>
<li>闭包表达式：以一种轻量级的语法定义的未命名闭包，可以从其上下文中捕获值</li>
</ol>


<p>swift对闭包表达式作了一些优化处理，主要包括：</p>

<ol>
<li>从上下方中推断出参数和返回值</li>
<li>可以从单一表达式闭包中隐式返回</li>
<li>速记(Shorthand)参数名</li>
<li>尾随闭包语法</li>
</ol>


<p>下面会对这几点分别说明</p>

<h2>闭包表达式</h2>

<p>闭包表达式提供了一种更加简洁、专注的方式来实现内嵌函数的功能。闭包表达式的通用格式如下</p>

<pre><code>{(parameters) -&gt; return type in
    statement   
}
</code></pre>

<p>闭包的参数可以是常量、变量、inout、可变参数列表、元组，但是不能提供默认值。返回值可以是通用类型，也可以是元组。闭包实现体位于in关键字后面，该关键字是闭包参数和返回值的声明和实现体的分界。</p>

<h6>代码清单1: 使用sort函数对数组进行排序</h6>

<pre><code>let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]

// 方法1：使用普通函数(或内嵌函数)提供排序功能
func backwards(s1:String, s2:String) -&gt; Bool {
    return s1 &gt; s2
}

var reversed = sort(names, backwards)

// 方法2：使用闭包表达式提供排序功能
reversed = sort(names, {
        (s1:String, s2:String) -&gt; Bool in
            return s1 &gt; s2
    })

// 方法3：类型推断,省略闭包表达式的参数及返回类型
reversed = sort(names, { s1, s2 in return s1 &gt; s2})

// 方法4：单一表达式：省略return关键字
reversed = sort(names, { s1, s2 in s1 &gt; s2 })

// 方法5：速记参数名
reversed = sort(names, { $0 &gt; $1 })

// 方法6：操作符函数
reversed = sort(names, &gt;)
</code></pre>

<p>swift标准库提供了sort用来对数据进行排序，它包含两个参数：</p>

<ol>
<li>待排序的已知类型的数组</li>
<li>排序函数(闭包)：带有两个类型相同的参数，并返回Bool值来告知第一个参数是显示排在第二个参数之前还是之后。</li>
</ol>


<p>代码清单1提供了几种方式来实现sort的排序函数</p>

<ol>
<li>方法1：使用普通函数(嵌套函数)，这种方法略显示复杂，且代码不够紧凑</li>
<li>方法2：内联闭包表达式，参数和返回值都位于大括号内，而不是外部</li>
<li>方法3：借助于swift强大的类型推断功能，我们甚至可以省略参数和返回值的类型。这样返回箭头->和返回类型都可以省略。在传递闭包给函数时，总是可以推断出参数类型和返回值，所以，我们很少需要明确写出内联闭包的完整格式。</li>
<li>方法4：如果闭包体只有一行代码，则可以省略retrun关键字，让闭包隐式返回单一表达式的值。</li>
<li>方法5：速记(Shorthand)参数名：swift为内联闭包提供了速记参数名，可以通过$0, $1, $2等参数名来索引闭包的参数。如果使用这种参数名，则可以直接省略参数列表，而参数的个数和类型可以自动推断出来。in关键字也可以省略</li>
<li>方法6：更极端的情况是，swift的字符串类型定义了>操作符，该操作符可以看作是带有两个参数的函数，并返回一个Bool值。而这正好符合sort函数的需求，我们可以只是简单的传入一个>，swift可以自动推断出我们想使用的实现。</li>
</ol>


<h2>尾随闭包(Trailing Closures)</h2>

<p>如果将闭包作为函数的最后一个参数，且闭包的实现体很长，则调用函数时可以使用尾随闭包。尾随闭包位于参数列表括号的后面。其格式如下：</p>

<pre><code>someFunctionThatTakesAClosure() {
    // 尾随闭包实现    
}
</code></pre>

<p>因此sort函数同样可以如下实现</p>

<h6>代码清单2: 使用尾随闭包实现sort函数</h6>

<pre><code>// 方法7：尾随闭包
reversed = sort(names) { $0 &gt; $1 }
</code></pre>

<p>另外，如果函数只有一个闭包参数，同时将闭包参数实现为尾随闭包，则在调用函数时可以省略参数列表的()，如代码清单3所示：</p>

<h6>代码清单3：函数只有一个闭包参数，同时将闭包参数实现为尾随闭包</h6>

<pre><code>let strings = numbers.map {
    (var name) -&gt; String in
    var output = ""
    while number &gt; 0 {
        output = digitNames[number % 10]! + output
        number /= 10
    }

    return number
}
</code></pre>

<h2>获取上下文的值</h2>

<p>和Objective-C的block一样，闭包可以获取定义它的上下文中常量或变量的值，同时可以在闭包体内引用和修改这些常量或变量的值，即使定义这些常量或变量的域已经销毁。</p>

<p>由于内嵌函数也是闭包，因此我们以内嵌函数为例，看看闭包如何获取上下文的常量和变量</p>

<h6>代码清单4：获取上下文值</h6>

<pre><code>func makeIncrementor(amount:Int) -&gt; () -&gt; Int {
    var runningTotal = 0
    func incrementor() -&gt; Int {
        runningTotal += amount
        return runningTotal
    }

    return incrementor
}
</code></pre>

<p>在代码清单4中，内嵌函数incriminator从上下文获取了两个值runningTotal和amount，其中amount是函数makeIncrementor的参数，runningTotal是函数内部定义的变量。由于incrementor没有修改amount，所以它实际上存储了amount的一份拷贝。而runningTotal在incremetor中被修改了，因此increminator存储了runningTotal的引用，这样确保runningTotal一直有效。</p>

<p>swift决定捕获的值哪些需要拷贝值，而哪些只拷贝引用。在runningTotal不再使用时，swift负责释放其内存。</p>

<h6>代码清单5：makeIncrementor使用</h6>

<pre><code>let incrementByTen = makeIncrementor(amount:10)

incrementByTen()    // returns a value of 10
incrementByTen()    // returns a value of 20
incrementByTen()    // returns a value of 30

// 定义另一个incrementor，则它有自己独立的runningTotal
let incrementBySeven = makeIncrementor(amount:7)

incrementBySeven()  // returns a value of 7
incrementBySeven()  // returns a value of 14
incrementBySeven()  // returns a value of 21
</code></pre>

<h2>引用类型</h2>

<p>在代码清单5中，虽然incrementByTen和incrementBySeven定义为常量，但是闭包仍然可以增加runningTotal的值。这是因为函数和闭包都是引用类型。</p>

<p>当定义一个函数(闭包)常量或变量时，实际上定义的是一个指向函数(闭包)的引用。这意味着如果指定一个闭包给两个不同的常量或变量，则这两个常量和变量将引用同一个函数(闭包)</p>

<h6>代码清单6：引用函数(闭包)</h6>

<pre><code>let incrementByTen = makeIncrementor(amount:10)
incrementByTen()    // returns a value of 10
incrementByTen()    // returns a value of 20
incrementByTen()    // returns a value of 30

let alsoIncrementByTen = incrementByTen
alsoIncrementByTen()  // returns a value of 40
</code></pre>

<p>这样，就引出另一个问题：循环引用。我们将会在<a href="http://southpeak.github.io/blog/2014/06/27/ios-swift-closures-2/">下一篇文章</a>中介绍这个问题。</p>
]]></content>
  </entry>
  
</feed>
