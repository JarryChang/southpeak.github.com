<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ios | 南峰子的技术博客]]></title>
  <link href="http://southpeak.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://southpeak.github.io/"/>
  <updated>2014-10-19T21:41:27+08:00</updated>
  <id>http://southpeak.github.io/</id>
  <author>
    <name><![CDATA[南峰子]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS技术周报：第一期(2014.10.13 ~ 2014.10.19)]]></title>
    <link href="http://southpeak.github.io/blog/2014/10/19/iosji-zhu-zhou-bao-:di-%5B%3F%5D-qi-2014-dot-10-dot-13-~-2014-dot-10-dot-19/"/>
    <updated>2014-10-19T21:12:35+08:00</updated>
    <id>http://southpeak.github.io/blog/2014/10/19/iosji-zhu-zhou-bao-:di-[?]-qi-2014-dot-10-dot-13-~-2014-dot-10-dot-19</id>
    <content type="html"><![CDATA[<h2>1. 自定义下标操作</h2>

<p>对于数组与字典，我们可以使用下标来获取指定下标对应的值，如：</p>

<pre><code>NSArray *array = @[@1, @2, @3];
id value1 = array[0];        // 1

NSDictionary *dic = @{@"1": @1, @"2": @2, @"3": @3};
id value2 = dic[@"2"];      // 2
</code></pre>

<p>另外，Objective-C还支持自定义下标操作。我们先来看看如下代码：</p>

<pre><code>@interface MyCollection : NSObject

@property (nonatomic, retain) NSMutableArray *array;
@property (nonatomic, retain) NSMutableDictionary *dictionary;

@end
</code></pre>

<p>我们定义MyCollection类的一个实例，然后可以按如下方式访问array的元素</p>

<pre><code>MyCollection *collection = [[MyCollection alloc] init];
id arrElement = collection.array[0];
collection.array[1] = @"1";
id arrDic = collection.dictionary[@"test"];
collection.dictionary[@"id"] = @"abc";
</code></pre>

<p>但这样写代码略显麻烦，毕竟中间多用了一次".&ldquo;操作。这种情况下，我们就可以为我们的类自定义相应的下标操作，来简单这种集合元素的访问。自定义下标使用到了如下几个方法：</p>

<ol>
<li>NSArray : &ndash; (id)objectAtIndexedSubscript:(NSUInteger)index;</li>
<li>NSMutableArray : &ndash; (void)setObject: (id)obj atIndexedSubscript: (NSUInteger)index;</li>
<li>NSDictionary : &ndash; (id)objectForKeyedSubscript: (id <NSCopying>)key;</li>
<li>NSMutableDictionary : &ndash; (void)setObject: (id)anObject forKeyedSubscript: (id <NSCopying>)aKey;</li>
</ol>


<p>我们为MyCollection类定义下标操作，代码如下所示：</p>

<pre><code>@implementation MyCollection

- (id)objectAtIndexedSubscript:(NSUInteger)index {
    return _array[index];
}

- (void)setObject:(id)obj atIndexedSubscript:(NSUInteger)index {
    _array[index] = obj;
}

- (id)objectForKeyedSubscript:(id&lt;NSCopying&gt;)key {
    return _dictionary[key];
}

- (void)setObject:(id)anObject forKeyedSubscript:(id&lt;NSCopying&gt;)aKey {
    _dictionary[aKey] = anObject;
}

@end
</code></pre>

<p>这样，我们就可以直接用下标操作来访问类中array属性和dictionary属性的元素了，如下所示：</p>

<pre><code>MyCollection *collection = [[MyCollection alloc] init];
id arrElement = collection[0];
collection[1] = @"1";
id arrDic = collection[@"test"];
collection[@"id"] = @"abc";
</code></pre>

<p><em>注：数组与字典本身也是实现了这些方法来支持下标操作</em></p>

<h2>2. NSInvocation的使用</h2>

<p>一个NSInvocation实例是一个静态呈现的Objective-C消息，换句话说，它是一个被转换成对象的一个动作。NSInvocation对象用于在对象间和应用间存储和转发消息，主要通过NSTimer对象和分布式对象系统来实现转发。</p>

<p>一个NSInvocation对象包含一个Objective-C消息所具有的元素：目标、selector、参数和返回值。所有这些元素可以直接设置，而返回值会在NSInvocation对象分发时被自动设置。</p>

<p>一个NSInvocation对象可以被多次分发到不同的目标(target)；它的参数可以在不同的分发中使用不同的值，以获取到不同的结果；甚至于它的selector也可以修改，只需要方法签名一样即可。这种灵活性使得NSInvocation在多次调用带有较多参数的消息的场景下非常有用；我们不需要为每个消息都键入不同的表达式，我们只需要每次在将消息发到新的目标时根据需要修改NSInvocation对象就可以。</p>

<p>NSInvocation对象不支持带有可变参数或联合参数的方法调用。我们应该使用invocationWithMethodSignature:方法来创建NSInvocation对象；而不应该使用alloc和init来创建。</p>

<p>这个类默认情况下不会为调用retain参数。如果这些参数(对象)可能会在创建NSInvocation对象和使用它这个时间段中间被释放，那么我们需要显示地retain这些对象，或者调用retainArguments方法来让调用对象自己retain它们。</p>

<p>NSInvocation的使用如下所示：</p>

<pre><code>// 代码来自ReactiveCocoa源码的RACBlockTrampoline类

- (id)invokeWithArguments:(RACTuple *)arguments {
    SEL selector = [self selectorForArgumentCount:arguments.count];
    NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:[self methodSignatureForSelector:selector]];
    invocation.selector = selector;
    invocation.target = self;

    for (NSUInteger i = 0; i &lt; arguments.count; i++) {
        id arg = arguments[i];
        NSInteger argIndex = (NSInteger)(i + 2);
        [invocation setArgument:&amp;arg atIndex:argIndex];
    }

    [invocation invoke];

    __unsafe_unretained id returnVal;
    [invocation getReturnValue:&amp;returnVal];
    return returnVal;
}
</code></pre>

<p>这里需要注意的是在调用setArgument:atIndex:时，参数的索引位置是从2开始的。因为索引0和1分别指向的是隐藏参数<strong>self</strong>和<strong>_cmd</strong>。这两个值是直接通过target和selector属性来设置的。</p>

<h4>参考</h4>

<ol>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSInvocation_Class">NSInvocation Class Reference</a></li>
</ol>


<h2>3. 方法签名</h2>

<p>在Objective-C中，方法签名由NSMethodSignature类来表示。</p>

<p>一个NSMethodSignature对象记录了方法的参数及返回值的类型信息。它主要用于转发那些接收对象无法响应的消息&mdash;最值得注意的是分发对象。通常我们会使用NSObject对象的methodSignatureForSelector:方法来创建一个NSMethodSignature对象。然后这个对象用于创建一个NSInvocation对象，这个对作为参数被传递到forwardInvocation:方法中，以将这个方法调用发送到任何其它对象以处理这个消息。默认情况下，NSObject调用doesNotRecognizeSelector:方法并引发一个异常。对于分发对象，NSInvocation对象通过NSMethodSignature对象的信息来编码，并被发送到一个表示消息接收者的真实对象中。</p>

<p>一个NSMethodSignature对象通过getArgumentTypeAtIndex:方法来获取指定索引位置的参数类型(该方法返回值是const char *, 用C字符串来表示Objective-C类型编码)。对于每个方法来说，有两个隐藏的参数，即self和_cmd，索引分别为0和1。除了参数类型，NSMethodSignature还有几个属性：numberOfArguments属性用来获取参数的个数；frameLength属性用来获取所有参数所占用的栈空间长度，以及methodReturnLength和methodReturnType获取返回值的长度和类型。最后，使用分发对象的程序可以通过isOneway方法来确定方法是否是异步的。</p>

<p>NSMethodSignature示例代码如下：</p>

<pre><code>// 代码摘自ReactiveCocoa:NSObject+RACLifting

- (RACSignal *)rac_liftSelector:(SEL)selector withSignalOfArguments:(RACSignal *)arguments {
    NSCParameterAssert(selector != NULL);
    NSCParameterAssert(arguments != nil);

    @unsafeify(self);

    NSMethodSignature *methodSignature = [self methodSignatureForSelector:selector];
    NSCAssert(methodSignature != nil, @"%@ does not respond to %@", self, NSStringFromSelector(selector));

    return [[[[arguments
            takeUntil:self.rac_willDeallocSignal]
            map:^(RACTuple *arguments) {
                @strongify(self);

                NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:methodSignature];
                invocation.selector = selector;
                invocation.rac_argumentsTuple = arguments;
                [invocation invokeWithTarget:self];

                return invocation.rac_returnValue;
            }]
            replayLast]
            setNameWithFormat:@"%@ -rac_liftSelector: %s withSignalsOfArguments: %@", [self rac_description], sel_getName(selector), arguments];
}
</code></pre>

<h4>参考</h4>

<ol>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSMethodSignature_Class/index.html#//apple_ref/doc/c_ref/NSMethodSignature">NSMethodSignature Class Reference</a></li>
</ol>


<h2>4. CFBridgingRelease/CFBridgingRetain</h2>

<p>这两个函数的作用类似于__bridge，用于在ARC环境下，在Cocoa Fundation和Core Funcation之间转换可桥接对象。</p>

<p>CFBridgingRetain函数是将Objective-C指针转换为Core Foundation指针，同时会转移对象所有权。如下代码所示：</p>

<pre><code>NSString *string = &lt;#Get a string#&gt;;
CFStringRef cfString = (CFStringRef)CFBridgingRetain(string);

// Use the CF string.
CFRelease(cfString);
</code></pre>

<p>通过这种转换，我们可以管理对象的生命周期。转换后，对象的释放就由我们来负责了。</p>

<p>相反，CFBridgingRelease函数是将一个非Objective-C指针转换为Objective-C指针，同时转移对象的权(ARC)。如下代码所示：</p>

<pre><code>CFStringRef cfName = ABRecordCopyValue(person, kABPersonFirstNameProperty);
NSString *name = (NSString *)CFBridgingRelease(cfName);
</code></pre>

<p>转换后，我们不需要手动去释放对象，因为这是在ARC环境所做的转换。</p>

<h4>参考</h4>

<ol>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Miscellaneous/Foundation_Functions">Foundation Functions Reference</a></li>
</ol>


<h2>5. NSProcessInfo</h2>

<p>这个类用来访问当前进程的信息。每一个进程都有一个单独的共享的NSProcessInfo对象，即为进程信息代理(Process information agent)，它可以返回诸如参数，环境变量，主机名或进程名等信息。方法processInfo类方法会返回当前进程共享的代理&mdash;即发送消息的对象所在的进程。我们可以如下获取当前进程的名字：</p>

<pre><code>NSString *processName = [[NSProcessInfo processInfo] processName];
</code></pre>

<p>NSProcessInfo对象在还能解析环境变量和命令行参数，如果无法使用Unicode编码将其表示为一个UTF-8字符串，则会将其编码成用户默认的C字符串编码格式。如果两种转换都无效，则NSProcessInfo对象会忽略这些值。</p>

<h4>管理Activity</h4>

<p>系统会以启发式(heuristics)的方法来改善电池寿命，性能和应用的响应。我们可以使用下面的方法来管理一些Activity，以告诉系统程序有特殊的需求：</p>

<pre><code>beginActivityWithOptions:reason:

endActivity:

performActivityWithOptions:reason:usingBlock:
</code></pre>

<p>为了响应创建Activity，系统会禁用部分或全部的heuristics，以便我们的程序尽快完成，而如果用户需要的话，同样还能提供响应操作。我们会在程序需要执行一个长时间运行的操作时使用Activity。如果Activity可能会消耗不同的时间，则应该使用这些API。这会在数据量或用户的计算机性能改变时，确保操作的正确。</p>

<p>Activity主要分为两类：</p>

<ol>
<li>用户启动(User initiated)的Activity：这些是用户显示开启的有限时长的Activity。比如导入或下载一个用户文件。</li>
<li>后台Activity：这些Activity是程序普通操作的一部分且是有限时长的，但不是由用户显示启动的。如自动保存、索引及自动下载文件。</li>
</ol>


<p>此外，如果程序需要高优先级的I/O操作，则可以包含NSActivityLatencyCritical标识(使用OR操作)。我们只应该在诸如录制视频音频这样确实需要高优先级的Activity中使用这个标识。</p>

<p>如果我们的Activity在主线程的事件回调中同步发生，则不需要使用这些API。</p>

<p>需要注意的是，如果在一个延长的时间周期内没有结束这些Activity，则会对设备的运行性能产生明显的负面影响，所以确保只使用最少的时间。用户偏好设置可能会重写应用的请求。</p>

<p>我们也可以用这些API来控制自动终止或突然终止。如</p>

<pre><code>id activity = [[NSProcessInfo processInfo] beginActivityWithOptions:NSActivityAutomaticTerminationDisabled reason:@"Good Reason"];
// Perform some work.
[[NSProcessInfo processInfo] endActivity:activity];
</code></pre>

<p>当然也可以使用</p>

<pre><code>[[NSProcessInfo processInfo] disableAutomaticTermination:@"Good Reason"];
// Perform some work.
[[NSProcessInfo processInfo] enableAutomaticTermination:@"Good Reason"];
</code></pre>

<p>不过由于上面这个接口返回一个对象，它可以方便地匹配开始和结束操作。如果这个对象在endActivity:方法调用之前被释放，则Activity会自动结束。</p>

<p>这个API也提供了禁用/执行系统范围内的闲置睡眠的机制。这可能对用户体验产生重大影响，所以确保不要忘记结束那些禁用睡眠的Activity。</p>

<h4>突然终止(Sudden Termination)</h4>

<p>在OS X v10.6及后续版本中有一个机制，它允许系统通过杀死应用程序来更快地输出日志或关机，而不是要求程序自行终止。应用程序可以在全局范围内开启这一功能，然后在可能导致数据损坏或较差用户体验的操作中重写这一功能的可用性。或者，我们的应用程序可以手动开启和禁用这一功能。</p>

<p>enableSuddenTermination和disableSuddenTermination方法分别会减少和增加一个计数器，其值在进程首次创建时为1。当计数器值为0时，程序会被认为是可安全杀死的，且可能在没有任何通知或事件被发送到进程时被系统杀死。</p>

<p>应用程序可以在程序的Info.plist文件中添加NSSupportsSuddenTermination键值来决定是否支持突然终止。如果该值存在且值为YES，则相当于在启动时调用了enableSuddenTermination。这使得程序可以立即被杀死。我们可以通过调用disableSuddenTermination方法来修改这种行为。</p>

<p>通常情况下，当我们的程序延迟那些必须在程序终止前才执行的操作时，我们会禁用突然终止行为。例如，如果程序延迟写磁盘操作，而突然终止行为可用，则我们应该将这些操作放在disableSuddenTermination方法与enableSuddenTermination方法之间执(注意，应该是先禁用、然后执行操作、最后再开启)。</p>

<p>一些AppKit功能会临时自动禁用突然终止行为，以确保数据完整性。如</p>

<ol>
<li>NSUserDefaults临时自动禁用突然终止行为以防止进程在设置值和将值写入磁盘这之间被杀死。</li>
</ol>


<h4>参考</h4>

<ol>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSProcessInfo_Class/">NSProcessInfo Class Reference</a></li>
</ol>


<h2>6. 快速枚举</h2>

<p>快速枚举即我们常写的for&hellip;in语句，可以让我们用简洁的语法来安全、有效地枚举集合中的内容。其基本用法如下</p>

<pre><code>for (type 变量 in 表达式) {
    // to do something
}
</code></pre>

<p>其中迭代变量会被赋值为表达式值对象中的每一个元素，并针对每一个元素执行处理语句。当循环结束后，迭代变量会被赋值为nil。如果循环提前结束，则迭代变量的值将指向最后一次遍历的那个对象。</p>

<p>要使用这种控制语句，则表达式的值必须遵循NSFastEnumeration协议。该协议中定义了一个用作上下文信息的结构体：</p>

<pre><code>typedef struct {
      unsigned long state;
      id *itemsPtr;
      unsigned long *mutationsPtr;
      unsigned long extra[5];
} NSFastEnumerationState;
</code></pre>

<p>及一个必须实现的方法</p>

<pre><code>- (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state
                                  objects:(id [])stackbuf
                                    count:(NSUInteger)len
</code></pre>

<p>该方法通过C数组返回发送者需要迭代的对象列表，并返回数组中对象的个数。</p>

<p>Cocoa中的集合类NSArray, NSDictionary和NSSet都遵循该协议，NSEnumerator类也是。</p>

<p>示例代码如下：</p>

<pre><code>// 代码摘自ReactiveCocoa: RACIndexSetSequence

- (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state objects:(__unsafe_unretained id[])stackbuf count:(NSUInteger)len {
    NSCParameterAssert(len &gt; 0);

    if (state-&gt;state &gt;= self.count) {
        // Enumeration has completed.
        return 0;
    }

    if (state-&gt;state == 0) {
        // Enumeration begun, mark the mutation flag.
        state-&gt;mutationsPtr = state-&gt;extra;
    }

    state-&gt;itemsPtr = stackbuf;

    unsigned long index = 0;
    while (index &lt; MIN(self.count - state-&gt;state, len)) {
        stackbuf[index] = @(self.indexes[index + state-&gt;state]);
        ++index;
    }

    state-&gt;state += index;
    return index;
}
</code></pre>

<p>从上面的代码可以看到，快速枚举使用了指针运算，所以它比使用NSEnumerator的标准方法效率更高。</p>

<h4>参考</h4>

<ol>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSEnumerator_Class/index.html">NSEnumerator Class Reference</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/NSFastEnumeration_protocol/index.html#//apple_ref/occ/intf/NSFastEnumeration">NSFastEnumeration Protocol Reference</a></li>
<li><a href="http://www.ituring.com.cn/article/details/1348">Objective-C——在Cocoa Touch框架中使用迭代器模式</a></li>
<li><a href="http://blog.csdn.net/amdbenq/article/details/7862718">快速枚举</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[instancetype]]></title>
    <link href="http://southpeak.github.io/blog/2014/10/19/instancetype/"/>
    <updated>2014-10-19T00:26:03+08:00</updated>
    <id>http://southpeak.github.io/blog/2014/10/19/instancetype</id>
    <content type="html"><![CDATA[<p>注：原文由Mattt Thompson发表于nshipster：<a href="http://nshipster.com/instancetype/">instancetype</a>。<strong>文章是2012年写的，所以有些内容现在已不适用。</strong></p>

<p>在Objective-C中，约定(conventions)不仅仅是编码最佳实践的问题，同时对编译器来说，也是一种隐式说明。</p>

<p>例如，alloc和init两个方法都返回id类型，而在Xcode中，编译器会对它们进行类型检查。这是怎么做到的呢？</p>

<p>在Cocoa中，有一个这样的约定，命名为alloc/init的方法总是返回接收者类的实例。这些方法有一个相关的返回类型。</p>

<p>而类的构造方法(类方法)，虽然他们都是返回id类型，但没有从类型检查中获得好处，因为他们不遵循命名约定。</p>

<p>我们可以试试以下代码：</p>

<pre><code>[[[NSArray alloc] init] mediaPlaybackAllowsAirPlay]; // 报错： "No visible @interface for `NSArray` declares the selector `mediaPlaybackAllowsAirPlay`"

[[NSArray array] mediaPlaybackAllowsAirPlay]; // (No error) 注：这个方法调用只在老的编译器上成立，新的编译器会报相同的错误。
</code></pre>

<p>由于alloc和init遵循返回相关结果类型的约定，所以会对NSArray执行类型检查。然而等价的类构造方法array则不遵循这一约定，只解释为id类型。</p>

<p>id类型在不需要确保类型安全时非常有用，但一旦需要时，就无法处理了。</p>

<p>而另一种方法，即显示声明返回类型(如前面例子中的(NSArray *))稍微改善了一些，但写起来有点麻烦，而且在继承体系中表现得不是很好。</p>

<p>这时编译器就需要去解决这种针对Objective-C类型系统的边界情况了:</p>

<p>instancetype是一个上下文关键字，可用在返回类型中以表示方法返回一个相关的结果类型，如：</p>

<pre><code>@interface Person
+ (instancetype)personWithName:(NSString *)name;
@end
</code></pre>

<p>使用instancetype，编译器可以正确地知道personWithName:的返回结果是一个Person实例。</p>

<p>我们现在看Foundation中的类构造器，可以发现大部分已经开始使用了instancetype了。新的API，如UICollectionViewLayoutAttributes，都是使用instancetype了。</p>

<p><em>注：instancetype与id不同的是，它只能用在方法声明的返回值中。</em></p>

<h4>更进一步的启示</h4>

<p>语言特性是特别有趣的，因为它不清楚在软件设计的更高层次方面会带来什么样的影响。</p>

<p>虽然instancetype看上去非常一般，只是对编译器有用，但也可能被用于一些更聪明的目的。</p>

<p>Jonathan Sterling的文章<a href="http://www.jonmsterling.com/posts/2012-02-05-typed-collections-with-self-types-in-objective-c.html">this quite interesting article</a>，详细描述了instancetype如何被用于编码静态类型集合，而不需要使用泛型：</p>

<pre><code>NSURL &lt;MapCollection&gt; *sites = (id)[NSURL mapCollection];
[sites put:[NSURL URLWithString:@"http://www.jonmsterling.com/"]
        at:@"jon"];
[sites put:[NSURL URLWithString:@"http://www.nshipster.com/"]
        at:@"nshipster"];

NSURL *jonsSite = [sites at:@"jon"]; // =&gt; http://www.jonmsterling.com/
</code></pre>

<p>静态类型集合使得API更有表现力，这样开发者将不再需要去确定集合中的参数可以使用使用类型的对象了。</p>

<p>不管这会不会成为Objective-C公认的约定，诸如instancetype这样一个低层特性可用于改变语言的形态已是非常棒的一件事了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OSAtomic原子操作]]></title>
    <link href="http://southpeak.github.io/blog/2014/10/17/osatomicyuan-zi-cao-zuo/"/>
    <updated>2014-10-17T10:56:00+08:00</updated>
    <id>http://southpeak.github.io/blog/2014/10/17/osatomicyuan-zi-cao-zuo</id>
    <content type="html"><![CDATA[<p>并发编程一个主要问题就是如何同步数据。同步数据的方式有很多种，这里我们介绍一下libkern/OSAtomic.h。这个头文件包含是大量关于原子操作和同步操作的函数，如果要对数据进行同步操作，这里面的函数可以作为我们的首选项。不同平台这些函数的实现是自定义的。另外，它们是线程安全的。</p>

<p>需要注意的是，传递给这些函数的所有地址都必须是“自然对齐”的，例如int32_t * 指针必须是32位对齐的(地址的低位2个bit为0)，int64_t * 指针必须是64位对齐的(低3位为0)。</p>

<p>这些原子函数的一些版本整合了内存屏障(memory barriers)，而另一些则没有。在诸如PPC这样的弱有序(weakly-ordered)架构中，Barriers严格限制了内存访问顺序。所有出现在barriers之前的加载和存储操作完成后，才会运行barriers之后的加载和存储操作。</p>

<p>在单处理器系统中，barriers操作通常是一个空操作。在多处理器系统中，barriers在某些平台上可能是相当昂贵的操作，如PPC。</p>

<p>大多数代码都应该使用barrier函数来确保在线程间共享的内存是正确同步的。例如，如果我们想要初始化一个共享的数据结构，然后自动增加某个变量值来标识初始化操作完成，则我们必须使用OSAtomicIncrement32Barrier来确保数据结构的存储操作在变量自动增加前完成。</p>

<p>同样的，该数据结构的消费者也必须使用OSAtomicIncrement32Barrier，以确保在自动递增变量值之后再去加载这些数据。另一方面，如果我们只是简单地递增一个全局计数器，那么使用OSAtomicIncrement32会更安全且可能更快。</p>

<p>如果不能确保我们使用的是哪个版本，则使用barrier变量以保证是安全的。</p>

<p>另外，自旋锁和队列操作总是包含一个barrier。</p>

<p>这个头文件中的函数主要可以分为以下几类</p>

<h2>内存屏障(Memory barriers)</h2>

<p>内存屏障的概念如上所述，它是一种屏障和指令类，可以让CPU或编译器强制将barrier之前和之后的内存操作分开。CPU采用了一些可能导致乱序执行的性能优化。在单个线程的执行中，内存操作的顺序一般是悄无声息的，但是在并发编程和设备驱动程序中就可能出现一些不可预知的行为，除非我们小心地去控制。排序约束的特性是依赖于硬件的，并由架构的内存顺序模型来定义。一些架构定义了多种barrier来执行不同的顺序约束。</p>

<p>OSMemoryBarrier()函数就是用来设置内存屏障，它即可以用于读操作，也可以用于写操作。</p>

<p>示例代码：</p>

<pre><code>// 代码来自ReactiveCocoa:RACDisposable类

- (id)initWithBlock:(void (^)(void))block {
    NSCParameterAssert(block != nil);

    self = [super init];
    if (self == nil) return nil;

    _disposeBlock = (void *)CFBridgingRetain([block copy]);
    OSMemoryBarrier();

    return self;
}
</code></pre>

<h2>自旋锁(Spinlocks)</h2>

<p>自旋锁是在多处理器系统(SMP)上为保护一段关键代码的执行或者关键数据的一种保护机制，是实现synchronization的一种手段。</p>

<p>libkern/OSAtomic.h中包含了三个关于自旋锁的函数：OSSpinLockLock, OSSpinLockTry, OSSpinLockUnlock</p>

<p>示例代码：</p>

<pre><code>// 代码来自ReactiveCocoa:RACCompoundDisposable类

- (void)dispose {
#if RACCompoundDisposableInlineCount
    RACDisposable *inlineCopy[RACCompoundDisposableInlineCount];
#endif

    CFArrayRef remainingDisposables = NULL;

    OSSpinLockLock(&amp;_spinLock);
    {
        _disposed = YES;

#if RACCompoundDisposableInlineCount
        for (unsigned i = 0; i &lt; RACCompoundDisposableInlineCount; i++) {
            inlineCopy[i] = _inlineDisposables[i];
            _inlineDisposables[i] = nil;
        }
#endif

        remainingDisposables = _disposables;
        _disposables = NULL;
    }
    OSSpinLockUnlock(&amp;_spinLock);

#if RACCompoundDisposableInlineCount
    // Dispose outside of the lock in case the compound disposable is used
    // recursively.
    for (unsigned i = 0; i &lt; RACCompoundDisposableInlineCount; i++) {
        [inlineCopy[i] dispose];
    }
#endif

    if (remainingDisposables == NULL) return;

    CFIndex count = CFArrayGetCount(remainingDisposables);
    CFArrayApplyFunction(remainingDisposables, CFRangeMake(0, count), &amp;disposeEach, NULL);
    CFRelease(remainingDisposables);
}
</code></pre>

<h2>原子队列操作</h2>

<p>队列操作主要包含两类：</p>

<ol>
<li>不加锁的FIFO入队和出队原子操作，包含OSAtomicFifoDequeue和OSAtomicFifoEnqueue两个函数</li>
<li>不加锁的LIFO入队和出队原子操作，包含OSAtomicDequeue和OSAtomicEnqueue两个函数。这两个函数是线程安全的，对有潜在精确要求的代码来说，这会是强大的构建方式。</li>
</ol>


<h2>比较和交换</h2>

<p>这组函数可以细分为三组函数：</p>

<ol>
<li>OSAtomicCompareAndSwap**[Barrier](type __oldValue, type __newValue, volatile type *__theValue)：这组函数用于比较__oldValue是否与__theValue指针指向的内存位置的值匹配，如果匹配，则将__newValue的值存储到__theValue指向的内存位置。可以根据需要使用barrier版本。</li>
<li>OSAtomicTestAndClear/OSAtomicTestAndClearBarrier( uint32_t __n, volatile void *__theAddress )：这组函数用于测试__theAddress指向的值中由__n指定的bit位，如果该位未被清除，则清除它。需要注意的是最低bit位应该是1，而不是0。对于一个64-bit的值来说，如果要清除最高位的值，则__n应该是64。</li>
<li>OSAtomicTestAndSet/OSAtomicTestAndSetBarrier(uint32_t __n, volatile void *__theAddress)：与OSAtomicTestAndClear相反，这组函数测试值后，如果指定位没有设置，则设置它。</li>
</ol>


<p>示例代码：</p>

<pre><code>void * sharedBuffer(void)
{
    static void * buffer;
    if (buffer == NULL) {
        void * newBuffer = calloc(1, 1024);
        if (!OSAtomicCompareAndSwapPtrBarrier(NULL, newBuffer, &amp;buffer)) {
            free(newBuffer);
        }
    }
    return buffer;
}
</code></pre>

<p>上述代码的作用是如果没有缓冲区，我们将创建一个newBuffer，然后将其写到buffer中。</p>

<h2>布尔操作(AND, OR, XOR)</h2>

<p>这组函数可根据以下两个规则来分类：</p>

<ol>
<li>是否使用Barrier</li>
<li>返回值是原始值还是操作完成后的值</li>
</ol>


<p>以And为例，有4个函数：OSAtomicAnd32, OSAtomicAnd32Barrier, OSAtomicAnd32Orig, OSAtomicAnd32OrigBarrier。每个函数均带有两个参数：__theMask(uint32_t)和__theValue(volatile uint32_t *)。函数将__theMask与__theValue指向的值做AND操作。</p>

<p>类似，还有OR操作和XOR操作。</p>

<h2>数学操作</h2>

<p>这组函数主要包括：</p>

<ol>
<li>加操作：OSAtomicAdd**, OSAtomicAdd**Barrier</li>
<li>递减操作：OSAtomicDecrement**, OSAtomicDecrement**Barrier</li>
<li>递增操作：OSAtomicIncrement**, OSAtomicIncrement**Barrier</li>
</ol>


<p>示例代码：</p>

<pre><code>// 代码摘自ReactiveCocoa:RACDynamicSequence

- (void)dealloc {
    static volatile int32_t directDeallocCount = 0;

    if (OSAtomicIncrement32(&amp;directDeallocCount) &gt;= DEALLOC_OVERFLOW_GUARD) {
        OSAtomicAdd32(-DEALLOC_OVERFLOW_GUARD, &amp;directDeallocCount);

        // Put this sequence's tail onto the autorelease pool so we stop
        // recursing.
        __autoreleasing RACSequence *tail __attribute__((unused)) = _tail;
    }

    _tail = nil;
}
</code></pre>

<h2>小结</h2>

<p>相较于@synchronized，OSAtomic原子操作更趋于数据的底层，从更深层次来对单例进行保护。同时，它没有阻断其它线程对函数的访问。</p>

<h2>参考</h2>

<ol>
<li><a href="https://developer.apple.com/library/mac/documentation/System/Reference/OSAtomic_header_reference/Reference/reference.html">OSAtomic.h User-Space Reference</a></li>
<li><a href="http://blog.csdn.net/wzb56_earl/article/details/6634622">Memory barrier</a></li>
<li><a href="http://www.cocoachina.com/industry/20130821/6842.html">Objc的底层并发API</a></li>
<li><a href="http://blog.csdn.net/tuxiangqi/article/details/8076972">OSATOMIC与synchronized加锁的对比</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在ReactiveCocoa中将一个ViewModel绑定到UITableView上]]></title>
    <link href="http://southpeak.github.io/blog/2014/09/21/zai-reactivecocoazhong-jiang-%5B%3F%5D-ge-viewmodelbang-ding-dao-uitableviewshang/"/>
    <updated>2014-09-21T14:14:19+08:00</updated>
    <id>http://southpeak.github.io/blog/2014/09/21/zai-reactivecocoazhong-jiang-[?]-ge-viewmodelbang-ding-dao-uitableviewshang</id>
    <content type="html"><![CDATA[<p>英文作者Colin Eberhardt，原文可查看<a href="http://www.scottlogic.com/blog/2014/05/11/reactivecocoa-tableview-binding.html">BINDING TO A UITABLEVIEW FROM A REACTIVECOCOA VIEWMODEL</a></p>

<p>这篇博客介绍了一个工具类，这个类将ReactiveCocoa中的ViewModels绑定到UITableView，而不需要通常的datasource和delegate。下面是这个辅助类的使用方法：</p>

<pre><code>// 创建一个cell
UINib *nib = [UINib nibWithNibName:@"CETweetTableViewCell" bundle:nil];

// 将ViewModels的searchResults属性绑定到table view
[CETableViewBindingHelper bindingHelperForTableView:self.searchResultsTable
                        sourceSignal:RACObserve(self.viewModel, searchResults)
                        templateCell:nib];
</code></pre>

<h2>介绍</h2>

<p>我总是在不断的编写代码：在工作中，在家里，在火车上&hellip;如果我不写代码，我就会觉得不快乐！(注：这才是真正的程序员啊)</p>

<p>在过去的几个月中，我开始在我的工程中越来越多地使用ReactiveCocoa了。这个框架可以用来创建一些非常优雅的解决方案，但同时它非常具有挑战性，因为对于任何一个问题，都有许多可用的解决方案。对于像我这样的编码狂人来说，这再好不过了。</p>

<p>几个月之前，我在Ray Wenderlich的网站上发表了两篇关于ReactiveCocoa的文章(<a href="http://www.raywenderlich.com/62699/reactivecocoa-tutorial-pt1">第一部分</a>、<a href="http://www.raywenderlich.com/62796/reactivecocoa-tutorial-pt2">第二部分</a>)，以及一个<a href="http://www.raywenderlich.com/70598/reactivecocoa-tech-talk-video">Tech Talk</a>视频。这些覆盖了ReactiveCocoa的基本用法，希望能让广大读者熟悉ReactiveCocoa。不过，我收到不少请求，希望能讨论一些使用ReactiveCocoa实现MVVM模式的高级话题。</p>

<p>正因此，我开始写这篇文章。不过，在我发布之前，我想先分享一个已纠缠我很久的问题&hellip;</p>

<p>如果将一个UITableView绑定到一个ReactiveCocoa的ViewModel中？</p>

<h2>视图模式</h2>

<p>我以一个简单的例子开头&mdash;一个允许我们搜索Twitter的ViewModel：</p>

<pre><code>/// A view model which provides a mechanism for searching twitter
@interface CETwitterSearchViewModel : NSObject

/// The current search text
@property NSString *searchText;

/// An array of CETweetViewModel instances which indicate
/// the current search results
@property NSArray *searchResults;

/// A command which when executed searches twitter using the current searchText
@property RACCommand *searchCommand;

@end
</code></pre>

<p>这个ViewModel的实现重用了我在ReactiveCocoa指南第二部分所创建的信号，所以我不在此重复。如果想要看详细的代码，可以在github上查找。</p>

<p>将ViewModel绑定到一个带有UITextField和UIButton的UI是使用ReactiveCocoa最普通不过工作了</p>

<pre><code>// bind the UITextField text updates to the view model
RAC(self.viewModel, searchText) = self.searchTextField.rac_textSignal;

// bind a button to the search command
self.searchButton.rac_command = self.viewModel.searchCommand;

// when the search executes hide the keyboard
[self.viewModel.searchCommand.executing subscribeNext:^(id x) {
  [self.searchTextField resignFirstResponder];
}];

// show a network activity indicator when the search is being executed
RAC([UIApplication sharedApplication], networkActivityIndicatorVisible) =
  self.viewModel.searchCommand.executing;
</code></pre>

<p>在上面的代码中，当点击go按钮时，我们处理了诸如隐藏键盘这样的操作，并将网络连接的activity indicator绑定到了searchCommand.executing信号。</p>

<p><img src="http://www.scottlogic.com/blog/ceberhardt/assets/mvvm/UIBinding.png" alt="image" /></p>

<p>这样就将ViewModel三个属性中的两个绑定到了UI，到目前为止，一切都还不错！</p>

<p>最后一个属性是searchResults；这个属性是一个数组，包含了搜索结果。我们可以通过RACObserve来观察这个属性的修改，RACObserve创建了一个信号，该信号会在每次更新时发出一个next事件。但不幸的是，我们不能只给UITableView一个对象的数组，并告诉它去渲染自己。</p>

<p>如果我们在StackOverflow上搜索相关帖子，或者查看别人的ReactiveCocoa实例，可以看到传统的方式似乎是我们需要自己去实现table view的代理和数据源。换句话说，我们之前优雅的只需要几行绑定代码的视图类代码会由于需要实现table view的各种逻辑而显示异常丑陋。</p>

<p>不过，我们有更好的方法。</p>

<h2>一个Table View绑定辅助类</h2>

<p>在MVVM模式中，每一个View都由一个ViewModel支撑着。一个视图可能占据整个屏幕(此时我们将一个视图控制器绑定到一个ViewModel)，或者只占据屏幕的一部分。</p>

<p>我们的顶层ViewModel的searchResults属性包含了一个对象数组，其中每一个元素都是一个ViewModel。为了解决这个问题，我们需要的是一个通用的机制来为每个视图创建一个ViewModel，并将这两者绑定在一起。</p>

<p>Nib提供了一种便捷的机制来定义可重用的视图。可以方便地使用nib来定义一个table view的单元格。</p>

<p>一个合理的table view绑定辅助类的接口如下：</p>

<pre><code>/// A helper class for binding view models with NSArray properties
/// to a UITableView.
@interface CETableViewBindingHelper : NSObject

- (instancetype) initWithTableView:(UITableView *)tableView
                      sourceSignal:(RACSignal *)source
                      templateCell:(UINib *)templateCellNib;

@end
</code></pre>

<p>这个绑定类使用提供的table view来渲染由源信号所提供的view model，另外templeteCell定义了视图。让我们来看看这个辅助类的实现：</p>

<pre><code>＠interface CETableViewBindingHelper () &lt;UITableViewDataSource&gt;

＠end

＠implementation CETableViewBindingHelper {
  UITableView *_tableView;
  NSArray *_data;
  UITableViewCell *_templateCell;
}

- (instancetype)initWithTableView:(UITableView *)tableView
                     sourceSignal:(RACSignal *)source
                     templateCell:(UINib *)templateCellNib {

  if (self = [super init]) {
    _tableView = tableView;
    _data = [NSArray array];

    // each time the view model updates the array property, store the latest
    // value and reload the table view
    [source subscribeNext:^(id x) {
      _data = x;
      [_tableView reloadData];
    }];

    // create an instance of the template cell and register
    // with the table view
    _templateCell = [[templateCellNib instantiateWithOwner:nil
                                          options:nil] firstObject];
    [_tableView registerNib:templateCellNib
              forCellReuseIdentifier:_templateCell.reuseIdentifier];

    // use the template cell to set the row height
    _tableView.rowHeight = _templateCell.bounds.size.height;

    _tableView.dataSource = self;
  }
  return self;
}

#pragma mark - UITableViewDataSource implementation

- (NSInteger)tableView:(UITableView *)tableView
                       numberOfRowsInSection:(NSInteger)section {
  return _data.count;
}

- (UITableViewCell *)tableView:(UITableView *)tableView
                        cellForRowAtIndexPath:(NSIndexPath *)indexPath {
  id&lt;CEReactiveView&gt; cell = [tableView
      dequeueReusableCellWithIdentifier:_templateCell.reuseIdentifier];
  [cell bindViewModel:_data[indexPath.row]];
  return (UITableViewCell *)cell;
}

＠end
</code></pre>

<p>注意，初始化方法是内在逻辑所在。在这里，sourceSignal添加了一个subscriber，这样每次ViewModel的数组属性变化时，当前属性值的引用都会被保存，而table view也会重新加载。同样，也会创建templeteCell实例，来确定单元格的高度。</p>

<p>最后，这个类实现了table view的数据源方法，并通过信号来获取数据。</p>

<p>其中，单元格Cell必须实现以下协议，该协议提供了一个信号方法来将Cell绑定到相应的ViewModel上。</p>

<pre><code>/// A protocol which is adopted by views which are backed by view models.
@protocol CEReactiveView &lt;NSObject&gt;

/// Binds the given view model to the view
- (void)bindViewModel:(id)viewModel;

@end 
</code></pre>

<p>将这个用于实际当中，现在只需要几行代码就可以将一个数组属性绑定到一个table view上了。</p>

<pre><code>// create a cell template
UINib *nib = [UINib nibWithNibName:@"CETweetTableViewCell" bundle:nil];

// bind the view models 'searchResults' property to a table view
[[CETableViewBindingHelper alloc]
      initWithTableView:self.searchResultsTable
           sourceSignal:RACObserve(self.viewModel, searchResults)
           templateCell:nib];
</code></pre>

<p>注意，源信号是通过RACObserver宏来创建的。这个信号在每次属性通过setter来改变都会发出一个next事件。</p>

<p>cell的实现类似于视图控制器；它们的UI控件定义在一个nib文件中并连接到相应的outlet属性。下图是该示例程序中定义cell的nib：</p>

<p><img src="http://www.scottlogic.com/blog/ceberhardt/assets/mvvm/CellNib.png" alt="image" /></p>

<p>定义在CEReactiveView协议中的ViewModel绑定方法实现如下：</p>

<pre><code>- (void)bindViewModel:(id)viewModel {

  CETweetViewModel *tweet = (CETweetViewModel *)viewModel;

  // set the tweet 'status' label, sizing it to fit the text
  self.titleTextField.frame =
                 CGRectInset(self.titleBackgroundView.frame, 5.0f, 5.0f) ;
  self.titleTextField.text = tweet.status;
  [self.titleTextField sizeToFit];

  // set the username
  self.usernameTextField.text = tweet.username;

  // use signals to fetch the images for each image view
  self.profileImage.image = nil;
  [[self signalForImage:[NSURL URLWithString:tweet.profileBannerUrl]]
    subscribeNext:^(id x) {
      self.ghostImageView.image = x;
    }];

  self.ghostImageView.image = nil;
  [[self signalForImage:[NSURL URLWithString:tweet.profileImageUrl]]
    subscribeNext:^(id x) {
      self.profileImage.image = x;
    }];
} 
</code></pre>

<p>注意，由于CETweetViewModel的属性不会发生变化，因此它们的值直接被拷贝到相应的UI控件上。当然，如果它们的值会改变，我们也可以使用ReactiveCocoa来将两者绑定到一起。</p>

<p>cell的实现同样使用了ReactiveCocoa在后台加载图片：</p>

<pre><code>// creates a signal that fetches an image in the background, delivering
// it on the UI thread. This signal 'cancels' itself if the cell is re-used before the
// image is downloaded.
-(RACSignal *)signalForImage:(NSURL *)imageUrl {

  RACScheduler *scheduler = [RACScheduler 
                 schedulerWithPriority:RACSchedulerPriorityBackground];

  RACSignal *imageDownloadSignal = [[RACSignal
    createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
      NSData *data = [NSData dataWithContentsOfURL:imageUrl];
      UIImage *image = [UIImage imageWithData:data];
      [subscriber sendNext:image];
      [subscriber sendCompleted];
      return nil;
    }] subscribeOn:scheduler];

  return [[imageDownloadSignal
          takeUntil:self.rac_prepareForReuseSignal]
          deliverOn:[RACScheduler mainThreadScheduler]];

}
</code></pre>

<p>通过这种方式，我们就可以让我们的视图控制器保持少量的代码。看，是不是很整洁。</p>

<p>下面是完整的程序的实现效果：</p>

<p><img src="http://www.scottlogic.com/blog/ceberhardt/assets/mvvm/CellBinding.png" alt="image" /></p>

<h2>处理选中事件</h2>

<p>当前的绑定辅助类允许我们在一个table view中渲染ViewModel的数组，但如果我们需要处理选中事件呢？传统的方法是在视图控制器的手动处理，实现table view的代理方法，并执行相关的ViewModel的命令。</p>

<p>不过，这部分逻辑代码也可以放入到绑定辅助类中。</p>

<p>首先，我们在初始化方法中添加一个选择命令：</p>

<pre><code>- (instancetype) initWithTableView:(UITableView *)tableView
                      sourceSignal:(RACSignal *)source
                  selectionCommand:(RACCommand *)selection                  
                      templateCell:(UINib *)templateCellNib;
</code></pre>

<p>这个初始化方法的实现现在存储了这个命令的引用。辅助类同样也实现了table view的代理，即tableView:didSelectRowAtIndexPath:方法的实现如下：</p>

<pre><code>- (void)tableView:(UITableView *)tableView
               didSelectRowAtIndexPath:(NSIndexPath *)indexPath {
  [_selection execute:_data[indexPath.row]];
}
</code></pre>

<p>即当命令被调用时，会将选择的ViewModel作为执行参数传入。</p>

<p>在顶层ViewModel中，我已经添加了一个命令，这个操作只是简单地记录一下日志：</p>

<pre><code> // create the tweet selected command, that simply logs
 self.tweetSelectedCommand = [[RACCommand alloc]
             initWithSignalBlock:^RACSignal *(CETweetViewModel *selected) {
   NSLog(selected.status);
   return [RACSignal empty];
 }];
</code></pre>

<h2>结论</h2>

<p>希望这个table view绑定辅助类能够帮助那些使用MVVM和ReactiveCocoa来开发iOS应用的开发者们。所有的代码都在github上。如果您有任何意见、想法或建议，请让我知道。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS8中扫描Wi-Fi时MAC地址的随机化]]></title>
    <link href="http://southpeak.github.io/blog/2014/09/18/ios8zhong-sao-miao-wi-fishi-macdi-zhi-de-sui-ji-hua/"/>
    <updated>2014-09-18T15:51:54+08:00</updated>
    <id>http://southpeak.github.io/blog/2014/09/18/ios8zhong-sao-miao-wi-fishi-macdi-zhi-de-sui-ji-hua</id>
    <content type="html"><![CDATA[<p>继在iOS6和iOS7系统中面向开发者关闭IP地址和MAC地址的获取后，苹果在iOS8中又出新招：在扫描Wi-Fi时使用随机的、本地管理的MAC地址。基于苹果保护用户隐私的一贯政策，这一步是必然的，它会封死所以获取用户隐私信息的通道。这对于苹果用户来说，当然是件好事。而对于想通过MAC地址来获取用户信息的商家们或黑客们，可能就得另想办法了。我们在此粗略地总结一下iOS对MAC地址所做的随机化处理。</p>

<h2>MAC地址</h2>

<p>在当今基于OSI模型的七层网络系统中，所有有网络接口的设备至少都有一个MAC地址(Media Access Control)。MAC地址位于OSI模型的第二层中，用于帮助网络交换机(有机或无线)确定哪个设备正在传输包及哪个设备应该接收这些包。根据设计，MAC地址应该是唯一的，它被写入到设备的物理网络芯片中，两个不同的设备MAC地址是不一样的。由于像智能手机设备中的无线以太网适配器在广播MAC地址时，采用的的类似于“嘿，这里有没有Wi-Fi”这种形式，所以，我们可以很容易地通过记录这个唯一识别来跟踪用户是否到过某个公共区域。</p>

<h2>随机MAC地址的技术实现</h2>

<p>在WWDC 2014上，Frederic Jacobs在对iOS8新特性的介绍中，提到了如下一条:</p>

<p><img src="http://cdn.arstechnica.net/wp-content/uploads/2014/06/Screen-Shot-2014-06-09-at-10.15.22-AM-1280x551.png" alt="image" /></p>

<p>其大意是在iOS8系统中，Wi-Fi扫描过程中将使用随机的、本地管理的MAC地址，这个MAC地址并不总是设备的真实的MAC地址。</p>

<p>首先需要注意的是MAC地址的随机化。</p>

<p>如果是主动扫描，手机的无线设备会广播一个Probe请求，它包含一个随机的MAC地址。然后手机会等待周围的无线访问接入点(AP)返回Probe响应。一般来说会扫描所有的信道channel1-channel13(或者channel1, 5, 13)，每个信道扫描10ms左右。当然，手机也可以通过点对点的方式将请求(Directed Probe)发送给特定的AP。我们一般隐藏一个无线路由的SSID的方法，就是让这个无线路由不响应广播的Probe，不主动发Beacon，只响应Directed Probe。</p>

<p>而如果是被动扫描，则手机不会广播任何Probe请求，只是周期性地在不同的信道上监听AP发出的beacon包。</p>

<p>另外一个需要注意的是这个随机化是发生在扫描过程中的。而在手机与无线接入点进行关联的过程以及数据传输的过程中，使用MAC地址仍然是设备真实的MAC地址。通常只有在关联阶段才是让AP记录手机MAC地址的阶段，这时候记录的MAC地址，才是将来作为数据传输的MAC地址。</p>

<p>更详细的介绍，可以参看<a href="http://www.zhihu.com/people/qiang-meta">@Qiang Meta</a>在知乎上对《<a href="http://www.zhihu.com/question/24094236?sort=created">iOS 8 设备随机 MAC 地址躲避 Wi-Fi 热点的记录追踪，技术上是怎么实现，有何影响？</a>》的作答。</p>

<h2>影响</h2>

<p>如果我们是在家中或者在办公区域，我们通常会自己去主动关联无线接入点，那么等到下次再进入这一区域时，我们的手机等设备就会自动去连接无线网络。由于这些Wi-Fi是受我们信任的，所以无所谓。但是当我们到达一个陌生区域或公共区域时，我们的设备就会去搜索可用的无线接入点。这时候就涉及到隐私的问题了。</p>

<p>现在，已经有一些公司已经开发了可以记住所扫描到的MAC地址的Wi-Fi集线器。这种设备可以记住我们的MAC地址，无论我们有没有连接它。这些公司已经在许多地方部署了这些设备，以便他们能在用户不知道的情况下了解用户的一些基本行为。</p>

<p>正如WWDC上所指出的一样，“诸如Euclid或其同行Turnstyle Solutions这样的公司，它们会使用MAC地址这样的数据来记录用户进出商店的一些信息，如人们何时走进一个商店，他们在某个区域停留多久，他们来商店的频率是多少”。而MAC地址的随机化正是为了规避这个问题。</p>

<p>这对于广告商和营销商来说无疑是个不小的打击，如果iOS8设备使用不断变化的MAC地址来广播Wi-Fi Probe请求，则不可能通过MAC地址来跟踪进出商店或其它场所的移动设备。这对于保护用户的隐私来说，又是更进了一步。</p>

<h2>苹果的替代方案</h2>

<p>不过苹果也没有完全关闭追踪用户并向用户推送广告的通道，它推出了另外一种方案&mdash;即基于位置服务的iBeacon。iBeacon已经内置在最近的iOS设备中了。不同于使用设备的MAC地址，iBeacon使用低功耗蓝牙技术来发现那边带有支持iBeacon功能的App的设备，以向这些设备发送广告或通知。iBeacon不同于基于MAC地址跟踪技术(iBeacon发射器不会从设备中获取数据)，它只是在匹配到带有基于iBeacon的应用时，才可以察看设备位置。这样就无法推测出一个用户的习惯，从而保护了用户的隐私了。</p>

<p>当然，苹果在随机化MAC地址时，也综合考虑了用户隐私的泄露与商家基于地理位置来发送广告的需求之间的平衡。那些不愿意使用iBeacon的iOS用户可以通过关闭蓝牙来禁用iBeacon感知功能。在iOS8之前，用户只能通过禁用Wi-Fi来避免自己的设备被通过MAC地址的方式跟踪到。</p>

<h2>总结</h2>

<p>苹果这次对MAC地址的随机化处理，又一次展示了它对保护用户隐私的决定。相信以后类似的事情还会出现。而对于开发商或者开发者来说，在iOS设备上获取用户信息的渠道将会越来越少。我们改变不了苹果，或许也就只能另辟蹊径。</p>

<h2>参考</h2>

<ol>
<li><a href="http://www.zhihu.com/question/24094236">iOS 8 设备随机 MAC 地址躲避 Wi-Fi 热点的记录追踪，技术上是怎么实现，有何影响？</a></li>
<li><a href="http://arstechnica.com/apple/2014/06/ios8-to-stymie-trackers-and-marketers-with-mac-address-randomization/">iOS 8 to stymie trackers and marketers with MAC address randomization</a></li>
<li><a href="http://www.tuicool.com/articles/rUv6Br">Why iOS 8′s MAC address randomizing is a huge win for privacy</a></li>
</ol>

]]></content>
  </entry>
  
</feed>
