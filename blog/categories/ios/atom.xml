<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ios | 南峰子的技术博客]]></title>
  <link href="http://southpeak.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://southpeak.github.io/"/>
  <updated>2015-03-20T18:21:48+08:00</updated>
  <id>http://southpeak.github.io/</id>
  <author>
    <name><![CDATA[南峰子]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[NSNotificationCenter]]></title>
    <link href="http://southpeak.github.io/blog/2015/03/20/nsnotificationcenter/"/>
    <updated>2015-03-20T17:45:28+08:00</updated>
    <id>http://southpeak.github.io/blog/2015/03/20/nsnotificationcenter</id>
    <content type="html"><![CDATA[<p>一个NSNotificationCenter对象(通知中心)提供了在程序中广播消息的机制，它实质上就是一个通知分发表。这个分发表负责维护为各个通知注册的观察者，并在通知到达时，去查找相应的观察者，将通知转发给他们进行处理。</p>

<p>本文主要了整理了一下NSNotificationCenter的使用及需要注意的一些问题，并提出了一些未解决的问题，希望能在此得到解答。</p>

<h2>获取通知中心</h2>

<p>每个程序都会有一个默认的通知中心。为此，NSNotificationCenter提供了一个类方法来获取这个通知中心：</p>

<pre><code>+ (NSNotificationCenter *)defaultCenter
</code></pre>

<p>获取了这个默认的通知中心对象后，我们就可以使用它来处理通知相关的操作了，包括注册观察者，移除观察者、发送通知等。</p>

<p>通常如果不是出于必要，我们一般都使用这个默认的通知中心，而不自己创建维护一个通知中心。</p>

<h2>添加观察者</h2>

<p>如果想让对象监听某个通知，则需要在通知中心中将这个对象注册为通知的观察者。早先，NSNotificationCenter提供了以下方法来添加观察者：</p>

<pre><code>- (void)addObserver:(id)notificationObserver
           selector:(SEL)notificationSelector
               name:(NSString *)notificationName
             object:(id)notificationSender
</code></pre>

<p>这个方法带有4个参数，分别指定了通知的观察者、处理通知的回调、通知名及通知的发送对象。这里需要注意几个问题：</p>

<ol>
<li>notificationObserver不能为nil。</li>
<li>notificationSelector回调方法有且只有一个参数(NSNotification对象)。</li>
<li>如果notificationName为nil，则会接收所有的通知(如果notificationSender不为空，则接收所有来自于notificationSender的所有通知)。如代码清单1所示。</li>
<li>如果notificationSender为nil，则会接收所有notificationName定义的通知；否则，接收由notificationSender发送的通知。</li>
<li>监听同一条通知的多个观察者，在通知到达时，它们执行回调的顺序是不确定的，所以我们不能去假设操作的执行会按照添加观察者的顺序来执行。</li>
</ol>


<p>对于以上几点，我们来重点关注一下第3条。以下代码演示了当我们的notificationName设置为nil时，通知的监听情况。</p>

<p><strong>代码清单1：添加一个Observer，其中notificationName为nil</strong></p>

<pre><code>@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleNotification:) name:nil object:nil];

    [[NSNotificationCenter defaultCenter] postNotificationName:TEST_NOTIFICATION object:nil];
}

- (void)handleNotification:(NSNotification *)notification
{
    NSLog(@"notification = %@", notification.name);
}

@end
</code></pre>

<p>运行后的输出结果如下：</p>

<pre><code>notification = TestNotification
notification = UIWindowDidBecomeVisibleNotification
notification = UIWindowDidBecomeKeyNotification
notification = UIApplicationDidFinishLaunchingNotification
notification = _UIWindowContentWillRotateNotification
notification = _UIApplicationWillAddDeactivationReasonNotification
notification = _UIApplicationDidRemoveDeactivationReasonNotification
notification = UIDeviceOrientationDidChangeNotification
notification = _UIApplicationDidRemoveDeactivationReasonNotification
notification = UIApplicationDidBecomeActiveNotification
</code></pre>

<p>可以看出，我们的对象基本上监听了测试程序启动后的所示消息。当然，我们很少会去这么做。</p>

<p>而对于第4条，使用得比较多的场景是监听UITextField的修改事件，通常我们在一个ViewController中，只希望去监听当前视图中的UITextField修改事件，而不希望监听所有UITextField的修改事件，这时我们就可以将当前页面的UITextField对象指定为notificationSender。</p>

<p>在iOS 4.0之后，NSNotificationCenter为了跟上时代，又提供了一个以block方式实现的添加观察者的方法，如下所示：</p>

<pre><code>- (id&lt;NSObject&gt;)addObserverForName:(NSString *)name
                            object:(id)obj
                             queue:(NSOperationQueue *)queue
                        usingBlock:(void (^)(NSNotification *note))block
</code></pre>

<p>大家第一次看到这个方法时是否会有这样的疑问：观察者呢？参数中并没有指定具体的观察者，那谁是观察者呢？实际上，与前一个方法不同的是，前者使用一个现存的对象作为观察者，而这个方法会创建一个匿名的对象作为观察者(即方法返回的id&lt;NSObject>对象)，这个匿名对象会在指定的队列(queue)上去执行我们的block。</p>

<p>这个方法的优点在于添加观察者的操作与回调处理操作的代码更加紧凑，不需要拼命滚动鼠标就能直接找到处理代码，简单直观。这个方法也有几个地方需要注意：</p>

<ol>
<li>name和obj为nil时的情形与前面一个方法是相同的。</li>
<li>如果queue为nil，则消息是默认在post线程中同步处理，即通知的post与转发是在同一线程中；但如果我们指定了操作队列，情况就变得有点意思了，我们一会再讲。</li>
<li>block块会被通知中心拷贝一份(执行copy操作)，以在堆中维护一个block对象，直到观察者被从通知中心中移除。所以，应该特别注意在block中使用外部对象，避免出现对象的循环引用，这个我们在下面将举例说明。</li>
<li>如果一个给定的通知触发了多个观察者的block操作，则这些操作会在各自的Operation Queue中被并发执行。所以我们不能去假设操作的执行会按照添加观察者的顺序来执行。</li>
<li>该方法会返回一个表示观察者的对象，记得在不用时释放这个对象。</li>
</ol>


<p>下面我们重点说明一下第2点和第3点。</p>

<p>关于第2点，当我们指定一个Operation Queue时，不管通知是在哪个线程中post的，都会在Operation Queue所属的线程中进行转发，如代码清单2所示：</p>

<p><strong>代码清单2：在指定队列中接收通知</strong></p>

<pre><code>@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    [[NSNotificationCenter defaultCenter] addObserverForName:TEST_NOTIFICATION object:nil queue:[NSOperationQueue mainQueue] usingBlock:^(NSNotification *note) {

        NSLog(@"receive thread = %@", [NSThread currentThread]);
    }];

    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{

        NSLog(@"post thread = %@", [NSThread currentThread]);
        [[NSNotificationCenter defaultCenter] postNotificationName:TEST_NOTIFICATION object:nil];
    });
}

@end
</code></pre>

<p>在这里，我们在主线程里添加了一个观察者，并指定在主线程队列中去接收处理这个通知。然后我们在一个全局队列中post了一个通知。我们来看下输出结果：</p>

<pre><code>post thread = &lt;NSThread: 0x7ffe0351f5f0&gt;{number = 2, name = (null)}
receive thread = &lt;NSThread: 0x7ffe03508b30&gt;{number = 1, name = main}
</code></pre>

<p>可以看到，消息的post与接收处理并不是在同一个线程中。如上面所提到的，如果queue为nil，则消息是默认在post线程中同步处理，大家可以试一下。</p>

<p>对于第3点，由于使用的是block，所以需要注意的就是避免引起循环引用的问题，如代码清单3所示：</p>

<p><strong>代码清单3：block引发的循环引用问题</strong></p>

<pre><code>@interface Observer : NSObject

@property (nonatomic, assign) NSInteger i;
@property (nonatomic, weak) id&lt;NSObject&gt; observer;

@end

@implementation Observer

- (instancetype)init
{
    self = [super init];

    if (self)
    {
        NSLog(@"Init Observer");

        // 添加观察者
        _observer =  [[NSNotificationCenter defaultCenter] addObserverForName:TEST_NOTIFICATION object:nil queue:[NSOperationQueue mainQueue] usingBlock:^(NSNotification *note) {

            NSLog(@"handle notification");

            // 使用self
            self.i = 10;
        }];
    }

    return self;
}

@end

#pragma mark - ViewController

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    [self createObserver];

    // 发送消息
    [[NSNotificationCenter defaultCenter] postNotificationName:TEST_NOTIFICATION object:nil];
}

- (void)createObserver {

    Observer *observer = [[Observer alloc] init];
}

@end
</code></pre>

<p>运行后的输出如下：</p>

<pre><code>Init Observer
handle notification
</code></pre>

<p>我们可以看到createObserver中创建的observer并没有被释放。所以，使用
&ndash; addObserverForName:object:queue:usingBlock:一定要注意这个问题。</p>

<h2>移除观察者</h2>

<p>与注册观察者相对应的，NSNotificationCenter为我们提供了两个移除观察者的方法。它们的定义如下：</p>

<pre><code>- (void)removeObserver:(id)notificationObserver

- (void)removeObserver:(id)notificationObserver name:(NSString *)notificationName object:(id)notificationSender
</code></pre>

<p>前一个方法会将notificationObserver从通知中心中移除，这样notificationObserver就无法再监听任何消息。而后一个会根据三个参数来移除相应的观察者。</p>

<p>这两个方法也有几点需要注意：</p>

<ol>
<li>由于注册观察者时(不管是哪个方法)，通知中心会维护一个观察者的弱引用，所以在释放对象时，要确保移除对象所有监听的通知。否则，可能会导致程序崩溃或一些莫名其妙的问题。</li>
<li>对于第二个方法，如果notificationName为nil，则会移除所有匹配notificationObserver和notificationSender的通知，同理notificationSender也是一样的。而如果notificationName和notificationSender都为nil，则其效果就与第一个方法是一样的了。大家可以试一下。</li>
<li>最有趣的应该是这两个方法的使用时机。–removeObserver:适合于在类的dealloc方法中调用，这样可以确保将对象从通知中心中清除；而在viewWillDisappear:这样的方法中，则适合于使用-removeObserver:name:object:方法，以避免不知情的情况下移除了不应该移除的通知观察者。例如，假设我们的ViewController继承自一个类库的某个ViewController类(假设为SKViewController吧)，可能SKViewController自身也监听了某些通知以执行特定的操作，但我们使用时并不知道。如果直接在viewWillDisappear:中调用–removeObserver:，则也会把父类监听的通知也给移除。</li>
</ol>


<p>关于注册监听者，还有一个需要注意的问题是，每次调用addObserver时，都会在通知中心重新注册一次，即使是同一对象监听同一个消息，而不是去覆盖原来的监听。这样，当通知中心转发某一消息时，如果同一对象多次注册了这个通知的观察者，则会收到多个通知，如代码清单4所示：</p>

<p><strong>代码清单4：同一对象多次注册同一消息</strong></p>

<pre><code>@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleNotification:) name:TEST_NOTIFICATION object:nil];
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleNotification:) name:TEST_NOTIFICATION object:nil];

    [[NSNotificationCenter defaultCenter] postNotificationName:TEST_NOTIFICATION object:nil];
}

- (void)handleNotification:(NSNotification *)notification
{
    NSLog(@"notification = %@", notification.name);
}

@end
</code></pre>

<p>其输出结果如下所示：</p>

<pre><code>notification = TestNotification
notification = TestNotification
</code></pre>

<p>可以看到对象处理了两次通知。所以，如果我们需要在viewWillAppear监听一个通知时，一定要记得在对应的viewWillDisappear里面将观察者移除，否则就可能会出现上面的情况。</p>

<p><strong>最后，再特别重点强调的非常重要的一点是，在释放对象前，一定要记住如果它监听了通知，一定要将它从通知中心移除。如果是用
&ndash; addObserverForName:object:queue:usingBlock:，也记得一定得移除这个匿名观察者。说白了就一句话，添加和移除要配对出现。</strong></p>

<h2>post消息</h2>

<p>注册了通知观察者，我们便可以随时随地的去post一个通知了(当然，如果闲着没事，也可以不注册观察者，post通知随便玩，只是没人理睬罢了)。NSNotificationCenter提供了三个方法来post一个通知，如下所示：</p>

<pre><code>- postNotification:
– postNotificationName:object:
– postNotificationName:object:userInfo:
</code></pre>

<p>我们可以根据需要指定通知的发送者(object)并附带一些与通知相关的信息(userInfo)，当然这些发送者和userInfo可以封装在一个NSNotification对象中，由- postNotification:来发送。注意，- postNotification:的参数不能为空，否则会引发一个异常，如下所示：</p>

<pre><code>*** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '*** -[NSNotificationCenter postNotification:]: notification is nil'
</code></pre>

<p>每次post一个通知时，通知中心都会去遍历一下它的分发表，然后将通知转发给相应的观察者。</p>

<p>另外，通知的发送与处理是同步的，在某个地方post一个消息时，会等到所有观察者对象执行完处理操作后，才回到post的地方，继续执行后面的代码。如代码清单5所示：</p>

<p><strong>代码清单5：通知的同步处理</strong></p>

<pre><code>@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleNotification:) name:TEST_NOTIFICATION object:nil];

    [[NSNotificationCenter defaultCenter] postNotificationName:TEST_NOTIFICATION object:nil];

    NSLog(@"continue");
}

- (void)handleNotification:(NSNotification *)notification
{
    NSLog(@"handle notification");
}

@end
</code></pre>

<p>运行后输出结果是：</p>

<pre><code>handle notification
continue
</code></pre>

<h2>一些思考</h2>

<p>翻了好些资料，还有两个问题始终没有明确的答案。</p>

<p>首先就是通知中心是如何维护观察者对象的。可以明确的是，添加观察者时，通知中心没有对观察者做retain操作，即不会使观察者的引用计数加1。那通知中心维护的是观察者的weak引用呢还是unsafe_unretained引用呢？</p>

<p>个人认为可能是unsafe_unretained的引用，因为我们知道如果是weak引用，其所指的对象被释放后，这个引用会被置成nil。而实际情况是通知中心还会给这个对象发送消息，并引发一个异常。而如果向nil发送一个消息是不会导致异常的。</p>

<p>另外，我们知道NSNotificationCenter实现的是观察者模式，而且通常情况下消息在哪个线程被post，就在哪个线程被转发。而从上面的描述可以发现，
-addObserverForName:object:queue:usingBlock:添加的匿名观察者可以在指定的队列中处理通知，那它的实现机制是什么呢？</p>

<h2>小结</h2>

<p>在我们的应用程序中，一个大的话题就是两个对象之间如何通信。我们需要根据对象之间的关系来确定采用哪一种通信方式。对象之间的通信方式主要有以下几种：</p>

<ol>
<li>直接方法调用</li>
<li>Target-Action</li>
<li>Delegate</li>
<li>回调(block)</li>
<li>KVO</li>
<li>通知</li>
</ol>


<p>一般情况下，我们可以根据以下两点来确定使用哪种方式：</p>

<ol>
<li>通信对象是一对一的还是一对多的</li>
<li>对象之间的耦合度，是强耦合还是松耦合</li>
</ol>


<p>Objective-C中的通知由于其广播性及松耦合性，非常适合于大的范围内对象之间的通信(模块与模块，或一些框架层级)。通知使用起来非常方便，也正因为如此，所以容易导致滥用。所以在使用前还是需要多想想，是否有更好的方法来实现我们所需要的对象间通信。毕竟，通知机制会在一定程度上会影响到程序的性能。</p>

<p>对于使用NSNotificationCenter，最后总结一些小建议：</p>

<ol>
<li>在需要的地方使用通知。</li>
<li>注册的观察者在不使用时一定要记得移除，即添加和移除要配对出现。</li>
<li>尽可能迟地去注册一个观察者，并尽可能早将其移除，这样可以改善程序的性能。因为，每post一个通知，都会是遍历通知中心的分发表，确保通知发给每一个观察者。</li>
<li>记住通知的发送和处理是在同一个线程中。</li>
<li>使用-addObserverForName:object:queue:usingBlock:务必处理好内存问题，避免出现循环引用。</li>
<li>NSNotificationCenter是线程安全的，但并不意味着在多线程环境中不需要关注线程安全问题。不恰当的使用仍然会引发线程问题。</li>
</ol>


<p>最后，“<a href="http://weibo.com/u/1438670852">@叶孤城___</a>”叶大大在微博中推荐了几篇文章，即参考中的4-7，值得细读一下。</p>

<h2>参考</h2>

<ol>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSNotificationCenter_Class/">NSNotificationCenter Class Reference</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Notifications/Articles/NotificationQueues.html">Notification Programming Topics</a></li>
<li><a href="http://nshipster.com/nsnotification-and-nsnotificationcenter/">NSNotification &amp; NSNotification​Center</a></li>
<li><a href="http://www.hpique.com/2013/12/nsnotificationcenter-part-1/">NSNotificationCenter part 1: Receiving and sending notifications</a></li>
<li><a href="http://www.hpique.com/2013/12/nsnotificationcenter-part-2/">NSNotificationCenter part 2: Implementing the observer pattern with notifications</a></li>
<li><a href="http://www.hpique.com/2013/12/nsnotificationcenter-part-3/">NSNotificationCenter part 3: Unit testing notifications with OCMock</a></li>
<li><a href="http://www.hpique.com/2013/12/nsnotificationcenter-part-4/">NSNotificationCenter part 4: Asynchronous notifications with NSNotificationQueue</a></li>
<li><a href="http://stackoverflow.com/questions/12699118/view-controller-dealloc-not-called-when-using-nsnotificationcenter-code-block-me">View controller dealloc not called when using NSNotificationCenter code block method with ARC</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Notification与多线程]]></title>
    <link href="http://southpeak.github.io/blog/2015/03/14/nsnotificationyu-duo-xian-cheng/"/>
    <updated>2015-03-14T12:58:59+08:00</updated>
    <id>http://southpeak.github.io/blog/2015/03/14/nsnotificationyu-duo-xian-cheng</id>
    <content type="html"><![CDATA[<p>前几天与同事讨论到Notification在多线程下的转发问题，所以就此整理一下。</p>

<p>先来看看官方的文档，是这样写的：</p>

<pre><code>In a multithreaded application, notifications are always delivered in the thread in which the notification was posted, which may not be the same thread in which an observer registered itself.
</code></pre>

<p>翻译过来是：</p>

<pre><code>在多线程应用中，Notification在哪个线程中post，就在哪个线程中被转发，而不一定是在注册观察者的那个线程中。
</code></pre>

<p>也就是说，Notification的发送与接收处理都是在同一个线程中。为了说明这一点，我们先来看一个示例：</p>

<p><strong>代码清单1：Notification的发送与处理</strong></p>

<pre><code>@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    NSLog(@"current thread = %@", [NSThread currentThread]);

    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleNotification:) name:TEST_NOTIFICATION object:nil];

    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{

        [[NSNotificationCenter defaultCenter] postNotificationName:TEST_NOTIFICATION object:nil userInfo:nil];
    });
}

- (void)handleNotification:(NSNotification *)notification
{
    NSLog(@"current thread = %@", [NSThread currentThread]);

    NSLog(@"test notification");
}

@end
</code></pre>

<p>其输出结果如下：</p>

<pre><code>2015-03-11 22:05:12.856 test[865:45102] current thread = &lt;NSThread: 0x7fbb23412f30&gt;{number = 1, name = main}
2015-03-11 22:05:12.857 test[865:45174] current thread = &lt;NSThread: 0x7fbb23552370&gt;{number = 2, name = (null)}
2015-03-11 22:05:12.857 test[865:45174] test notification
</code></pre>

<p>可以看到，虽然我们在主线程中注册了通知的观察者，但在全局队列中post的Notification，并不是在主线程处理的。所以，这时候就需要注意，如果我们想在回调中处理与UI相关的操作，需要确保是在主线程中执行回调。</p>

<p>这时，就有一个问题了，如果我们的Notification是在二级线程中post的，如何能在主线程中对这个Notification进行处理呢？或者换个提法，如果我们希望一个Notification的post线程与转发线程不是同一个线程，应该怎么办呢？我们看看官方文档是怎么说的：</p>

<pre><code>For example, if an object running in a background thread is listening for notifications from the user interface, such as a window closing, you would like to receive the notifications in the background thread instead of the main thread. In these cases, you must capture the notifications as they are delivered on the default thread and redirect them to the appropriate thread.
</code></pre>

<p>这里讲到了“重定向”，就是我们在Notification所在的默认线程中捕获这些分发的通知，然后将其重定向到指定的线程中。</p>

<p>一种重定向的实现思路是自定义一个通知队列(注意，不是NSNotificationQueue对象，而是一个数组)，让这个队列去维护那些我们需要重定向的Notification。我们仍然是像平常一样去注册一个通知的观察者，当Notification来了时，先看看post这个Notification的线程是不是我们所期望的线程，如果不是，则将这个Notification存储到我们的队列中，并发送一个信号(signal)到期望的线程中，来告诉这个线程需要处理一个Notification。指定的线程在收到信号后，将Notification从队列中移除，并进行处理。</p>

<p>官方文档已经给出了示例代码，在此借用一下，以测试实际结果：</p>

<p><strong>代码清单2：在不同线程中post和转发一个Notification</strong></p>

<pre><code>@interface ViewController () &lt;NSMachPortDelegate&gt;

@property (nonatomic) NSMutableArray    *notifications;         // 通知队列
@property (nonatomic) NSThread          *notificationThread;    // 期望线程
@property (nonatomic) NSLock            *notificationLock;      // 用于对通知队列加锁的锁对象，避免线程冲突
@property (nonatomic) NSMachPort        *notificationPort;      // 用于向期望线程发送信号的通信端口

@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    NSLog(@"current thread = %@", [NSThread currentThread]);

    // 初始化
    self.notifications = [[NSMutableArray alloc] init];
    self.notificationLock = [[NSLock alloc] init];

    self.notificationThread = [NSThread currentThread];
    self.notificationPort = [[NSMachPort alloc] init];
    self.notificationPort.delegate = self;

    // 往当前线程的run loop添加端口源
    // 当Mach消息到达而接收线程的run loop没有运行时，则内核会保存这条消息，直到下一次进入run loop
    [[NSRunLoop currentRunLoop] addPort:self.notificationPort
                                forMode:(__bridge NSString *)kCFRunLoopCommonModes];

    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(processNotification:) name:@"TestNotification" object:nil];

    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{

        [[NSNotificationCenter defaultCenter] postNotificationName:TEST_NOTIFICATION object:nil userInfo:nil];

    });
}

- (void)handleMachMessage:(void *)msg {

    [self.notificationLock lock];

    while ([self.notifications count]) {
        NSNotification *notification = [self.notifications objectAtIndex:0];
        [self.notifications removeObjectAtIndex:0];
        [self.notificationLock unlock];
        [self processNotification:notification];
        [self.notificationLock lock];
    };

    [self.notificationLock unlock];
}

- (void)processNotification:(NSNotification *)notification {

    if ([NSThread currentThread] != _notificationThread) {
        // Forward the notification to the correct thread.
        [self.notificationLock lock];
        [self.notifications addObject:notification];
        [self.notificationLock unlock];
        [self.notificationPort sendBeforeDate:[NSDate date]
                                   components:nil
                                         from:nil
                                     reserved:0];
    }
    else {
        // Process the notification here;
        NSLog(@"current thread = %@", [NSThread currentThread]);
        NSLog(@"process notification");
    }
}

@end
</code></pre>

<p>运行后，其输出如下：</p>

<pre><code>2015-03-11 23:38:31.637 test[1474:92483] current thread = &lt;NSThread: 0x7ffa4070ed50&gt;{number = 1, name = main}
2015-03-11 23:38:31.663 test[1474:92483] current thread = &lt;NSThread: 0x7ffa4070ed50&gt;{number = 1, name = main}
2015-03-11 23:38:31.663 test[1474:92483] process notification
</code></pre>

<p>可以看到，我们在全局dispatch队列中抛出的Notification，如愿地在主线程中接收到了。</p>

<p>这种实现方式的具体解析及其局限性大家可以参考官方文档<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Notifications/Articles/Threading.html#//apple_ref/doc/uid/20001289-CEGJFDFG">Delivering Notifications To Particular Threads</a>，在此不多做解释。当然，更好的方法可能是我们自己去子类化一个NSNotificationCenter，或者单独写一个类来处理这种转发。</p>

<h2>NSNotificationCenter的线程安全性</h2>

<p>苹果之所以采取通知中心在同一个线程中post和转发同一消息这一策略，应该是出于线程安全的角度来考量的。官方文档告诉我们，NSNotificationCenter是一个线程安全类，我们可以在多线程环境下使用同一个NSNotificationCenter对象而不需要加锁。原文在<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/ThreadSafetySummary/ThreadSafetySummary.html">Threading Programming Guide</a>中，具体如下：</p>

<pre><code>The following classes and functions are generally considered to be thread-safe. You can use the same instance from multiple threads without first acquiring a lock.

NSArray
...
NSNotification
NSNotificationCenter
...
</code></pre>

<p>我们可以在任何线程中添加/删除通知的观察者，也可以在任何线程中post一个通知。</p>

<p>NSNotificationCenter在线程安全性方面已经做了不少工作了，那是否意味着我们可以高枕无忧了呢？再回过头来看看第一个例子，我们稍微改造一下，一点一点来：</p>

<p><strong>代码清单3：NSNotificationCenter的通用模式</strong></p>

<pre><code>@interface Observer : NSObject

@end

@implementation Observer

- (instancetype)init
{
    self = [super init];

    if (self)
    {
        _poster = [[Poster alloc] init];

        [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleNotification:) name:TEST_NOTIFICATION object:nil]
    }

    return self;
}

- (void)handleNotification:(NSNotification *)notification
{
    NSLog(@"handle notification ");
}

- (void)dealloc
{
    [[NSNotificationCenter defaultCenter] removeObserver:self];
}

@end

// 其它地方
[[NSNotificationCenter defaultCenter] postNotificationName:TEST_NOTIFICATION object:nil];   
</code></pre>

<p>上面的代码就是我们通常所做的事情：添加一个通知监听者，定义一个回调，并在所属对象释放时移除监听者；然后在程序的某个地方post一个通知。简单明了，如果这一切都是发生在一个线程里面，或者至少dealloc方法是在-postNotificationName:的线程中运行的(注意：NSNotification的post和转发是同步的)，那么都OK，没有线程安全问题。但如果dealloc方法和-postNotificationName:方法不在同一个线程中运行时，会出现什么问题呢？</p>

<p>我们再改造一下上面的代码：</p>

<p><strong>代码清单4：NSNotificationCenter引发的线程安全问题</strong></p>

<pre><code>#pragma mark - Poster

@interface Poster : NSObject

@end

@implementation Poster

- (instancetype)init
{
    self = [super init];

    if (self)
    {
        [self performSelectorInBackground:@selector(postNotification) withObject:nil];
    }

    return self;
}

- (void)postNotification
{
    [[NSNotificationCenter defaultCenter] postNotificationName:TEST_NOTIFICATION object:nil];
}

@end

#pragma mark - Observer

@interface Observer : NSObject
{
    Poster  *_poster;
}

@property (nonatomic, assign) NSInteger i;

@end

@implementation Observer

- (instancetype)init
{
    self = [super init];

    if (self)
    {
        _poster = [[Poster alloc] init];

        [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleNotification:) name:TEST_NOTIFICATION object:nil];
    }

    return self;
}

- (void)handleNotification:(NSNotification *)notification
{
    NSLog(@"handle notification begin");
    sleep(1);
    NSLog(@"handle notification end");

    self.i = 10;
}

- (void)dealloc
{
    [[NSNotificationCenter defaultCenter] removeObserver:self];

    NSLog(@"Observer dealloc");
}

@end

#pragma mark - ViewController

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    __autoreleasing Observer *observer = [[Observer alloc] init];
}

@end
</code></pre>

<p>这段代码是在主线程添加了一个TEST_NOTIFICATION通知的监听者，并在主线程中将其移除，而我们的NSNotification是在后台线程中post的。在通知处理函数中，我们让回调所在的线程睡眠1秒钟，然后再去设置属性i值。这时会发生什么呢？我们先来看看输出结果：</p>

<pre><code>2015-03-14 00:31:41.286 SKTest[932:88791] handle notification begin
2015-03-14 00:31:41.291 SKTest[932:88713] Observer dealloc
2015-03-14 00:31:42.361 SKTest[932:88791] handle notification end
(lldb) 

// 程序在self.i = 10处抛出了"Thread 6: EXC_BAD_ACCESS(code=EXC_I386_GPFLT)"
</code></pre>

<p>经典的内存错误，程序崩溃了。其实从输出结果中，我们就可以看到到底是发生了什么事。我们简要描述一下：</p>

<ol>
<li>当我们注册一个观察者是，通知中心会持有观察者的一个弱引用，来确保观察者是可用的。</li>
<li>主线程调用dealloc操作会让Observer对象的引用计数减为0，这时对象会被释放掉。</li>
<li>后台线程发送一个通知，如果此时Observer还未被释放，则会向其转发消息，并执行回调方法。而如果在回调执行的过程中对象被释放了，就会出现上面的问题。</li>
</ol>


<p>当然，上面这个例子是故意而为之，但不排除在实际编码中会遇到类似的问题。虽然NSNotificationCenter是线程安全的，但并不意味着我们在使用时就可以保证线程安全的，如果稍不注意，还是会出现线程问题。</p>

<p>那我们该怎么做呢？这里有一些好的建议：</p>

<ol>
<li>尽量在一个线程中处理通知相关的操作，大部分情况下，这样做都能确保通知的正常工作。不过，我们无法确定到底会在哪个线程中调用dealloc方法，所以这一点还是比较困难。</li>
<li>注册监听都时，使用基于block的API。这样我们在block还要继续调用self的属性或方法，就可以通过weak-strong的方式来处理。具体大家可以改造下上面的代码试试是什么效果。</li>
<li>使用带有安全生命周期的对象，这一点对象单例对象来说再合适不过了，在应用的整个生命周期都不会被释放。</li>
<li>使用代理。</li>
</ol>


<h2>小结</h2>

<p>NSNotificationCenter虽然是线程安全的，但不要被这个事实所误导。在涉及到多线程时，我们还是需要多加小心，避免出现上面的线程问题。想进一步了解的话，可以查看<a href="http://inessential.com/2013/12/20/observers_and_thread_safety">Observers and Thread Safety</a>。</p>

<h2>参考</h2>

<ol>
<li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Notifications/Articles/Notifications.html">Notification Programming Topics</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/ThreadSafetySummary/ThreadSafetySummary.html">Threading Programming Guide</a></li>
<li><a href="http://blog.csdn.net/wzzvictory/article/details/8489516">NSNotification的几点说明</a></li>
<li><a href="http://lapcatsoftware.com/articles/nsnotificationcenter-is-threadsafe-not.html">NSNotificationCenter is thread-safe NOT</a></li>
<li><a href="http://inessential.com/2013/12/20/observers_and_thread_safety">Observers and Thread Safety</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIResponder]]></title>
    <link href="http://southpeak.github.io/blog/2015/03/07/uiresponder/"/>
    <updated>2015-03-07T18:54:23+08:00</updated>
    <id>http://southpeak.github.io/blog/2015/03/07/uiresponder</id>
    <content type="html"><![CDATA[<p>我们的App与用户进行交互，基本上是依赖于各种各样的事件。例如，用户点击界面上的按钮，我们需要触发一个按钮点击事件，并进行相应的处理，以给用户一个响应。UIView的三大职责之一就是处理事件，一个视图是一个事件响应者，可以处理点击等事件，而这些事件就是在UIResponder类中定义的。</p>

<p>一个UIResponder类为那些需要响应并处理事件的对象定义了一组接口。这些事件主要分为两类：触摸事件(touch events)和运动事件(motion events)。UIResponder类为每两类事件都定义了一组接口，这个我们将在下面详细描述。</p>

<p>在UIKit中，UIApplication、UIView、UIViewController这几个类都是直接继承自UIResponder类。另外SpriteKit中的SKNode也是继承自UIResponder类。因此UIKit中的视图、控件、视图控制器，以及我们自定义的视图及视图控制器都有响应事件的能力。这些对象通常被称为响应对象，或者是响应者(以下我们统一使用响应者)。</p>

<p>本文将详细介绍一个UIResponder类提供的基本功能。不过在此之前，我们先来了解一下事件响应链机制。</p>

<h2>响应链</h2>

<p>大多数事件的分发都是依赖响应链的。响应链是由一系列链接在一起的响应者组成的。一般情况下，一条响应链开始于第一响应者，结束于application对象。如果一个响应者不能处理事件，则会将事件沿着响应链传到下一响应者。</p>

<p>那这里就会有三个问题：</p>

<ol>
<li>响应链是何时构建的</li>
<li>系统是如何确定第一响应者的</li>
<li>确定第一响应者后，系统又是按照什么样的顺序来传递事件的</li>
</ol>


<h3>构建响应链</h3>

<p>我们都知道在一个App中，所有视图是按一定的结构组织起来的，即树状层次结构。除了根视图外，每个视图都有一个父视图；而每个视图都可以有0个或多个子视图。而在这个树状结构构建的同时，也构建了一条条的事件响应链。</p>

<h3>确定第一响应者</h3>

<p>当用户触发某一事件(触摸事件或运动事件)后，UIKit会创建一个事件对象(UIEvent)，该对象包含一些处理事件所需要的信息。然后事件对象被放到一个事件队列中。这些事件按照先进先出的顺序来处理。当处理事件时，程序的UIApplication对象会从队列头部取出一个事件对象，将其分发出去。通常首先是将事件分发给程序的主window对象，对于触摸事件来讲，window对象会首先尝试将事件分发给触摸事件发生的那个视图上。这一视图通常被称为hit-test视图，而查找这一视图的过程就叫做hit-testing。</p>

<p>系统使用hit-testing来找到触摸下的视图，它检测一个触摸事件是否发生在相应视图对象的边界之内(即视图的frame属性，这也是为什么子视图如果在父视图的frame之外时，是无法响应事件的)。如果在，则会递归检测其所有的子视图。包含触摸点的视图层次架构中最底层的视图就是hit-test视图。在检测出hit-test视图后，系统就将事件发送给这个视图来进行处理。</p>

<p>我们通过一个示例来演示hit-testing的过程。图1是一个视图层次结构，</p>

<p><img src="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/hit_testing_2x.png" alt="image" /></p>

<p>假设用户点击了视图E，系统按照以下顺序来查找hit-test视图：</p>

<ol>
<li>点击事件发生在视图A的边界内，所以检测子视图B和C；</li>
<li>点击事件不在视图B的边界内，但在视图C的边界范围内，所以检测子图片D和E；</li>
<li>点击事件不在视图D的边界内，但在视图E的边界范围内；</li>
</ol>


<p>视图E是包含触摸点的视图层次架构中最底层的视图(倒树结构)，所以它就是hit-test视图。</p>

<p>hit-test视图可以最先去处理触摸事件，如果hit-test视图不能处理事件，则事件会沿着响应链往上传递，直到找到能处理它的视图。</p>

<h3>事件传递</h3>

<p>最有机会处理事件的对象是hit-test视图或第一响应者。如果这两者都不能处理事件，UIKit就会将事件传递到响应链中的下一个响应者。每一个响应者确定其是否要处理事件或者是通过nextResponder方法将其传递给下一个响应者。这一过程一直持续到找到能处理事件的响应者对象或者最终没有找到响应者。</p>

<p>图2演示了这样一个事件传递的流程，</p>

<p><img src="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/iOS_responder_chain_2x.png" alt="image" /></p>

<p>当系统检测到一个事件时，将其传递给初始对象，这个对象通常是一个视图。然后，会按以下路径来处理事件(我们以左图为例)：</p>

<ol>
<li>初始视图(initial view)尝试处理事件。如果它不能处理事件，则将事件传递给其父视图。</li>
<li>初始视图的父视图(superview)尝试处理事件。如果这个父视图还不能处理事件，则继续将视图传递给上层视图。</li>
<li>上层视图(topmost view)会尝试处理事件。如果这个上层视图还是不能处理事件，则将事件传递给视图所在的视图控制器。</li>
<li>视图控制器会尝试处理事件。如果这个视图控制器不能处理事件，则将事件传递给窗口(window)对象。</li>
<li>窗口(window)对象尝试处理事件。如果不能处理，则将事件传递给单例app对象。</li>
<li>如果app对象不能处理事件，则丢弃这个事件。</li>
</ol>


<p>从上面可以看到，视图、视图控制器、窗口对象和app对象都能处理事件。另外需要注意的是，手势也会影响到事件的传递。</p>

<p>以上便是响应链的一些基本知识。有了这些知识，我们便可以来看看UIResponder提供给我们的一些方法了。</p>

<h2>管理响应链</h2>

<p>UIResponder提供了几个方法来管理响应链，包括让响应对象成为第一响应者、放弃第一响应者、检测是否是第一响应者以及传递事件到下一响应者的方法，我们分别来介绍一下。</p>

<p>上面提到在响应链中负责传递事件的方法是nextResponder，其声明如下：</p>

<pre><code>- (UIResponder *)nextResponder
</code></pre>

<p>UIResponder类并不自动保存或设置下一个响应者，该方法的默认实现是返回nil。子类的实现必须重写这个方法来设置下一响应者。UIView的实现是返回管理它的UIViewController对象(如果它有)或者其父视图。而UIViewController的实现是返回它的视图的父视图；UIWindow的实现是返回app对象；而UIApplication的实现是返回nil。所以，响应链是在构建视图层次结构时生成的。</p>

<p>一个响应对象可以成为第一响应者，也可以放弃第一响应者。为此，UIResponder提供了一系列方法，我们分别来介绍一下。</p>

<p>如果想判定一个响应对象是否是第一响应者，则可以使用以下方法：</p>

<pre><code>- (BOOL)isFirstResponder
</code></pre>

<p>如果我们希望将一个响应对象作为第一响应者，则可以使用以下方法：</p>

<pre><code>- (BOOL)becomeFirstResponder
</code></pre>

<p>如果对象成为第一响应者，则返回YES；否则返回NO。默认实现是返回YES。子类可以重写这个方法来更新状态，或者来执行一些其它的行为。</p>

<p>一个响应对象只有在当前响应者能放弃第一响应者状态(canResignFirstResponder)且自身能成为第一响应者(canBecomeFirstResponder)时才会成为第一响应者。</p>

<p>这个方法相信大家用得比较多，特别是在希望UITextField获取焦点时。另外需要注意的是只有当视图是视图层次结构的一部分时才调用这个方法。如果视图的window属性不为空时，视图才在一个视图层次结构中；如果该属性为nil，则视图不在任何层次结构中。</p>

<p>上面提到一个响应对象成为第一响应者的一个前提是它可以成为第一响应者，我们可以使用canBecomeFirstResponder方法来检测，</p>

<pre><code>- (BOOL)canBecomeFirstResponder
</code></pre>

<p>需要注意的是我们不能向一个不在视图层次结构中的视图发送这个消息，其结果是未定义的。</p>

<p>与上面两个方法相对应的是响应者放弃第一响应者的方法，其定义如下：</p>

<pre><code>- (BOOL)resignFirstResponder
- (BOOL)canResignFirstResponder
</code></pre>

<p>resignFirstResponder默认也是返回YES。需要注意的是，如果子类要重写这个方法，则在我们的代码中必须调用super的实现。</p>

<p>canResignFirstResponder默认也是返回YES。不过有些情况下可能需要返回NO，如一个输入框在输入过程中可能需要让这个方法返回NO，以确保在编辑过程中能始终保证是第一响应者。</p>

<h2>管理输入视图</h2>

<p>所谓的输入视图，是指当对象为第一响应者时，显示另外一个视图用来处理当前对象的信息输入，如UITextView和UITextField两个对象，在其成为第一响应者是，会显示一个系统键盘，用来输入信息。这个系统键盘就是输入视图。输入视图有两种，一个是inputView，另一个是inputAccessoryView。这两者如图3所示：</p>

<p><img src="http://images.cnblogs.com/cnblogs_com/kuku/b.jpg" alt="image" /></p>

<p>与inputView相关的属性有如下两个，</p>

<pre><code>@property(nonatomic, readonly, retain) UIView *inputView
@property(nonatomic, readonly, retain) UIInputViewController *inputViewController
</code></pre>

<p>这两个属性提供一个视图(或视图控制器)用于替代为UITextField和UITextView弹出的系统键盘。我们可以在子类中将这两个属性重新定义为读写属性来设置这个属性。如果我们需要自己写一个键盘的，如为输入框定义一个用于输入身份证的键盘(只包含0-9和X)，则可以使用这两个属性来获取这个键盘。</p>

<p>与inputView类似，inputAccessoryView也有两个相关的属性：</p>

<pre><code>@property(nonatomic, readonly, retain) UIView *inputAccessoryView
@property(nonatomic, readonly, retain) UIInputViewController *inputAccessoryViewController
</code></pre>

<p>设置方法与前面相同，都是在子类中重新定义为可读写属性，以设置这个属性。</p>

<p>另外，UIResponder还提供了以下方法，在对象是第一响应者时更新输入和访问视图，</p>

<pre><code>- (void)reloadInputViews
</code></pre>

<p>调用这个方法时，视图会立即被替换，即不会有动画之类的过渡。如果当前对象不是第一响应者，则该方法是无效的。</p>

<h2>响应触摸事件</h2>

<p>UIResponder提供了如下四个大家都非常熟悉的方法来响应触摸事件：</p>

<pre><code>// 当一个或多个手指触摸到一个视图或窗口
- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
// 当与事件相关的一个或多个手指在视图或窗口上移动时
- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event
// 当一个或多个手指从视图或窗口上抬起时
- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event
// 当一个系统事件取消一个触摸事件时
- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event
</code></pre>

<p>这四个方法默认都是什么都不做。不过，UIKit中UIResponder的子类，尤其是UIView，这几个方法的实现都会把消息传递到响应链上。因此，为了不阻断响应链，我们的子类在重写时需要调用父类的相应方法；而不要将消息直接发送给下一响应者。</p>

<p>默认情况下，多点触摸是被禁用的。为了接受多点触摸事件，我们需要设置响应视图的multipleTouchEnabled属性为YES。</p>

<h2>响应移动事件</h2>

<p>与触摸事件类似，UIResponder也提供了几个方法来响应移动事件：</p>

<pre><code>// 移动事件开始
- (void)motionBegan:(UIEventSubtype)motion withEvent:(UIEvent *)event
// 移动事件结束
- (void)motionEnded:(UIEventSubtype)motion withEvent:(UIEvent *)event
// 取消移动事件
- (void)motionCancelled:(UIEventSubtype)motion withEvent:(UIEvent *)event
</code></pre>

<p>与触摸事件不同的是，运动事件只有开始与结束操作；它不会报告类似于晃动这样的事件。这几个方法的默认操作也是什么都不做。不过，UIKit中UIResponder的子类，尤其是UIView，这几个方法的实现都会把消息传递到响应链上。</p>

<h2>响应远程控制事件</h2>

<p>远程控制事件来源于一些外部的配件，如耳机等。用户可以通过耳机来控制视频或音频的播放。接收响应者对象需要检查事件的子类型来确定命令(如播放，子类型为UIEventSubtypeRemoteControlPlay)，然后进行相应处理。</p>

<p>为了响应远程控制事件，UIResponder提供了以下方法，</p>

<pre><code>- (void)remoteControlReceivedWithEvent:(UIEvent *)event
</code></pre>

<p>我们可以在子类中实现该方法，来处理远程控制事件。不过，为了允许分发远程控制事件，我们必须调用UIApplication的beginReceivingRemoteControlEvents方法；而如果要关闭远程控制事件的分发，则调用endReceivingRemoteControlEvents方法。</p>

<h2>获取Undo管理器</h2>

<p>默认情况下，程序的每一个window都有一个undo管理器，它是一个用于管理undo和redo操作的共享对象。然而，响应链上的任何对象的类都可以有自定义undo管理器。例如，UITextField的实例的自定义管理器在文件输入框放弃第一响应者状态时会被清理掉。当需要一个undo管理器时，请求会沿着响应链传递，然后UIWindow对象会返回一个可用的实例。</p>

<p>UIResponder提供了一个只读方法来获取响应链中共享的undo管理器，</p>

<pre><code>@property(nonatomic, readonly) NSUndoManager *undoManager
</code></pre>

<p>我们可以在自己的视图控制器中添加undo管理器来执行其对应的视图的undo和redo操作。</p>

<h2>验证命令</h2>

<p>在我们的应用中，经常会处理各种菜单命令，如文本输入框的"复制"、"粘贴"等。UIResponder为此提供了两个方法来支持此类操作。首先使用以下方法可以启动或禁用指定的命令：</p>

<pre><code>- (BOOL)canPerformAction:(SEL)action withSender:(id)sender
</code></pre>

<p>该方法默认返回YES，我们的类可以通过某种途径处理这个命令，包括类本身或者其下一个响应者。子类可以重写这个方法来开启菜单命令。例如，如果我们希望菜单支持"Copy"而不支持"Paser"，则在我们的子类中实现该方法。需要注意的是，即使在子类中禁用某个命令，在响应链上的其它响应者也可能会处理这些命令。</p>

<p>另外，我们可以使用以下方法来获取可以响应某一行为的接收者：</p>

<pre><code>- (id)targetForAction:(SEL)action withSender:(id)sender
</code></pre>

<p>在对象需要调用一个action操作时调用该方法。默认的实现是调用canPerformAction:withSender:方法来确定对象是否可以调用action操作。如果可以，则返回对象本身，否则将请求传递到响应链上。如果我们想要重写目标的选择方式，则应该重写这个方法。下面这段代码演示了一个文本输入域禁用拷贝/粘贴操作：</p>

<pre><code>- (id)targetForAction:(SEL)action withSender:(id)sender
{
    UIMenuController *menuController = [UIMenuController sharedMenuController];
    if (action == @selector(selectAll:) || action == @selector(paste:) ||action == @selector(copy:) || action == @selector(cut:)) {
        if (menuController) {
            [UIMenuController sharedMenuController].menuVisible = NO;
        }
        return nil;
    }
    return [super targetForAction:action withSender:sender];
}
</code></pre>

<h2>访问快捷键命令</h2>

<p>我们的应用可以支持外部设备，包括外部键盘。在使用外部键盘时，使用快捷键可以大大提高我们的输入效率。因此从iOS7后，UIResponder类新增了一个只读属性keyCommands，来定义一个响应者支持的快捷键，其声明如下：</p>

<pre><code>@property(nonatomic, readonly) NSArray *keyCommands
</code></pre>

<p>一个支持硬件键盘命令的响应者对象可以重新定义这个方法并使用它来返回一个其所支持快捷键对象(UIKeyCommand)的数组。每一个快捷键命令表示识别的键盘序列及响应者的操作方法。</p>

<p>我们用这个方法返回的快捷键命令数组被用于整个响应链。当与快捷键命令对象匹配的快捷键被按下时，UIKit会沿着响应链查找实现了响应行为方法的对象。它调用找到的第一个对象的方法并停止事件的处理。</p>

<h2>管理文本输入模式</h2>

<p>文本输入模式标识当响应者激活时的语言及显示的键盘。UIResponder为此定义了一个属性来返回响应者对象的文本输入模式：</p>

<pre><code>@property(nonatomic, readonly, retain) UITextInputMode *textInputMode
</code></pre>

<p>对于响应者而言，系统通常显示一个基于用户语言设置的键盘。我们可以重新定义这个属性，并让它返回一个不同的文本输入模式，以让我们的响应者使用一个特定的键盘。用户在响应者被激活时仍然可以改变键盘，在切换到另一个响应者时，可以再恢复到指定的键盘。</p>

<p>如果我们想让UIKit来跟踪这个响应者的文本输入模式，我们可以通过textInputContextIdentifier属性来设置一个标识，该属性的声明如下：</p>

<pre><code>@property(nonatomic, readonly, retain) NSString *textInputContextIdentifier
</code></pre>

<p>该标识指明响应者应保留文本输入模式的信息。在跟踪模式下，任何对文本输入模式的修改都会记录下来，当响应者激活时再用于恢复处理。</p>

<p>为了从程序的user default中清理输入模式信息，UIResponder定义了一个类方法，其声明如下：</p>

<pre><code>+ (void)clearTextInputContextIdentifier:(NSString *)identifier
</code></pre>

<p>调用这个方法可以从程序的user default中移除与指定标识相关的所有文本输入模式。移除这些信息会让响应者重新使用默认的文本输入模式。</p>

<h2>支持User Activities</h2>

<p>从iOS 8起，苹果为我们提供了一个非常棒的功能，即Handoff。使用这一功能，我们可以在一部iOS设备的某个应用上开始做一件事，然后在另一台iOS设备上继续做这件事。Handoff的基本思想是用户在一个应用里所做的任何操作都可以看作是一个Activity，一个Activity可以和一个特定iCloud用户的多台设备关联起来。在编写一个支持Handoff的应用时，会有以下三个交互事件：</p>

<ol>
<li>为将在另一台设备上继续做的事创建一个新的User Activity；</li>
<li>当需要时，用新的数据更新已有的User Activity；</li>
<li>把一个User Activity传递到另一台设备上。</li>
</ol>


<p>为了支持这些交互事件，在iOS 8后，UIResponder类新增了几个方法，我们在此不讨论这几个方法的实际使用，想了解更多的话，可以参考<a href="http://www.cocoachina.com/ios/20150115/10926.html">iOS 8 Handoff 开发指南</a>。我们在此只是简单描述一下这几个方法。</p>

<p>在UIResponder中，已经为我们提供了一个userActivity属性，它是一个NSUserActivity对象。因此我们在UIResponder的子类中不需要再去声明一个userActivity属性，直接使用它就行。其声明如下：</p>

<pre><code>@property(nonatomic, retain) NSUserActivity *userActivity
</code></pre>

<p>由UIKit管理的User Activities会在适当的时间自动保存。一般情况下，我们可以重写UIResponder类的updateUserActivityState:方法来延迟添加表示User Activity的状态数据。当我们不再需要一个User Activity时，我们可以设置userActivity属性为nil。任何由UIKit管理的NSUserActivity对象，如果它没有相关的响应者，则会自动失效。</p>

<p>另外，多个响应者可以共享一个NSUserActivity实例。</p>

<p>上面提到的updateUserActivityState:是用于更新给定的User Activity的状态。其定义如下：</p>

<pre><code>- (void)updateUserActivityState:(NSUserActivity *)activity
</code></pre>

<p>子类可以重写这个方法来按照我们的需要更新给定的User Activity。我们需要使用NSUserActivity对象的addUserInfoEntriesFromDictionary:方法来添加表示用户Activity的状态。</p>

<p>在我们修改了User Activity的状态后，如果想将其恢复到某个状态，则可以使用以下方法：</p>

<pre><code>- (void)restoreUserActivityState:(NSUserActivity *)activity
</code></pre>

<p>子类可以重写这个方法来使用给定User Activity的恢复响应者的状态。系统会在接收到数据时，将数据传递给application:continueUserActivity:restorationHandler:以做处理。我们重写时应该使用存储在user activity的userInfo字典中的状态数据来恢复对象。当然，我们也可以直接调用这个方法。</p>

<h2>参考</h2>

<ol>
<li><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIResponder_Class">UIResponder Class Reference</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Introduction/Introduction.html">Event Handling Guide for iOS</a></li>
<li><a href="http://www.cnblogs.com/kuku/archive/2011/11/12/2246389.html">iOS UIResponder 学习笔记</a></li>
<li><a href="http://firestudio.cn/blog/2013/12/26/ru-he-rang-ni-de-ios7ying-yong-zhi-chi-jian-pan-kuai-jie-jian/">如何让你的iOS7应用支持键盘快捷键</a></li>
<li><a href="http://www.cocoachina.com/ios/20150115/10926.html">iOS 8 Handoff 开发指南</a></li>
<li><a href="http://southpeak.github.io/blog/2015/03/01/fan-yi-pian-:ios-8-handoff-tutorial/">iOS 8 Handoff Tutorial</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[翻译篇：iOS 8 Handoff Tutorial]]></title>
    <link href="http://southpeak.github.io/blog/2015/03/01/fan-yi-pian-:ios-8-handoff-tutorial/"/>
    <updated>2015-03-01T12:33:51+08:00</updated>
    <id>http://southpeak.github.io/blog/2015/03/01/fan-yi-pian-:ios-8-handoff-tutorial</id>
    <content type="html"><![CDATA[<p>原文由Soheil Azarpour发表于raywenderlich，地址是<a href="http://www.raywenderlich.com/84174/ios-8-handoff-tutorial">iOS 8 Handoff Tutorial</a></p>

<p>Handoff是iOS 8和OS X Yosemite中的一个新特性。它让我们在不同的设备间切换时，可以不间断地继续一个Activity，而不需要重新配置任何设备。</p>

<p>我们可以为在iOS 8和Yosemite上的应用添加Handoff特性。在这篇指南中，我们将学习Handoff的基本功能和如何在非基于文档的app中使用Handoff。</p>

<h2>Handoff概览</h2>

<p>在开始写代码前，我们需要先来了解一下handoff的一些基本概念。</p>

<h3>起步</h3>

<p>Handoff不仅可以将当前的activity从一个iOS设备传递到OS X设备，还可以将activity在不同的iOS设备传递。目前在模拟器上还不能使用Handoff功能，所以需要在iOS设备上运行我们的实例。</p>

<h4>设备兼容性：iOS</h4>

<p>为了查看我们的iOS设备是否支持handoff功能，我们可以查看“设置”->“通用”列表。如果在列表中看到“Handoff与建议的应用程序”，则设备具备Handoff功能。以下截图显示了iPhone 5s(具备Handoff功能)和iPad3(不具备Handoff功能)的对比：</p>

<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/10/settings_screenshots-436x320.jpg" alt="image" /></p>

<p>Handoff功能依赖于以下几点：</p>

<ol>
<li>一个iCloud账户：我们必须在希望使用Handoff功能的多台设备上登录同一个iCloud账户。</li>
<li>低功耗蓝牙(Bluetooth LE 4.0)：Handoff是通过低功耗蓝牙来广播activities的，所以广播设备和接收设备都必须支持Bluetooth LE 4.0。</li>
<li>iCloud配对：设备必须已经通过iCloud配对。当在支持Handoff的设备上登录iCloud账户后，每台设备都会与其它支持Handoff的设备进行配对。</li>
</ol>


<p>此时，我们需要确保已经使用同一iCloud账号在两台支持Handoff功能且运行iOS 8+系统的设备上登录了。(译者注：具体配置可以参考<a href="https://support.google.com/chrome/answer/6153783?hl=zh-Hans">在 Chrome（iOS 版）中使用 Handoff</a>)</p>

<h3>User Activities</h3>

<p>Handoff是基于User Activity的。User Activity是一个独立的信息集合单位，可以不依赖于任何其它信息而进行传输(be handed off)。</p>

<p>NSUserActivity对象表示一个User Activity实例。它封装了程序的一些状态，这些状态可以在其它设备相关的程序中继续使用。</p>

<p>有三种方法和一个NSUserActivity对象交互：</p>

<p>1) 创建一个user activity：原始应用程序创建一个NSUserActivity实例并调用becomeCurrent()以开启一个广播进程。下面是一个实例：</p>

<pre><code>let activity = NSUserActivity(activityType: "com.razeware.shopsnap.view")
activity.title = "Viewing"
activity.userInfo = ["shopsnap.item.key": ["Apple", "Orange", "Banana"]]
self.userActivity = activity;
self.userActivity?.becomeCurrent()
</code></pre>

<p>我们可以使用NSUserActivity的userInfo字典来传递本地数据类型对象或可编码的自定义对象以将其传输到接收设备。本地数据类型包括NSArray, NSData, NSDate, NSDictionary, NSNull, NSNumber, NSSet, NSString, NSUUID和NSURL。通过NSURL可能会有点棘手。在使用NSURL前可以先参考一下下面的“最佳实践”一节。</p>

<p>2) 更新user activity：一旦一个NSUserActivity成为当前的activity，则iOS会在最上层的视图控制器中调用updateUserActivityState(activity:)方法，以让我们有机会来更新user activity。下面是一个实例：</p>

<pre><code>override func updateUserActivityState(activity: NSUserActivity) {
  let activityListItems = // ... get updated list of items
  activity.addUserInfoEntriesFromDictionary(["shopsnap.item.key": activityListItems])
  super.updateUserActivityState(activity)
}
</code></pre>

<p>注意我们不要将userInfo设置为一个新的字典或直接更新它，而是应该使用便捷方法addUserInfoEntriesFromDictionary()。</p>

<p>在下文中，我们将学习如何按需求强制刷新user activity，或者是在程序的app delegate级别来获取一个相似功能的回调。</p>

<p>3) 接收user activity：当我们的接收程序以Handoff的方式启动时，程序代理会调用application(:willContinueUserActivityWithType:)方法。注意这个方法的参数不是NSUserActivity对象，因为接收程序在下载并传递NSUserActivity数据需要花费一定的时间。在user activity已经被下载完成后，会调用以下的回调函数：</p>

<pre><code>func application(application: UIApplication!, 
                 continueUserActivity userActivity: NSUserActivity!,
                 restorationHandler: (([AnyObject]!) -&gt; Void)!) 
                 -&gt; Bool {

  // Do some checks to make sure you can proceed
  if let window = self.window {
    window.rootViewController?.restoreUserActivityState(userActivity)
  }
  return true
}
</code></pre>

<p>然后我们可以使用存储在NSUserActivity对象中的数据来重新创建用户的activity。在这里，我们更新我们的应用以继续相关的activity。</p>

<h3>Activity类型</h3>

<p>当创建一个user activity后，我们必须为其指定一个activity类型。一个activity类型是一个简单的唯一字符串，通常使用反转DNS语义，如com.razeware.shopsnap.view。</p>

<p>每一个可以接收user activity的程序都必须声明其可接收的activity类型。这类似于在程序中声明支持的URL方案(URL scheme)。对于非基于文本的程序，activity类型需要在Info.plist文件中定义，其键值为NSUserActivityTypes，如下所示：</p>

<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/10/image10-38-480x259.png" alt="image" /></p>

<p>对于支持一个给定activity的程序来说，需要满足三个要求：</p>

<ol>
<li>相同的组：两个程序都必须源于使用同一开发者组ID(developer Team ID)的开发者。</li>
<li>相同的activity类型：发送程序创建某一activity类型的user activity，接收程序必须有相应类型的NSUserActivityTypes入口。</li>
<li>签约：两个程序必须通过App store来发布或使用同一开发者账号来签约。</li>
</ol>


<p>现在我们已经学习了user activities和activity类型的基础知识，接下来让我们来看一个实例。</p>

<h2>启动工程</h2>

<p>本指南的启动工程可以在“<a href="http://cdn2.raywenderlich.com/wp-content/uploads/2014/10/ShopSnap-Starter.zip">启动工程</a>”中下载。下载后，使用Xcode打开工程并在iPhone模拟器中运行。</p>

<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/10/App_Screenshots-700x412.jpg" alt="image" /></p>

<p>工程名是ShopSnap，我们可以在这个程序中构建一个简单的购物清单。一个购物项由一个字符串表示，然后我们将购物项存储在一个字符串的数组中。点击+按钮添加一个新的项目到清单中，而轻扫可以移除项目。</p>

<p>我们将在程序中定义两个独立的user activity：</p>

<ol>
<li>查看清单。如果用户当前正在查看清单，我们将传输整个数组。</li>
<li>添加或编译项目。如果用户当前正在添加新的项目，我们将传递一个单一项目的“编辑”activity。</li>
</ol>


<h3>设置开发组</h3>

<p>为了让Handoff工作，发送和接收app都必须使用相同的开发组来签约。由于这个示例程序即是发送者也是接收者，所以这很简单！</p>

<p>选择ShopSnap工程，在“通用”选项卡中，在"Team"中选择自己的开发组：</p>

<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2014/10/image15-49-700x232.png" alt="image" /></p>

<p>在支持Handoff的设备中编译并运行程序，以确保运行正常，然后继续。</p>

<h3>配置activity类型</h3>

<p>接下来是配置程序所支持的activity类型。打开"Supporting Files\Info.plist"，点击"Information Property List"旁边的"+&ldquo;按钮，在"Information Property List"中添加一个新的选项：</p>

<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/10/image16-52-480x268.png" alt="image" /></p>

<p>键名为"NSUserActivityTypes"，类型设备为数组类型，如下所示：</p>

<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2014/10/image17-55-480x233.png" alt="image" /></p>

<p>在NSUserActivityTypes下添加两项并设置类型为字符串。Item 0的值为com.razeware.shopsnap.view，Item 1的值为com.razeware.shopsnap.edit。</p>

<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/10/image18-58-480x85.png" alt="image" /></p>

<p>这些任意的activity类型对于我们的程序来说是特定和唯一的。因为我们将在程序的不同地方引用它们，所以在独立的文件中将其添加为常量是一种好的实践。</p>

<p>在工程导航中右键点击ShopSnap组，选择"New File \ iOS \ Source \ Swift File"。将文件命名为Constants.swift并确保新类被添加到ShopSnap target中。</p>

<p>在类中添加以下代码：</p>

<pre><code>let ActivityTypeView = "com.razeware.shopsnap.view"
let ActivityTypeEdit = "com.razeware.shopsnap.edit"

let ActivityItemsKey = "shopsnap.items.key"
let ActivityItemKey  = "shopsnap.item.key"
</code></pre>

<p>然后我们就可以使用这两个activity类型的常量。同时我们定义一些用于user activity的userInfo字典的键名字符串。</p>

<h3>快速端到端测试</h3>

<p>让我们来运行一个快速端到端测试以确保设备可以正确地通信。</p>

<p>打开ListViewController.swift并添加以下两个函数：</p>

<pre><code>// 1.
func startUserActivity() {
  let activity = NSUserActivity(activityType: ActivityTypeView)
  activity.title = "Viewing Shopping List"
  activity.userInfo = [ActivityItemsKey: ["Ice cream", "Apple", "Nuts"]]
  userActivity = activity
  userActivity?.becomeCurrent()
}

// 2.
override func updateUserActivityState(activity: NSUserActivity) {
  activity.addUserInfoEntriesFromDictionary([ActivityItemsKey: ["Ice cream", "Apple", "Nuts"]])
  super.updateUserActivityState(activity)
}
</code></pre>

<p>我们通过硬编码一个user activity来快速测试，以确保我们可以在另一端正常接收。</p>

<p>上面的代码做了以下两件事：</p>

<ol>
<li>startUserActivity()是一个辅助函数，它使用一个硬编码的购物清单来创建了一个NSUserActivity实例。然后调用becomeCurrent()来广播这个activity。</li>
<li>在调用becomeCurrent()后，系统将定期调用updateUserActivityState()。UIViewController从UIResponder类中继承了这个方法，我们应该重写它来更新我们的userActivity的状态。在这里，我们像前面一样使用硬编码来更新购物清单。注意，我们应该使用addUserInfoEntriesFromDictionary方法来修改NSUserActivity的userInfo字典。我们应该总是在方法的结尾调用super.updateUserActivityState()。</li>
</ol>


<p>注意，我们只需要调用上面的起始方法。在viewDidLoad()起始行下面添加以下代码</p>

<pre><code>startUserActivity()
</code></pre>

<p>开始广播至少需要以上步骤。现在来看看接收者。打开AppDelegate.swift并添加以下代码：</p>

<pre><code>func application(application: UIApplication!, 
                 continueUserActivity userActivity: NSUserActivity!, 
                 restorationHandler: (([AnyObject]!) -&gt; Void)!) 
                 -&gt; Bool {

  let userInfo = userActivity.userInfo as NSDictionary
  println("Received a payload via handoff: \(userInfo)")
  return true
}
</code></pre>

<p>AppDelegate中的这个方法在所有事情都准备好，且一个userActivity被成功传送后调用。在这里我们简单打印userActivity中的userInfo字典。我们返回true来标识我们处理了user activity。</p>

<p>让我们来试试！要想在两台设备中正常工作，还需要做一些协调工作，所以还得仔细跟着。</p>

<ol>
<li>在第一台设备上安装并运行程序。</li>
<li>在第二台设备上安装并运行程序。确保在Xcode中调用程序以便我们能看到打印输出。</li>
<li><p>按下电源按钮让第二台设备休眠。在同一台设备上，按下Home键。如果所有事件都正常运行，我们应该可以看到ShopSnap程序的icon显示在屏幕的左下角上。从这里我们可以启动程序，然后在Xcode控制台可以看到以下的日志信息：</p>

<p> Received a payload via handoff: {
     &ldquo;shopsnap.items.key&rdquo; = (
     &ldquo;Ice cream&rdquo;,
     Apple,
     Nuts
   );
 }</p></li>
</ol>


<p>如果在锁屏下没有看到程序的icon，则在源设备上关闭并重新打开程序。这将强制系统重新广播信息。同时确认一下设备的控制台以查看是否有来自于Handoff的错误消息。</p>

<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2014/10/image20-63-180x320.png" alt="image" /></p>

<h2>创建一个新的Activity</h2>

<p>现在我们有一个基本上可以工作的Handoff程序，是时候来扩展它了。打开ListViewController.swift，更新startUserActivity()方法，这次我们传入实际的购物清单以代码硬编码。使用以下代码来更新方法：</p>

<pre><code>func startUserActivity() {
  let activity = NSUserActivity(activityType: ActivityTypeView)
  activity.title = "Viewing Shopping List"
  activity.userInfo = [ActivityItemsKey: items]
  userActivity = activity
  userActivity?.becomeCurrent()
}
</code></pre>

<p>同样，更新ListViewController.swift的updateUserActivityState(activity:)方法，传递购物清单数组：</p>

<pre><code>override func updateUserActivityState(activity: NSUserActivity) {
  activity.addUserInfoEntriesFromDictionary([ActivityItemsKey: items])
  super.updateUserActivityState(activity)
}
</code></pre>

<p>现在，更新ListViewController.swift中的viewDidLoad()，在从前面的代码中成功获取到清单后开启userActivity，如下所示：</p>

<pre><code>override func viewDidLoad() {
  title = "Shopping List"
  weak var weakSelf = self
  PersistentStore.defaultStore().fetchItems({ (items:[String]) in
    if let unwrapped = weakSelf {
      unwrapped.items = items
      unwrapped.tableView.reloadData()
      if items.isEmpty == false {
        unwrapped.startUserActivity()
      }
    }
  })
  super.viewDidLoad()
}
</code></pre>

<p>当然，如果程序开始时，清单是空的，则程序不会去广播user activity。我们需要解决这个问题：在用户第一次添加一个购物项到列表时开启user activity。</p>

<p>为了做到这一点，更新ListViewController.swift中代理回调detailViewController(controller:didFinishWithUpdatedItem:)的实现，如下所示：</p>

<pre><code>func detailViewController(#controller: DetailViewController,
                          didFinishWithUpdatedItem item: String) {
    // ... some code
    if !items.isEmpty {
      startUserActivity()
    }
}
</code></pre>

<p>在此有三种可能：</p>

<ol>
<li>用于更新一个已存在的购物项</li>
<li>用户删除一个存在的购物项</li>
<li>用户添加一个新的购物项</li>
</ol>


<p>现存的代码处理了所有的可能性；我们只需要添加一些检测代码，以在有一个非空的清单时开始一个activity。</p>

<p>在两台设备上编译并运行。此时，我们应该可以在一台设备上添加新的项目，然后将其发送给另外一台设备。</p>

<h3>收尾</h3>

<p>当用户开始添加一个新的项目或编辑一个已存在的项目时，用户可能不是在查看购物清单。所以我们需要停止广播当前activity。同样，当清单中的所有项目被删除时，没有理由去继续广播当前activiry。在ListViewController.swift中添加以下辅助方法：</p>

<pre><code>func stopUserActivity() {
  userActivity?.invalidate()
}
</code></pre>

<p>在stopUserActivity()中，我们废止已存在的NSUserActivity。这让handoff停止广播。</p>

<p>现在有了stopUserActivity()，是时候在适当的地方调用它了。</p>

<p>在ListViewController.swift中，更新prepareForSegue(segue:, sender:)方法的实现，如下所示：</p>

<pre><code>override func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject!) {
    // ... some code
    stopUserActivity()
}
</code></pre>

<p>当用户选择一行或者点击添加按钮时，ListViewController准备导航到详情视图。我们废弃当前的清单查看activity。</p>

<p>在同一文件中，更新tableView(_:commitEditingStyle:forRowAtIndexPath:)的实现，如下所示：</p>

<pre><code>override func tableView(tableView: UITableView, 
                        commitEditingStyle editingStyle: UITableViewCellEditingStyle,
                        forRowAtIndexPath indexPath: NSIndexPath) {
  // ... some code
  if items.isEmpty {
    stopUserActivity()
  } else {
    userActivity?.needsSave = true
  }
}
</code></pre>

<p>当用户从清单中删除一项时，我们需要相应地更新user activity。如果移除清单中的所有项目，我们停止广播。否则，我们设置userActivity的needsSave属性为true。当我们这样做时，系统会立即回调updateUserActivityState(activity:)，在这里我们会更新userActivity。</p>

<p>结束这一节之前，还有一种情况需要考虑，用户点击取消按钮，然后从DetailViewController中返回。这触发了一个已存在的场景。我们需要重新开始userActivity。更新unwindDetailViewController(unwindSegue:)的实现，如下所示：</p>

<pre><code>@IBAction func unwindDetailViewController(unwindSegue: UIStoryboardSegue) {
  // ... some code
  startUserActivity()
}
</code></pre>

<p>编译并运行，确保所有事情运行正常。尝试添加一些项目到清单中，确保它们在设备间传输。</p>

<h2>创建一个编辑Activity</h2>

<p>接下来，我们以类似的方式来处理DetailViewController。这一次，我们广播另一个activity类型。</p>

<p>打开DetailViewController.swift并修改textFieldDidBeginEditing(textField:)，如下所示：</p>

<pre><code>func textFieldDidBeginEditing(textField: UITextField!) {
  // Broadcast what we have, if there is anything!
  let activity = NSUserActivity(activityType: ActivityTypeEdit)
  activity.title = "Editing Shopping List Item"
  let activityItem = (countElements(textField.text!) &gt; 0) ? textField.text : ""
  activity.userInfo = [ActivityItemKey: activityItem]
  userActivity = activity
  userActivity?.becomeCurrent()
}
</code></pre>

<p>上面的方法使用项目的字符串的当前内容创建一个“编辑”activity。</p>

<p>当用户继续编辑项目时，我们需要更新user activity。仍然是在DetailViewController.swift中，更新textFieldTextDidChange(notification:)的实现，如下所示：</p>

<pre><code>func textFieldTextDidChange(notification: NSNotification) {
  if let text = textField!.text {
    item = text
  }

  userActivity?.needsSave = true
}
</code></pre>

<p>现在我们已经标记了activity需要更新，接下来实现updateUserActivityState(activity:)，以备系统的更新需求：</p>

<pre><code>override func updateUserActivityState(activity: NSUserActivity) {
  let activityListItem = (countElements(textField!.text!) &gt; 0) ? textField!.text : ""
  activity.addUserInfoEntriesFromDictionary([ActivityItemKey: activityListItem])
  super.updateUserActivityState(activity)
}
</code></pre>

<p>这里我们简单地更新了当前项为文本输入框中的文本。</p>

<p>编译并运行。此时，如果我们在一个设备中开始添加一个新项或编辑已存在的项目，我们可以将编辑进程同步给另一个设备。</p>

<h3>收尾</h3>

<p>因为needsSave是一个轻量级的操作，在上面的代码中，你可以根据需要来设置它，然后在每次按键时更新userInfo。</p>

<p>这里有一个小细节你可能已经注意到了。视图控制器在iPad和iPhone的景观模式下中是一个分离视图。这样可以在清单的项目间切换而不需要收起键盘。这种情况发生时，textFieldDidBeginEditing(textField:)方法不会被调用，导致我们的user activity不会更新为新的文本。</p>

<p>为了解决这个问题，更新DetailViewController.swift中item属性的didSet观察者，如下所示：</p>

<pre><code>var item: String? {
  didSet {
    if let textField = self.textField {
      textField.text = item
    }
    if let activity = userActivity {
      activity.needsSave = true
    }
  }
}
</code></pre>

<p>当用户点击ListViewController中的一个项目时，DetailViewController的item属性被设置。一个简单解决方案是让视图控制器知道，在项目更新时它必须更新activity。</p>

<p>最后，当用户离开DetailViewController时，我们需要废止userActivity，以让编辑activity不再被广播。</p>

<p>在DetailViewController.swift的textFieldShouldReturn(_:)方法的起始位置添加以下代码：</p>

<pre><code>userActivity?.invalidate()
</code></pre>

<p>编译并运行程序，确保程序工作正常。接下来，我们将处理接收的activity。</p>

<h2>接收Activity</h2>

<p>当用户通过Handoff启动程序时，处理接收的NSUserActivity的任务大部分是由程序的delegate来完成的。</p>

<p>假设所有事情运行正常，数据成功传输，iOS会调用application(_:continueUserActivity:restorationHandler:)方法。这是我们与NSUserActivity实例交互的第一次机会。</p>

<p>我们在前面的章节中已经有一个该方法的实现了。现在，我们做如下修改：</p>

<pre><code>func application(application: UIApplication!, 
                 continueUserActivity userActivity: NSUserActivity!,
                 restorationHandler: (([AnyObject]!) -&gt; Void)!)
                 -&gt; Bool {

  if let window = self.window {
    window.rootViewController?.restoreUserActivityState(userActivity)
  }
  return true
}
</code></pre>

<p>我们将userActivity传递给程序的window对象的rootViewController，然后返回true。这告诉系统成功处理了Handoff行为。从这里开始，我们将自己转发调用并恢复activity。</p>

<p>我们在rootViewController中调用的方法是restoreUserActivityState(activity:)。这是在UIResponder中声明的一个标准方法。系统使用这个方法来告诉接收者恢复一个NSUserActivivty实例。</p>

<p>我们现在的任务是沿着视图控制器架构往下，将activity从父视图控制器传递到子视图控制器，直到到达需要使用activity的地方：</p>

<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/10/image22-691-700x360.png" alt="image" /></p>

<p>根视图控制器是一个TraitOverrideViewController对象，它的任务是管理程序的size classes；它对我们的user activity不感兴趣。打开TraitOverrideViewController.swift并添加以下代码：</p>

<pre><code>override func restoreUserActivityState(activity: NSUserActivity) {
  let nextViewController = childViewControllers.first as UIViewController
  nextViewController.restoreUserActivityState(activity)
  super.restoreUserActivityState(activity)
}
</code></pre>

<p>在这里，我们获取TraitOverrideViewController的第一个子视图控制器，然后将activity往下传递。这样做是安全的，因为我们知道程序的视图控制器只包含一个子视图控制器。</p>

<p>层级架构中的下一个视图控制器是SplitViewController，在这里事情会变得更有趣一些。</p>

<p>打开SplitViewController.swift并添加以下代码：</p>

<pre><code>override func restoreUserActivityState(activity: NSUserActivity) {
  // What type of activity is it?
  let activityType = activity.activityType

  // This is an activity for ListViewController.
  if activityType == ActivityTypeView {
    let controller = viewControllerForViewing()
    controller.restoreUserActivityState(activity)

  } else if activityType == ActivityTypeEdit {
    // This is an activity for DetailViewController.
    let controller = viewControllerForEditing()
    controller.restoreUserActivityState(activity)
  }

  super.restoreUserActivityState(activity)
}
</code></pre>

<p>SplitViewController知道ListViewController和DetailViewController。如果NSUserActivity是一个列表查看activity类型，则将其传递给ListViewController；否则，如果是一个编辑activity类型，则传递给DetailViewController。</p>

<p>我们将所有的activity传递给正确的对象，现在是时候从这些activity中获取数据了。</p>

<p>打开ListViewController.swift并实现restoreUserActivityState(activity:)，如下所示：</p>

<pre><code>override func restoreUserActivityState(activity: NSUserActivity) {
  // Get the list of items.
  if let userInfo = activity.userInfo {
    if let importedItems = userInfo[ActivityItemsKey] as? NSArray {
      // Merge it with what we have locally and update UI.
      for anItem in importedItems {
        addItemToItemsIfUnique(anItem as String)
      }
      PersistentStore.defaultStore().updateStoreWithItems(items)
      PersistentStore.defaultStore().commit()
      tableView.reloadData()
    }
  }
  super.restoreUserActivityState(activity)
}
</code></pre>

<p>在上面的方法中，我们终于可以继续一个查看activity了。因为我们需要维护一个唯一的购物清单时，我们只需要将这些唯一的项目添加到本地列表中，然后保存并更新UI。</p>

<p>编译并运行。现在我们可以看到通过Handoff从另一台设备上同步过来的清单数据了。</p>

<p>编辑activity以类似的方法来处理。打开DetailViewController.swift并实现restoreUserActivityState(activity:)，如下所示：</p>

<pre><code>override func restoreUserActivityState(activity: NSUserActivity) {
  if let userInfo = activity.userInfo {
    var activityItem: AnyObject? = userInfo[ActivityItemKey]
    if let itemToRestore = activityItem as? String {
      item = itemToRestore
      textField?.text = item
    }
  }
  super.restoreUserActivityState(activity)
}
</code></pre>

<p>这里获取编辑activity的信息并更新文本域的内容。</p>

<p>编译并运行，查看运行结果！</p>

<h3>收尾</h3>

<p>当用户在另一台设备上点击程序的icon以表明他们想要继续一个user activity时，系统启动相应的程序。一旦程序启动后，系统调用application(_, willContinueUserActivityWithType:)方法。打开AppDelegate.swift并添加以下方法：</p>

<pre><code>func application(application: UIApplication,
                 willContinueUserActivityWithType userActivityType: String!)
                 -&gt; Bool {
  return true
}
</code></pre>

<p>到这里，我们的程序已经下载了NSUserActivity实例及其userInfo有效载荷。现在我们只是简单返回true。这强制程序在每次用户初始Handoff进程时接收activity。如果想要通知用户activity正在处理，则这是个好地方。</p>

<p>到这里，系统开始将数据从一台设备同步到另一台设备上。我们已经覆盖了任务正常运行的所有情况。但是可以想象Handoff的activity在某些情况下会失败。</p>

<p>将以下方法添加到AppDelegate.swift中来处理这种情况：</p>

<pre><code>func application(application: UIApplication!, 
                 didFailToContinueUserActivityWithType userActivityType: String!,
                 error: NSError!) {

  if error.code != NSUserCancelledError {
    let message = "The connection to your other device may have been interrupted. Please try again. \(error.localizedDescription)"
    let alertView = UIAlertView(title: "Handoff Error", message: message, delegate: nil, cancelButtonTitle: "Dismiss")
    alertView.show()
  }
}
</code></pre>

<p>如果我们接收到除了NSUserCancelledError之外的任何信息，则发生了某些错误，且我们不能恢复activity。在这种情况下，我们显示一个适当的消息给用户。然而，如果用户显示取消Handoff行为，则在这里我们不需要做任何事情，只需要放弃操作。</p>

<h2>版本支持</h2>

<p>使用Handoff的最佳实践之一是版本化。处理这的一个策略是为每个发送的Handoff添加一个版本号，并且只接收来自这个版本号(或者更早的)handoff。让我们来试试。</p>

<p>打开Constants.swift并添加以下常量：</p>

<pre><code>let ActivityVersionKey = "shopsnap.version.key"
let ActivityVersionValue = "1.0"
</code></pre>

<p>上面的版本键名和值是我们为这个版本的程序随意挑选的键值对。</p>

<p>如果我们回顾一下上面的章节，系统会定期并自动调用restoreUserActivityState(activity:)方法。这个方法的实现聚集于并限定于实现它的对象的范围内。例如，ListViewController重写了这个方法来更新带有购物清单的userActivity，而DetailViewController的实现是更新当前正在被编辑的项目。</p>

<p>如果涉及到的东西对于userActivity来说是通用的，可用于所有的user activity，如版本号，则处理它的最好的地方就是在AppDelegate中了。</p>

<p>任何时候调用restoreUserActivityState(activity:)，系统都会紧接着调用程序delegate的application(application:, didUpdateUserActivity userActivity:)方法。我们使用这个方法来为我们的Handoff添加版本支持。</p>

<p>打开AppDelegate.swift并添加以下代码：</p>

<pre><code>func application(application: UIApplication, 
                 didUpdateUserActivity userActivity: NSUserActivity) {
  userActivity.addUserInfoEntriesFromDictionary([ActivityVersionKey: ActivityVersionValue])
}
</code></pre>

<p>在这里我们简单地使用了程序的版本号来更新了userInfo字典。</p>

<p>仍然是在AppDelegate.swift中，更新application(_:, continueUserActivity: restorationHandler:)的实现，如下所示：</p>

<pre><code>func application(application: UIApplication!,
                 continueUserActivity userActivity: NSUserActivity!,
                 restorationHandler: (([AnyObject]!) -&gt; Void)!)
                 -&gt; Bool {

  if let userInfo: NSDictionary = userActivity.userInfo {
    if let version = userInfo[ActivityVersionKey] as? String {
      // Pass it on.
      if let window = self.window {
        window.rootViewController?.restoreUserActivityState(userActivity)
      }
      return true
    }
  }
  return false
}
</code></pre>

<p>在这里我们检查userAcitivty的版本，只有当版本号与我们知道的相匹配时才传递。编译并运行，确保程序运行正常。</p>

<h2>Handoff最佳实践</h2>

<p>在结束之前，我们来看看Handoff的最佳实践：</p>

<ol>
<li><p>NSURL：在NSUserActivity的userInfo字典中使用NSURL有点棘手。唯一可以安全地在Handoff中传输的NSURLs是使用HTTP/HTTPS和iCloud文档的web网址。我们不能传递本地文件的URL，因为在接收者端，接收者不能正确地转换并映射这些URL。传输文件链接的最好的方式是传递相对路径，然后在接收者端重新构建我们的URL。</p></li>
<li><p>平台特定值：避免使用平台特定值，如滑动视图的内容偏移量；更好的方法是使用相对位置。例如，如果用户查看table view中的一些项目时，在我们的user activity中传递table view最上面的可视项的index path，而不是传递table view可视区域的内容偏移量。</p></li>
<li><p>版本：想想在程序中使用版本和将来的更新。我们可以在程序的未来版本中添加一些新数据格式或者从userInfo字典中移除值。版本让我们可以理好地控制我们的user activity在当前和将来版本的程序中的行为。</p></li>
</ol>


<h2>下一步是哪</h2>

<p>这里是<a href="http://cdn5.raywenderlich.com/wp-content/uploads/2014/10/ShopSnap-Final.zip">示例工程</a>的最终版本。</p>

<p>如果想了解更多的关于Handoff，流和基于文档的Handoff，则可以查看Handoff的开发文档<a href="https://developer.apple.com/library/prerelease/ios/documentation/UserExperience/Conceptual/Handoff/HandoffFundamentals/HandoffFundamentals.html">Apple’s Handoff Programming Guide</a>以获取更多的信息。</p>

<p>如果喜欢这篇文章，则可以下载我们的书<a href="http://www.raywenderlich.com/store/ios-8-by-tutorials">iOS 8 by Tutorials</a>，这里塞满了这样的教程。</p>

<p>如果有更多的总量或关于这篇文章的评论，那么可以加入下面的讨论。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSCache]]></title>
    <link href="http://southpeak.github.io/blog/2015/02/11/nscache/"/>
    <updated>2015-02-11T21:45:14+08:00</updated>
    <id>http://southpeak.github.io/blog/2015/02/11/nscache</id>
    <content type="html"><![CDATA[<p>NSCache是一个类似于集合的容器，即缓存。它存储key-value对，这一点类似于NSDictionary类。我们通常用使用缓存来临时存储短时间使用但创建昂贵的对象。重用这些对象可以优化性能，因为它们的值不需要重新计算。另外一方面，这些对象对于程序来说不是紧要的，在内存紧张时会被丢弃。如果对象被丢弃了，则下次使用时需要重新计算。</p>

<p>当一个key-value对在缓存中时，缓存维护它的一个强引用。存储在NSCache中的通用数据类型通常是实现了NSDiscardableContent协议的对象。在缓存中存储这类对象是有好处的，因为当不再需要它时，可以丢弃这些内容，以节省内存。默认情况下，缓存中的NSDiscardableContent对象在其内容被丢弃时，会被移除出缓存，尽管我们可以改变这种缓存策略。如果一个NSDiscardableContent被放进缓存，则在对象被移除时，缓存会调用discardContentIfPossible方法。</p>

<p>NSCache与可变集合有几点不同：</p>

<ol>
<li>NSCache类结合了各种自动删除策略，以确保不会占用过多的系统内存。如果其它应用需要内存时，系统自动执行这些策略。当调用这些策略时，会从缓存中删除一些对象，以最大限度减少内存的占用。</li>
<li>NSCache是线程安全的，我们可以在不同的线程中添加、删除和查询缓存中的对象，而不需要锁定缓存区域。</li>
<li>不像NSMutableDictionary对象，一个缓存对象不会拷贝key对象。</li>
</ol>


<p>这些特性对于NSCache类来说是必须的，因为在需要释放内存时，缓存必须异步地在幕后决定去自动修改自身。</p>

<h2>缓存限制</h2>

<p>NSCache提供了几个属性来限制缓存的大小，如属性countLimit限定了缓存最多维护的对象的个数。声明如下：</p>

<pre><code>@property NSUInteger countLimit
</code></pre>

<p>默认值为0，表示不限制数量。但需要注意的是，这不是一个严格的限制。如果缓存的数量超过这个数量，缓存中的一个对象可能会被立即丢弃、或者稍后、也可能永远不会，具体依赖于缓存的实现细节。</p>

<p>另外，NSCache提供了totalCostLimit属性来限定缓存能维持的最大内存。其声明如下：</p>

<pre><code>@property NSUInteger totalCostLimit
</code></pre>

<p>默认值也是0，表示没有限制。当我们添加一个对象到缓存中时，我们可以为其指定一个消耗(cost)，如对象的字节大小。如果添加这个对象到缓存导致缓存总的消耗超过totalCostLimit的值，则缓存会自动丢弃一些对象，直到总消耗低于totalCostLimit值。不过被丢弃的对象的顺序无法保证。</p>

<p>需要注意的是totalCostLimit也不是一个严格限制，其策略是与countLimit一样的。</p>

<h2>存取方法</h2>

<p>NSCache提供了一组方法来存取key-value对，类似于NSMutableDictionary类。如下所示：</p>

<pre><code>- (id)objectForKey:(id)key

- (void)setObject:(id)obj forKey:(id)key

- (void)removeObjectForKey:(id)key

- (void)removeAllObjects
</code></pre>

<p>如上所述，与NSMutableDictionary不同的就是它不会拷贝key对象。</p>

<p>此外，我们在存储对象时，可以为对象指定一个消耗值，如下所示：</p>

<pre><code>- (void)setObject:(id)obj forKey:(id)key cost:(NSUInteger)num
</code></pre>

<p>这个消耗值用于计算缓存中所有对象的一个消耗总和。当内存受限或者总消耗超过了限定的最大总消耗，则缓存应该开启一个丢弃过程以移除一些对象。不过，这个过程不能保证被丢弃对象的顺序。其结果是，如果我们试图操作这个消耗值来实现一些特殊的行为，则后果可能会损害我们的程序。通常情况下，这个消耗值是对象的字节大小。如果这些信息不是现成的，则我们不应该去计算它，因为这样会使增加使用缓存的成本。如果我们没有可用的值传递，则直接传递0，或者是使用-setObject:forKey:方法，这个方法不需要传入一个消耗值。</p>

<h2>NSDiscardableContent协议</h2>

<p>NSDiscardableContent是一个协议，实现这个协议的目的是为了让我们的对象在不被使用时，可以将其丢弃，以让程序占用更少的内存。</p>

<p>一个NSDiscardableContent对象的生命周期依赖于一个“counter”变量。一个NSDiscardableContent对象实际是一个可清理内存块，这个内存记录了对象当前是否被其它对象使用。如果这块内存正在被读取，或者仍然被需要，则它的counter变量是大于或等于1的；当它不再被使用时，就可以丢弃，此时counter变量将等于0。当counter变量等于0时，如果当前时间点内存比较紧张的话，内存块就可能被丢弃。</p>

<p>为了丢弃这些内容，可以调用对象的discardContentIfPossible方法，该方法的声明如下：</p>

<pre><code>- (void)discardContentIfPossible
</code></pre>

<p>这样当counter变量等于0时将会释放相关的内存。而如果counter变量不为0，则该方法什么也不做。</p>

<p>默认情况下，NSDiscardableContent对象的counter变量初始值为1，以确保对象不会被内存管理系统立即释放。从这个点开始，我们就需要去跟踪counter变量的状态。为此。协议声明了两个方法：beginContentAccess和endContentAccess。</p>

<p>其中调用beginContentAccess方法会增加对象的counter变量(+1)，这样就可以确保对象不会被丢弃。该方法声明如下：</p>

<pre><code>- (BOOL)beginContentAccess
</code></pre>

<p>通常我们在对象被需要或者将要使用时调用这个方法。具体的实现类可以决定在对象已经被丢弃的情况下是否重新创建这些内存，且重新创建成功后返回YES。协议的实现者在NSDiscardableContent对象被使用，而又没有调用它的beginContentAccess方法时，应该抛出一个异常。</p>

<p>函数的返回值如果是YES，则表明可丢弃内存仍然可用且已被成功访问；否则返回NO。另外需要注意的是，该方法是在实现类中必须实现(required)。</p>

<p>与beginContentAccess相对应的是endContentAccess。如果可丢弃内存不再被访问时调用。其声明如下：</p>

<pre><code>- (void)endContentAccess
</code></pre>

<p>该方法会减少对象的counter变量，通常是让对象的counter值变回为0，这样在对象的内容不再被需要时，就要以将其丢弃。</p>

<p>NSCache类提供了一个属性，来标识缓存是否自动舍弃那些内存已经被丢弃的对象(discardable-content object)，其声明如下：</p>

<pre><code>@property BOOL evictsObjectsWithDiscardedContent
</code></pre>

<p>如果设置为YES，则在对象的内存被丢弃时舍弃对象。默认值为YES。</p>

<h2>NSCacheDelegate代理</h2>

<p>NSCache对象还有一个代理属性，其声明如下：</p>

<pre><code>@property(assign) id&lt; NSCacheDelegate &gt; delegate
</code></pre>

<p>实现NSCacheDelegate代理的对象会在对象即将从缓存中移除时执行一些特定的操作，因此代理对象可以实现以下方法：</p>

<pre><code>- (void)cache:(NSCache *)cache willEvictObject:(id)obj
</code></pre>

<p>需要注意的是在这个代理方法中不能修改cache对象。</p>

<h2>小结</h2>

<p>实际上，我们常用的SDWebImage图片下载库的缓存机制就是通过NSCache来实现的。《Effective Objective-C 2.0》中也专门用一小篇的内容来介绍NSCache的使用(第50条：构建缓存时选用NSCache而非NSDictionary)，里面有更精彩的内容。如果我们需要构建缓存机制，则应该使用NSCache，而不是NSDictionary，这样可以减少我们应用对内存的占用，从而达到优化内存的目标。</p>

<p><em>题外话：最近好好久不用的微博整理了一下，重新开始混微博圈了，哈哈，还是个菜鸟。还望大家多提意见啊。微博号：南峰子_老驴(<a href="http://weibo.com/touristdiary">http://weibo.com/touristdiary</a>)</em></p>

<h2>参考</h2>

<ol>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/NSCache_Class/">NSCache Class Reference</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/NSDiscardableContent_Protocol/index.html">NSDiscardableContent Protocol Reference</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/NSCacheDelegate_Protocol/index.html">NSCacheDelegate Protocol Reference</a></li>
<li><a href="http://www.15yan.com/story/45toOUzFGlr/">Objective-C中的缓存: NSCache介绍</a></li>
<li><a href="http://nshipster.cn/nscache/">NSCache</a></li>
</ol>

]]></content>
  </entry>
  
</feed>
